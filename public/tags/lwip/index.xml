<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Lwip on Tagore&#39;s Studio</title>
    <link>http://github.wuquantai.com/tags/lwip/</link>
    <description>Recent content in Lwip on Tagore&#39;s Studio</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>zh-cn</language>
    <lastBuildDate>Wed, 17 Aug 2016 08:01:24 +0000</lastBuildDate>
    
	<atom:link href="http://github.wuquantai.com/tags/lwip/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>LwIP TCP Layer Simple analysis</title>
      <link>http://github.wuquantai.com/</link>
      <pubDate>Wed, 06 Jul 2016 10:07:02 +0000</pubDate>
      
      <guid>http://github.wuquantai.com/</guid>
      <description>LwIP Version : 1.4.1; 这里分享一些阅读LwIP协议栈的心得。 有个经验: 源代码才是最权威的资料。 若想用raw api编程，可以参考httpd_raw的代码。若涉及进程间通讯，请参考netconn接口，避免在其它进程内调用非Thead-Safe的函数。 下面说说对一些函数及过程的认识。 (1)** xxx_accept(void *arg, struct tcp_pcb *pcb, err_t err); ** 这个函数的参数注意点: 回调原型：pcb-&amp;gt;accept(pcb-&amp;gt;callback_arg, pcb, err); @*arg: 这里协议栈传递过来的是lpcb，即监听pcb，不要认为和第二个参数相同。因为在tcp_listen_input()里，当有新连接请求到达时会新建一个npcb并将其加入到tcp_active_list里，在初始化npcb时，继承的是lpcb的callback_arg, 而这个callback_arg在新建监听链接时将其赋为lpcb。 @*pcb: 这里是传递进新创建的pcb。在创建APP过程中，需给其分配新的argument, 指定xxx_recv(),xxx_err(), xxx_poll(), xxx_sent()等函数。
(2) struct tcp_pcb **tcp_listen( struct tcp_pcb pcb);
这里传入了一个original pcb，返回一个lpcb，因为listening状态的pcb 只需包含更少的信息。函数内新分配了一个 lpcb, 拷贝必要信息后，将original pcb释放。 对于SO_REUSE选项，在此函数内对比已经在监听List 中的pcb, 允许本地端口号相同，但本地IP号不同的连接可再次监听。
(3) 服务端口监听过程分析 TCP_LISTEN_BACKLOG 选项
此选项使能 TCP 对监听列表允许监听的数量控制。在tcp_listen_input()函数内，
[c]
&amp;hellip; else if (flags &amp;amp; TCP_SYN) { LWIP_DEBUGF(TCP_DEBUG, (&amp;ldquo;TCP connection request %&amp;ldquo;U16_F&amp;rdquo; -&amp;gt; %&amp;ldquo;U16_F&amp;rdquo;.\n&amp;rdquo;, tcphdr-&amp;gt;src, tcphdr-&amp;gt;dest)); #if TCP_LISTEN_BACKLOG if (pcb-&amp;gt;accepts_pending &amp;gt;= pcb-&amp;gt;backlog) { LWIP_DEBUGF(TCP_DEBUG, (&amp;ldquo;tcp_listen_input: listen backlog exceeded for port %&amp;ldquo;U16_F&amp;rdquo;\n&amp;rdquo;, tcphdr-&amp;gt;dest)); return ERR_ABRT; } #endif /* TCP_LISTEN_BACKLOG */ npcb = tcp_alloc(pcb-&amp;gt;prio); &amp;hellip; #if TCP_LISTEN_BACKLOG pcb-&amp;gt;accepts_pending++; #endif &amp;hellip; [/c]</description>
    </item>
    
  </channel>
</rss>