---
title: 'Lwip 内存管理'
date: Wed, 17 Aug 2016 08:01:24 +0000
draft: false
tags: ['LwIP', 'Lwip 内存管理']
---

Lwip 用它自己的动态内存分配方式替代了标准C的malloc(); 它可以使用MEM\_POOL的方式分配内存，即开辟几个不同尺寸的缓冲池，给数据分配合适的缓冲区来存放，就类似于使用数组的方式，可能会比较浪费空间，但是可以有效避免内存碎片产生, 这在第二部分讲。两种方式分别在mem.c memp.c里面实现，下面先总结一般的内存堆分配方式。 (一) **内存堆动态分配方式** \[c\] //mem.h /\*\* Align a memory pointer to the alignment defined by MEM\_ALIGNMENT \* so that ADDR % MEM\_ALIGNMENT == 0 \*/ #ifndef LWIP\_MEM\_ALIGN #define LWIP\_MEM\_ALIGN(addr) ((void \*)(((mem\_ptr\_t)(addr) + MEM\_ALIGNMENT - 1) & ~(mem\_ptr\_t)(MEM\_ALIGNMENT-1))) #endif \[/c\] 首先是内存对齐，这里用到的MCU是按4字节对齐的。这一语句功能是将addr 调整成最靠近addr的且能被4整除的值，其实就是(addr+3)&(~(u32)(0x03))，+3之后有余数的自然就进位了然后再舍掉余数。其实也可以用 addr = (addr&0x03)?(addr+1):addr; 这样应该也可以，更容易理解一些，但是没有上面的简便。 \[c\] #ifndef LWIP\_RAM\_HEAP\_POINTER /\*\* the heap. we need one struct mem at the end and some room for alignment \*/ u8\_t ram\_heap\[MEM\_SIZE\_ALIGNED + (2\*SIZEOF\_STRUCT\_MEM) + MEM\_ALIGNMENT\]; #define LWIP\_RAM\_HEAP\_POINTER ram\_heap #endif /\* LWIP\_RAM\_HEAP\_POINTER \*/ ... /\*\* \* The heap is made up as a list of structs of this type. \* This does not have to be aligned since for getting its size, \* we only use the macro SIZEOF\_STRUCT\_MEM, which automatically alignes. \*/ struct mem { /\*\* index (-> ram\[next\]) of the next struct \*/ mem\_size\_t next; /\*\* index (-> ram\[prev\]) of the previous struct \*/ mem\_size\_t prev; /\*\* 1: this area is used; 0: this area is unused \*/ u8\_t used; }; \[/c\] 这里申请了一个内存堆ram\_heap, 大小包括整个MEM\_SIZE + 两个STRUCT\_MEM的大小 + 4, 假设申请了MEM\_SIZE 为8k。 \[c\] \*\* pointer to the heap (ram\_heap): for alignment, ram is now a pointer instead of an array \*/ static u8\_t \*ram; /\*\* the last entry, always unused! \*/ static struct mem \*ram\_end; /\*\* pointer to the lowest free block, this is used for faster search \*/ static struct mem \*lfree; mem\_init(void) { ... /\* align the heap \*/ ram = (u8\_t \*)LWIP\_MEM\_ALIGN(LWIP\_RAM\_HEAP\_POINTER); /\* initialize the start of the heap \*/ mem = (struct mem \*)(void \*)ram; mem->next = MEM\_SIZE\_ALIGNED; mem->prev = 0; mem->used = 0; ram\_end = (struct mem \*)(void \*)&ram\[MEM\_SIZE\_ALIGNED\]; ram\_end->used = 1; ram\_end->next = MEM\_SIZE\_ALIGNED; ram\_end->prev = MEM\_SIZE\_ALIGNED; /\* initialize the lowest-free pointer to the start of the heap \*/ lfree = (struct mem \*)(void \*)ram; ... } \[/c\] 内存初始化。ram 指向了ram\_heap开头， 并且在开头初始化了一个struct mem。 ram\_end 指向了MEM\_SIZE之后的第一个STRUCT\_MEM, 这里不知道是不是bug，我觉得应该指向&ram\[MEM\_SIZE\_ALIGNED+SIZEOF\_STRUCT\_MEM\]; 没时间了，以后再慢慢研究。 lfree最开始也指向了开头。 ->next 等这些参数都是相对地址，相对ram的，方便之后用数组的方式访问。 \[c\] void \* mem\_malloc(mem\_size\_t size) { /\* Expand the size of the allocated memory region so that we can adjust for alignment. \*/ size = LWIP\_MEM\_ALIGN\_SIZE(size); if(size < MIN\_SIZE\_ALIGNED) { /\* every data block must be at least MIN\_SIZE\_ALIGNED long \*/ size = MIN\_SIZE\_ALIGNED; } if (size > MEM\_SIZE\_ALIGNED) { return NULL; } ... /\* Scan through the heap searching for a free block that is big enough, \* beginning with the lowest free block. \*/ for (ptr = (mem\_size\_t)((u8\_t \*)lfree - ram); ptr < MEM\_SIZE\_ALIGNED - size; ptr = ((struct mem \*)(void \*)&ram\[ptr\])->next) { mem = (struct mem \*)(void \*)&ram\[ptr\]; if ((!mem->used) && (mem->next - (ptr + SIZEOF\_STRUCT\_MEM)) >= size) { /\* mem is not used and at least perfect fit is possible: \* mem->next - (ptr + SIZEOF\_STRUCT\_MEM) gives us the 'user data size' of mem \*/ if (mem->next - (ptr + SIZEOF\_STRUCT\_MEM) >= (size + SIZEOF\_STRUCT\_MEM + MIN\_SIZE\_ALIGNED)) { /\* (in addition to the above, we test if another struct mem (SIZEOF\_STRUCT\_MEM) containing \* at least MIN\_SIZE\_ALIGNED of data also fits in the 'user data space' of 'mem') \* -> split large block, create empty remainder, \* remainder must be large enough to contain MIN\_SIZE\_ALIGNED data: if \* mem->next - (ptr + (2\*SIZEOF\_STRUCT\_MEM)) == size, \* struct mem would fit in but no data between mem2 and mem2->next \* @todo we could leave out MIN\_SIZE\_ALIGNED. We would create an empty \* region that couldn't hold data, but when mem->next gets freed, \* the 2 regions would be combined, resulting in more free memory \*/ ptr2 = ptr + SIZEOF\_STRUCT\_MEM + size; /\* create mem2 struct \*/ mem2 = (struct mem \*)(void \*)&ram\[ptr2\]; mem2->used = 0; mem2->next = mem->next; mem2->prev = ptr; /\* and insert it between mem and mem->next \*/ mem->next = ptr2; mem->used = 1; if (mem2->next != MEM\_SIZE\_ALIGNED) { ((struct mem \*)(void \*)&ram\[mem2->next\])->prev = ptr2; } MEM\_STATS\_INC\_USED(used, (size + SIZEOF\_STRUCT\_MEM)); } else { /\* (a mem2 struct does no fit into the user data space of mem and mem->next will always \* be used at this point: if not we have 2 unused structs in a row, plug\_holes should have \* take care of this). \* -> near fit or excact fit: do not split, no mem2 creation \* also can't move mem->next directly behind mem, since mem->next \* will always be used at this point! \*/ mem->used = 1; MEM\_STATS\_INC\_USED(used, mem->next - (mem\_size\_t)((u8\_t \*)mem - ram)); } } \[/c\] 内存分配函数。首先对齐size，并且size不能太小或者太大，太小容易产生过多的碎片导致后期内存不足。 然后搜索heap,找到适合的块。lfree指向未分配的内存位置，刚开始它是在开头。 ptr=lfree-ram 即是lfree相对ram的位置，即已经用掉的内存大小。 ptr mem 先指向lfree所指的位置，当这块内存未被使用并且剩下的内存大于size时，...略复杂，待续... (二) **内存池的动态分配** 内存池顾名思义就是一个个划分好的池子，不像内存堆一样东西乱堆。 pbuf是协议栈里最常用的数据类型，它有多种类型的存储方式，如下： \[code\] \* - PBUF\_RAM: buffer memory for pbuf is allocated as one large \* chunk. This includes protocol headers as well. \* - PBUF\_ROM: no buffer memory is allocated for the pbuf, even for \* protocol headers. Additional headers must be prepended \* by allocating another pbuf and chain in to the front of \* the ROM pbuf. It is assumed that the memory used is really \* similar to ROM in that it is immutable and will not be \* changed. Memory which is dynamic should generally not \* be attached to PBUF\_ROM pbufs. Use PBUF\_REF instead. \* - PBUF\_REF: no buffer memory is allocated for the pbuf, even for \* protocol headers. It is assumed that the pbuf is only \* being used in a single thread. If the pbuf gets queued, \* then pbuf\_take should be called to copy the buffer. \* - PBUF\_POOL: the pbuf is allocated as a pbuf chain, with pbufs from \* the pbuf pool that is allocated during pbuf\_init(). \[/code\] 我们从pbuf入手研究一下MEM\_POOL内存池的**编写方式**。 pbuf\_alloc(PBUF\_POOL)调用的是: p = (struct pbuf \*)memp\_malloc(MEMP\_PBUF\_POOL); 我们来看看MEMP\_PBUF\_POOL是如何声明的： \[c\] //memp\_std.h /\* \* A list of pools of pbuf's used by LWIP. \* \* LWIP\_PBUF\_MEMPOOL(pool\_name, number\_elements, pbuf\_payload\_size, pool\_description) \* creates a pool name MEMP\_pool\_name. description is used in stats.c \* This allocates enough space for the pbuf struct and a payload. \* (Example: pbuf\_payload\_size=0 allocates only size for the struct) \*/ LWIP\_PBUF\_MEMPOOL(PBUF, MEMP\_NUM\_PBUF, 0, "PBUF\_REF/ROM") LWIP\_PBUF\_MEMPOOL(PBUF\_POOL, PBUF\_POOL\_SIZE, PBUF\_POOL\_BUFSIZE, "PBUF\_POOL") /\* This treats "pbuf pools" just like any other pool. \* Allocates buffers for a pbuf struct AND a payload size \*/ #define LWIP\_PBUF\_MEMPOOL(name, num, payload, desc) LWIP\_MEMPOOL(name, num, (MEMP\_ALIGN\_SIZE(sizeof(struct pbuf)) + MEMP\_ALIGN\_SIZE(payload)), desc) \[/c\] memp\_std.h里定义了各种类型POOL. \[c\] //memp.c /\*\* This array holds the element sizes of each pool. \*/ const u16\_t memp\_sizes\[MEMP\_MAX\] = { #define LWIP\_MEMPOOL(name,num,size,desc) LWIP\_MEM\_ALIGN\_SIZE(size), #include "lwip/memp\_std.h" }; /\*\* This array holds the number of elements in each pool. \*/ static const u16\_t memp\_num\[MEMP\_MAX\] = { #define LWIP\_MEMPOOL(name,num,size,desc) (num), #include "lwip/memp\_std.h" }; /\*\* This is the actual memory used by the pools (all pools in one big block). \*/ static u8\_t memp\_memory\[MEM\_ALIGNMENT - 1 #define LWIP\_MEMPOOL(name,num,size,desc) + ( (num) \* (MEMP\_SIZE + MEMP\_ALIGN\_SIZE(size) ) ) #include "lwip/memp\_std.h" \]; \[/c\] memp.c 定义了 几个数组来保存每个pool的元素大小和数量。定义一个memp\_memory\[\]内存块保存所有的pool。 \[c\] /\* Create the list of all memory pools managed by memp. MEMP\_MAX represents a NULL pool at the end \*/ typedef enum { #define LWIP\_MEMPOOL(name,num,size,desc) MEMP\_##name, #include "lwip/memp\_std.h" MEMP\_MAX } memp\_t; \[/c\] ## 是连接符号。这样memp\_t的枚举类型里就有各种的POOL名字，如编译之后就成为： \[c\] typedef enum { MEMP\_PBUF, MEMP\_PBUF\_POOL, ... MEMP\_MAX } memp\_t; \[/c\] **总结一下**， memp\_std.h里包含许多条POOL的声明： LWIP\_PBUF\_MEMPOOL(PBUF\_POOL, PBUF\_POOL\_SIZE, PBUF\_POOL\_BUFSIZE, "PBUF\_POOL") 然后在memp.c 里面利用这种套路将memp\_std.h 里的声明全包进去: \[c\] static u8\_t memp\_memory\[MEM\_ALIGNMENT - 1 #define LWIP\_MEMPOOL(name,num,size,desc) + ( (num) \* (MEMP\_SIZE + MEMP\_ALIGN\_SIZE(size) ) ) #include "lwip/memp\_std.h" \]; \[/c\] 就可以生成我们想要的结果。 \[c\] static u8\_t memp\_memory\[MEM\_ALIGNMENT - 1 + ( (num) \* (MEMP\_SIZE + MEMP\_ALIGN\_SIZE(size) ) ) + ... \]; \[/c\] 这是一种很聪明的写法。领教了！ 回过头来我们就明白MEMP\_PBUF\_POOL内存到底多大了，Demo设置的是48\*512byte。 另外前面有一个是MEMP\_PBUF的内存池，它的BUFSIZE是0，仅能用来保存结构体指针，所以是专门给PBUF\_REF/ROM类型使用的。 声明好内存池后，我们看看p = (struct pbuf \*)memp\_malloc(MEMP\_PBUF\_POOL); 是怎么工作的。 \[c\] /\*\* This array holds the first free element of each pool. \* Elements form a linked list. \*/ static struct memp \*memp\_tab\[MEMP\_MAX\]; /\*\* \* Initialize this module. \* \* Carves out memp\_memory into linked lists for each pool-type. \*/ void memp\_init(void) { struct memp \*memp; u16\_t i, j; ... /\* for every pool: \*/ for (i = 0; i < MEMP\_MAX; ++i) { memp\_tab\[i\] = NULL; /\* create a linked list of memp elements \*/ for (j = 0; j < memp\_num\[i\]; ++j) { memp->next = memp\_tab\[i\]; memp\_tab\[i\] = memp; memp = (struct memp \*)(void \*)((u8\_t \*)memp + MEMP\_SIZE + memp\_sizes\[i\] ); } } ... } /\*\* \* Get an element from a specific pool. \* \* @param type the pool to get an element from \* \* the debug version has two more parameters: \* @param file file name calling this function \* @param line number of line where this function is called \* \* @return a pointer to the allocated memory or a NULL pointer on error \*/ void \* #if !MEMP\_OVERFLOW\_CHECK memp\_malloc(memp\_t type) #else memp\_malloc\_fn(memp\_t type, const char\* file, const int line) #endif { struct memp \*memp; SYS\_ARCH\_DECL\_PROTECT(old\_level); SYS\_ARCH\_PROTECT(old\_level); memp = memp\_tab\[type\]; if (memp != NULL) { memp\_tab\[type\] = memp->next; memp = (struct memp\*)(void \*)((u8\_t\*)memp + MEMP\_SIZE); } else { ... } SYS\_ARCH\_UNPROTECT(old\_level); return memp; } /\*\* \* Put an element back into its pool. \* \* @param type the pool where to put mem \* @param mem the memp element to free \*/ void memp\_free(memp\_t type, void \*mem) { struct memp \*memp; SYS\_ARCH\_DECL\_PROTECT(old\_level); ... memp = (struct memp \*)(void \*)((u8\_t\*)mem - MEMP\_SIZE); SYS\_ARCH\_PROTECT(old\_level); memp->next = memp\_tab\[type\]; memp\_tab\[type\] = memp; SYS\_ARCH\_UNPROTECT(old\_level); } \[/c\] memp\_tab\[\]在init 函数里初始化，将内存池的每个元素链成链表。做成链表就很简单了，memp\_malloc() 的时候直接就是返回memp\_tab\[\]所指向的内存块即可，并把memp\_tab指向下一个，相当于从链表中剔除。memp\_free()的时候就把它重新链上链表即可。 具体的就去看源代码了，这里不方便贴太多。 **后记之Lwip内存使用** 从网卡驱动部分的源代码看，所有输入的包使用的PBUF\_POOL的内存，用户在分配自己包的内存时，千万不要用PBUF\_POOL类型的内存，因为如果PBUF\_POOL很有可能会被外来的包全部占用，导致一直分配不到内存。这点从netbuf\_alloc函数里可以看到，它使用的是PBUF\_RAM类型的内存，就是有此意。还有从tcp\_write函数中也可以看到，在flag 有WRITE\_COPY 标志时，调用的也是PBUF\_RAM类型的内存。 从协议栈输入到应用层，都只是pbuf头的层层剥离与指针的传递，没有任何的数据拷贝过程，这正是LwIP的特点所在，为嵌入式系统而写的轻量级协议栈。只有在tcp\_write 发送数据时，可以选择一个WRITE\_COPY选项，将用户的数据拷贝到tcp层，之后用户即可释放自己的内存，剩下的事就由tcp负责处理。udp的发送过程没有数据拷贝，如果所发送的pbuf前头没有足够的内存放包头的话，会申请一点PBUF\_RAM类型的内存放传输层及以下的帧头，把数据chain到其之后。 另外内存分配函数是可以放心在其它线程内存调用的，但NO ISR！用户若想单独想开辟一个内存池，可以在memp\_std里定义即可。