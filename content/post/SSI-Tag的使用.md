---
title: 'SSI Tag的使用'
date: Tue, 12 Apr 2016 03:00:09 +0000
draft: false
tags: ['shtm', 'shtml', 'SSI', 'Web Develop']
---

这里先说最原始的使用SSI tag的方式，因为这样做在C开发中最简单。跟后来通用的web服务器的SSI有点不一样，因为后来为了使上层开发更方便，又进行了一些封装。 最原始的SSI是这样规定的，如在html中嵌入SSI tag。使用 \[code\]<--#tagname-->\[/code\] ;，则当Web服务器生成网页时，会将当前的标签后插入所指定的内容。这就是SSI Tag的作用。 SSI可以说是最初动态生成网页的方法，不仅仅是用来插入一些变量也可以直接插入javascript、json等等你想要发送给客户端的内容！一般用SSI来插入静态变量比较方便，如果是插入input框的当前值的话，可以往SSI中插入一段javascript代码或者是json格式的数据，再用javascript把这些实时的值加载进input框。 \[html\] <pre lang="html"></pre> <b><!--#modname--></b> <table width="31%"> <tbody> <tr> <td class="gr">Name:</td> </tr> <tr> <td class="gr" width="25%">IP Address:</td> <!--#ipaddr--> <td class="gr">MAC Address:</td> <!--#macaddr--></tr> </tbody> </table> \[/html\] 其Tag 在Web 服务端代码中作如下定义,并定义其序号的宏。 \[c\] static const char \*g\_pcConfigSSITags\[\] = { "ipaddr", // SSI\_INDEX\_IPADDR "macaddr", // SSI\_INDEX\_MACADDR "p0br", // SSI\_INDEX\_P0BR "p0sb", // SSI\_INDEX\_P0SB "p0p", // SSI\_INDEX\_P0P "p0bc", // SSI\_INDEX\_P0BC "p0fc", // SSI\_INDEX\_P0FC "p0tt", // SSI\_INDEX\_P0TT "p0tlp", // SSI\_INDEX\_P0TLP "p0trp", // SSI\_INDEX\_P0TRP "p0tip", // SSI\_INDEX\_P0TIP "p0tip1", // SSI\_INDEX\_P0TIP1 "p0tip2", // SSI\_INDEX\_P0TIP2 "p0tip3", // SSI\_INDEX\_P0TIP3 "p0tip4", // SSI\_INDEX\_P0TIP4 "p0tnm", // SSI\_INDEX\_P0TNM "p1br", // SSI\_INDEX\_P1BR "p1sb", // SSI\_INDEX\_P1SB "p1p", // SSI\_INDEX\_P1P "p1bc", // SSI\_INDEX\_P1BC "p1fc", // SSI\_INDEX\_P1FC "p1tt", // SSI\_INDEX\_P1TT "p1tlp", // SSI\_INDEX\_P1TLP "p1trp", // SSI\_INDEX\_P1TRP "p1tip", // SSI\_INDEX\_P1TIP "p1tip1", // SSI\_INDEX\_P1TIP1 "p1tip2", // SSI\_INDEX\_P1TIP2 "p1tip3", // SSI\_INDEX\_P1TIP3 "p1tip4", // SSI\_INDEX\_P1TIP4 "p1tnm", // SSI\_INDEX\_P1TNM "modname", // SSI\_INDEX\_MODNAME "pnpport", // SSI\_INDEX\_PNPPORT "disable", // SSI\_INDEX\_DISABLE ... }; \[/c\] 然后在SSIHandler里如下解析,当每次serving a page with a \`\`.ssi'', \`\`.shtml'' or \`\`.shtm'' file extension 的时候都会将SSI tag进行替换。 \[c\] static uint16\_t ConfigSSIHandler(int iIndex, char \*pcInsert, int iInsertLen) { uint32\_t ui32Port; int iCount; const char \*pcString; // // Which SSI tag are we being asked to provide content for? // switch(iIndex) { // // The local IP address tag "ipaddr". // case SSI\_INDEX\_IPADDR: { uint32\_t ui32IPAddr; ui32IPAddr = lwIPLocalIPAddrGet(); return(usnprintf(pcInsert, iInsertLen, "%d.%d.%d.%d", ((ui32IPAddr &gt;&gt; 0) &amp; 0xFF), ((ui32IPAddr &gt;&gt; 8) &amp; 0xFF), ((ui32IPAddr &gt;&gt; 16) &amp; 0xFF), ((ui32IPAddr &gt;&gt; 24) &amp; 0xFF))); } // // The local MAC address tag "macaddr". // case SSI\_INDEX\_MACADDR: { uint8\_t pucMACAddr\[6\]; lwIPLocalMACGet(pucMACAddr); return(usnprintf(pcInsert, iInsertLen, "%02X-%02X-%02X-%02X-%02X-%02X", pucMACAddr\[0\], pucMACAddr\[1\], pucMACAddr\[2\], pucMACAddr\[3\], pucMACAddr\[4\], pucMACAddr\[5\])); } ... // // All other tags are unknown. // default: { return(usnprintf(pcInsert, iInsertLen, "<b><i>Tag %d unknown!</i></b>", iIndex)); } } } \[/c\] 学习了SSI tag怎么用的，然后可以再深入研究下在文本中检索 SSI tag 的写法。这里用了个状态机，按顺序搜索ssi lead in 和lead out。 \[c\] /\* We have sent all the data that was already parsed so continue parsing \* the buffer contents looking for SSI tags. \*/ while((hs->parse\_left) && (err == ERR\_OK)) { /\* @todo: somewhere in this loop, 'len' should grow again... \*/ if (len == 0) { return data\_to\_send; } switch(hs->tag\_state) { case TAG\_NONE: /\* We are not currently processing an SSI tag so scan for the \* start of the lead-in marker. \*/ if(\*hs->parsed == g\_pcTagLeadIn\[0\]) { /\* We found what could be the lead-in for a new tag so change \* state appropriately. \*/ hs->tag\_state = TAG\_LEADIN; hs->tag\_index = 1; #if !LWIP\_HTTPD\_SSI\_INCLUDE\_TAG hs->tag\_started = hs->parsed; #endif /\* !LWIP\_HTTPD\_SSI\_INCLUDE\_TAG \*/ } /\* Move on to the next character in the buffer \*/ hs->parse\_left--; hs->parsed++; break; case TAG\_LEADIN: /\* We are processing the lead-in marker, looking for the start of \* the tag name. \*/ /\* Have we reached the end of the leadin? \*/ if(hs->tag\_index == LEN\_TAG\_LEAD\_IN) { hs->tag\_index = 0; hs->tag\_state = TAG\_FOUND; } else { /\* Have we found the next character we expect for the tag leadin? \*/ if(\*hs->parsed == g\_pcTagLeadIn\[hs->tag\_index\]) { /\* Yes - move to the next one unless we have found the complete \* leadin, in which case we start looking for the tag itself \*/ hs->tag\_index++; } else { /\* We found an unexpected character so this is not a tag. Move \* back to idle state. \*/ hs->tag\_state = TAG\_NONE; } /\* Move on to the next character in the buffer \*/ hs->parse\_left--; hs->parsed++; } break; case TAG\_FOUND: /\* We are reading the tag name, looking for the start of the \* lead-out marker and removing any whitespace found. \*/ /\* Remove leading whitespace between the tag leading and the first \* tag name character. \*/ if((hs->tag\_index == 0) && ((\*hs->parsed == ' ') || (\*hs->parsed == '\\t') || (\*hs->parsed == '\\n') || (\*hs->parsed == '\\r'))) { /\* Move on to the next character in the buffer \*/ hs->parse\_left--; hs->parsed++; break; } /\* Have we found the end of the tag name? This is signalled by \* us finding the first leadout character or whitespace \*/ if((\*hs->parsed == g\_pcTagLeadOut\[0\]) || (\*hs->parsed == ' ') || (\*hs->parsed == '\\t') || (\*hs->parsed == '\\n') || (\*hs->parsed == '\\r')) { if(hs->tag\_index == 0) { /\* We read a zero length tag so ignore it. \*/ hs->tag\_state = TAG\_NONE; } else { /\* We read a non-empty tag so go ahead and look for the \* leadout string. \*/ hs->tag\_state = TAG\_LEADOUT; LWIP\_ASSERT("hs->tag\_index <= 0xff", hs->tag\_index <= 0xff); hs->tag\_name\_len = (u8\_t)hs->tag\_index; hs->tag\_name\[hs->tag\_index\] = '\\0'; if(\*hs->parsed == g\_pcTagLeadOut\[0\]) { hs->tag\_index = 1; } else { hs->tag\_index = 0; } } } else { /\* This character is part of the tag name so save it \*/ if(hs->tag\_index < LWIP\_HTTPD\_MAX\_TAG\_NAME\_LEN) { hs->tag\_name\[hs->tag\_index++\] = \*hs->parsed; } else { /\* The tag was too long so ignore it. \*/ hs->tag\_state = TAG\_NONE; } } /\* Move on to the next character in the buffer \*/ hs->parse\_left--; hs->parsed++; break; /\* We are looking for the end of the lead-out marker. \*/ case TAG\_LEADOUT: /\* Remove leading whitespace between the tag leading and the first \* tag leadout character. \*/ if((hs->tag\_index == 0) && ((\*hs->parsed == ' ') || (\*hs->parsed == '\\t') || (\*hs->parsed == '\\n') || (\*hs->parsed == '\\r'))) { /\* Move on to the next character in the buffer \*/ hs->parse\_left--; hs->parsed++; break; } /\* Have we found the next character we expect for the tag leadout? \*/ if(\*hs->parsed == g\_pcTagLeadOut\[hs->tag\_index\]) { /\* Yes - move to the next one unless we have found the complete \* leadout, in which case we need to call the client to process \* the tag. \*/ /\* Move on to the next character in the buffer \*/ hs->parse\_left--; hs->parsed++; if(hs->tag\_index == (LEN\_TAG\_LEAD\_OUT - 1)) { /\* Call the client to ask for the insert string for the \* tag we just found. \*/ #if LWIP\_HTTPD\_SSI\_MULTIPART hs->tag\_part = 0; /\* start with tag part 0 \*/ #endif /\* LWIP\_HTTPD\_SSI\_MULTIPART \*/ get\_tag\_insert(hs); /\* Next time through, we are going to be sending data \* immediately, either the end of the block we start \* sending here or the insert string. \*/ hs->tag\_index = 0; hs->tag\_state = TAG\_SENDING; hs->tag\_end = hs->parsed; #if !LWIP\_HTTPD\_SSI\_INCLUDE\_TAG hs->parsed = hs->tag\_started; #endif /\* !LWIP\_HTTPD\_SSI\_INCLUDE\_TAG\*/ /\* If there is any unsent data in the buffer prior to the \* tag, we need to send it now. \*/ if (hs->tag\_end > hs->file) { /\* How much of the data can we send? \*/ #if LWIP\_HTTPD\_SSI\_INCLUDE\_TAG if(len > hs->tag\_end - hs->file) { len = (u16\_t)(hs->tag\_end - hs->file); } #else /\* LWIP\_HTTPD\_SSI\_INCLUDE\_TAG\*/ if(len > hs->tag\_started - hs->file) { /\* we would include the tag in sending \*/ len = (u16\_t)(hs->tag\_started - hs->file); } #endif /\* LWIP\_HTTPD\_SSI\_INCLUDE\_TAG\*/ err = http\_write(pcb, hs->file, &len, HTTP\_IS\_DATA\_VOLATILE(hs)); if (err == ERR\_OK) { data\_to\_send = true; #if !LWIP\_HTTPD\_SSI\_INCLUDE\_TAG if(hs->tag\_started <= hs->file) { /\* pretend to have sent the tag, too \*/ len += hs->tag\_end - hs->tag\_started; } #endif /\* !LWIP\_HTTPD\_SSI\_INCLUDE\_TAG\*/ hs->file += len; hs->left -= len; } } } else { hs->tag\_index++; } } else { /\* We found an unexpected character so this is not a tag. Move \* back to idle state. \*/ hs->parse\_left--; hs->parsed++; hs->tag\_state = TAG\_NONE; } break; /\* \* We have found a valid tag and are in the process of sending \* data as a result of that discovery. We send either remaining data \* from the file prior to the insert point or the insert string itself. \*/ case TAG\_SENDING: /\* Do we have any remaining file data to send from the buffer prior \* to the tag? \*/ if(hs->tag\_end > hs->file) { /\* How much of the data can we send? \*/ #if LWIP\_HTTPD\_SSI\_INCLUDE\_TAG if(len > hs->tag\_end - hs->file) { len = (u16\_t)(hs->tag\_end - hs->file); } #else /\* LWIP\_HTTPD\_SSI\_INCLUDE\_TAG\*/ LWIP\_ASSERT("hs->started >= hs->file", hs->tag\_started >= hs->file); if (len > hs->tag\_started - hs->file) { /\* we would include the tag in sending \*/ len = (u16\_t)(hs->tag\_started - hs->file); } #endif /\* LWIP\_HTTPD\_SSI\_INCLUDE\_TAG\*/ if (len != 0) { err = http\_write(pcb, hs->file, &len, HTTP\_IS\_DATA\_VOLATILE(hs)); } else { err = ERR\_OK; } if (err == ERR\_OK) { data\_to\_send = true; #if !LWIP\_HTTPD\_SSI\_INCLUDE\_TAG if(hs->tag\_started <= hs->file) { /\* pretend to have sent the tag, too \*/ len += hs->tag\_end - hs->tag\_started; } #endif /\* !LWIP\_HTTPD\_SSI\_INCLUDE\_TAG\*/ hs->file += len; hs->left -= len; } } else { #if LWIP\_HTTPD\_SSI\_MULTIPART if(hs->tag\_index >= hs->tag\_insert\_len) { /\* Did the last SSIHandler have more to send? \*/ if (hs->tag\_part != HTTPD\_LAST\_TAG\_PART) { /\* If so, call it again \*/ hs->tag\_index = 0; get\_tag\_insert(hs); } } #endif /\* LWIP\_HTTPD\_SSI\_MULTIPART \*/ /\* Do we still have insert data left to send? \*/ if(hs->tag\_index < hs->tag\_insert\_len) { /\* We are sending the insert string itself. How much of the \* insert can we send? \*/ if(len > (hs->tag\_insert\_len - hs->tag\_index)) { len = (hs->tag\_insert\_len - hs->tag\_index); } /\* Note that we set the copy flag here since we only have a \* single tag insert buffer per connection. If we don't do \* this, insert corruption can occur if more than one insert \* is processed before we call tcp\_output. \*/ err = http\_write(pcb, &(hs->tag\_insert\[hs->tag\_index\]), &len, HTTP\_IS\_TAG\_VOLATILE(hs)); if (err == ERR\_OK) { data\_to\_send = true; hs->tag\_index += len; /\* Don't return here: keep on sending data \*/ } } else { /\* We have sent all the insert data so go back to looking for \* a new tag. \*/ LWIP\_DEBUGF(HTTPD\_DEBUG, ("Everything sent.\\n")); hs->tag\_index = 0; hs->tag\_state = TAG\_NONE; #if !LWIP\_HTTPD\_SSI\_INCLUDE\_TAG hs->parsed = hs->tag\_end; #endif /\* !LWIP\_HTTPD\_SSI\_INCLUDE\_TAG\*/ } break; } } } \[/c\] 其实看懂了SSI实现的原理，就可以联想到简单的php引擎是如何处理php代码的。另外也可以看出ssi的处理效率是比较低的，因为需要检索整个文本的ssi tag。php也类似，所以后面会出现编译型的php引擎，预先把php代码和文本分开，这样执行效率就高很多。