---
title: 'Lwip 里的信号量、邮箱、线程'
date: Tue, 12 Jul 2016 01:42:53 +0000
draft: false
categories:
  - "Embedded"
tags: ['LwIP', 'Lwip 信号量', 'Lwip 邮箱']
---

这里简单分析总结一下Lwip sys\_arch.c 中的信号量、邮箱、进程相关的内容。系统用的是FreeRTOS。 \[c\] "sys\_arch.c" /\* An array to hold the memory for the available semaphores. \*/ static sem\_t sems\[SYS\_SEM\_MAX\]; /\* An array to hold the memory for the available mailboxes. \*/ static mbox\_t mboxes\[SYS\_MBOX\_MAX\]; "sys\_arch.h" ///\* A structure to hold the variables for a sys\_sem\_t. \*/ typedef struct { xQueueHandle queue; signed char buffer\[sizeof(void \*) + portQUEUE\_OVERHEAD\_BYTES\]; } sem\_t; /\* A structure to hold the variables for a sys\_mbox\_t. \*/ typedef struct { xQueueHandle queue; signed char buffer\[(sizeof(void \*) \* MBOX\_MAX) + portQUEUE\_OVERHEAD\_BYTES\]; } mbox\_t; \[/c\] 这里创建了两个全局结构体数组来管理semaphores and mailboxes. 有个不明白的地方是，结构体里的buffer是用来作什么的？ \[c\] sys\_sem\_new(sys\_sem\_t \*sem, u8\_t count){ ... /\* Create a single-entry queue to act as a semaphore. \*/ #if RTOS\_FREERTOS sem->queue = xQueueCreate(1, sizeof(void \*)); if(sem->queue == NULL) { #endif /\* RTOS\_FREERTOS \*/ ... } sys\_mbox\_new(sys\_mbox\_t \*mbox, int size){ ... #if RTOS\_FREERTOS /\* Create a queue for this mailbox. \*/ mbox->queue = xQueueCreate(size, sizeof(void \*)); if(mbox == NULL) { #endif /\* RTOS\_FREERTOS \*/ ... } \[/c\] 这里的semaphore其实用的是长度为1的queue来实现。mbox是长度为size的queue，其中消息对象类型都是void \*，由于freertos在把消息送入队列和提取出队列都是复制的方式（应该是类似ringbuf的操作，没深入研究），所以这里为了提高效率，把对象封装一个消息结构体，只传递指针。在作消息传递时要特别注意内存的分配和释放，以免造成内存泄漏。 这里还要总结的一点是，类似于这种xxx\_new, xxx\_alloc的函数，用来分配对向内存的函数，传递进去的是指针的地址，因为要将指针指向新分配的内存，所以传进去的为指针的地址。 如这样调用： \[c\] if (sys\_sem\_new(&conn->op\_completed, 0) != ERR\_OK) { goto free\_and\_return; } \[/c\] Lwip 的Thread是用FreeRTOS的xTaskCreate()来实现的。这里有个问题, TI的sys\_arch.c里的sys\_thread\_new的实现，又用mem\_malloc()分配了栈内存，是不是多此一举了，因为xTaskCreate里会为这个任务分配栈内存。这里似乎没有任何用处。 \[c\] sys\_thread\_t sys\_thread\_new(const char \*name, lwip\_thread\_fn thread, void \*arg, int stacksize, int prio) { sys\_thread\_t created\_thread; void \*data; u32\_t i; /\* Find a thread that is not in use. \*/ for(i = 0; i < SYS\_THREAD\_MAX; i++) { if(threads\[i\].stackstart == NULL) { break; } } if(i == SYS\_THREAD\_MAX) { return NULL; } /\* Allocate memory for the thread's stack. \*/ data = mem\_malloc(stacksize); if(!data) { return NULL; } /\* Save the details of this thread. \*/ threads\[i\].stackstart = data; threads\[i\].stackend = (void \*)((char \*)data + stacksize); threads\[i\].thread = thread; threads\[i\].arg = arg; /\* Create a new thread. \*/ #if RTOS\_FREERTOS if(xTaskCreate(sys\_arch\_thread, (signed portCHAR \*)name, stacksize/sizeof(int), (void \*)i, tskIDLE\_PRIORITY+prio, &threads\[i\].taskhandle) != pdTRUE){ threads\[i\].stackstart = NULL; threads\[i\].stackend = NULL; return NULL; } created\_thread = threads\[i\].taskhandle; #endif /\* RTOS\_FREERTOS \*/ /\* Return this thread. \*/ return created\_thread; } \[/c\]