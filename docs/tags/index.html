<!DOCTYPE html>
<html lang="zh-cn">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
    
    <title>Tagore&#39;s Studio </title>
    <meta name="viewport" content="width=device-width,minimum-scale=1">
    <meta name="generator" content="Hugo 0.68.3" />
    
    
      <META NAME="ROBOTS" CONTENT="NOINDEX, NOFOLLOW">
    

    
    
      <link href="/dist/css/app.1cb140d8ba31d5b2f1114537dd04802a.css" rel="stylesheet">
    

    

    
      
    

    
    
      <link href="/tags/index.xml" rel="alternate" type="application/rss+xml" title="Tagore&#39;s Studio" />
      <link href="/tags/index.xml" rel="feed" type="application/rss+xml" title="Tagore&#39;s Studio" />
      
    
    
    <meta property="og:title" content="Tags" />
<meta property="og:description" content="The last theme you&#39;ll ever need. Maybe." />
<meta property="og:type" content="website" />
<meta property="og:url" content="http://github.wuquantai.com/tags/" />
<meta property="og:updated_time" content="2019-04-20T13:59:51+00:00" />
<meta itemprop="name" content="Tags">
<meta itemprop="description" content="The last theme you&#39;ll ever need. Maybe."><meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="Tags"/>
<meta name="twitter:description" content="The last theme you&#39;ll ever need. Maybe."/>

  </head>

  <body class="ma0 avenir bg-near-white">

    

  
  
  <header class="cover bg-top" style="background-image: url('http://github.wuquantai.com/images/gohugo-default-sample-hero-image.jpg');">
    <div class="bg-black-60">
      <nav class="pv3 ph3 ph4-ns" role="navigation">
  <div class="flex-l justify-between items-center center">
    <a href="http://github.wuquantai.com" class="f3 fw2 hover-white no-underline white-90 dib">
      Tagore&#39;s Studio
    </a>
    <div class="flex-l items-center">
      

      
        <ul class="pl0 mr3">
          
          <li class="list f5 f4-ns fw4 dib pr3">
            <a class="hover-white no-underline white-90" href="/about/" title="About page">
              About
            </a>
          </li>
          
          <li class="list f5 f4-ns fw4 dib pr3">
            <a class="hover-white no-underline white-90" href="/contact/" title="Contact page">
              Contact
            </a>
          </li>
          
          <li class="list f5 f4-ns fw4 dib pr3">
            <a class="hover-white no-underline white-90" href="/post/" title="Posts page">
              Posts
            </a>
          </li>
          
        </ul>
      
      




<a href="https://twitter.com/TagoreWu" target="_blank" class="link-transition twitter link dib z-999 pt3 pt0-l mr1" title="Twitter link" rel="noopener" aria-label="follow on Twitter——Opens in a new window">
  <svg height="32px"  style="enable-background:new 0 0 67 67;" version="1.1" viewBox="0 0 67 67" width="32px" xml:space="preserve" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink"><path d="M37.167,22.283c-2.619,0.953-4.274,3.411-4.086,6.101  l0.063,1.038l-1.048-0.127c-3.813-0.487-7.145-2.139-9.974-4.915l-1.383-1.377l-0.356,1.017c-0.754,2.267-0.272,4.661,1.299,6.271  c0.838,0.89,0.649,1.017-0.796,0.487c-0.503-0.169-0.943-0.296-0.985-0.233c-0.146,0.149,0.356,2.076,0.754,2.839  c0.545,1.06,1.655,2.097,2.871,2.712l1.027,0.487l-1.215,0.021c-1.173,0-1.215,0.021-1.089,0.467  c0.419,1.377,2.074,2.839,3.918,3.475l1.299,0.444l-1.131,0.678c-1.676,0.976-3.646,1.526-5.616,1.568  C19.775,43.256,19,43.341,19,43.405c0,0.211,2.557,1.397,4.044,1.864c4.463,1.377,9.765,0.783,13.746-1.568  c2.829-1.673,5.657-5,6.978-8.221c0.713-1.716,1.425-4.851,1.425-6.354c0-0.975,0.063-1.102,1.236-2.267  c0.692-0.678,1.341-1.419,1.467-1.631c0.21-0.403,0.188-0.403-0.88-0.043c-1.781,0.636-2.033,0.551-1.152-0.402  c0.649-0.678,1.425-1.907,1.425-2.267c0-0.063-0.314,0.042-0.671,0.233c-0.377,0.212-1.215,0.53-1.844,0.72l-1.131,0.361l-1.027-0.7  c-0.566-0.381-1.361-0.805-1.781-0.932C39.766,21.902,38.131,21.944,37.167,22.283z M33,64C16.432,64,3,50.569,3,34S16.432,4,33,4  s30,13.431,30,30S49.568,64,33,64z" style="fill-rule:evenodd;clip-rule:evenodd;fill:;"/></svg>

<span class="new-window"><svg  height="8px"  style="enable-background:new 0 0 1000 1000;" version="1.1" viewBox="0 0 1000 1000" width="8px" xml:space="preserve" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" >
<path d="M598 128h298v298h-86v-152l-418 418-60-60 418-418h-152v-86zM810 810v-298h86v298c0 46-40 86-86 86h-596c-48 0-86-40-86-86v-596c0-46 38-86 86-86h298v86h-298v596h596z" style="fill-rule:evenodd;clip-rule:evenodd;fill:;"/>
</svg>
</span></a>











    </div>
  </div>
</nav>

      <div class="tc-l pv4 pv6-l ph3 ph4-ns">
        <h1 class="f2 f-subheadline-l fw2 white-90 mb0 lh-title">
          Tags
        </h1>
        
      </div>
    </div>
  </header>


    <main class="pb7" role="main">
      
    
  <article class="cf pa3 pa4-m pa4-l">
    <div class="measure-wide-l center f4 lh-copy nested-copy-line-height nested-links nested-img mid-gray">
      
    </div>
  </article>
  <div class="mw8 center">
    <section class="ph4">
      
        <h2 class="f1">
          <a href="/tags/ac7020" class="link blue hover-black">
            Tag: ac7020
          </a>
        </h2>
        
          <div class="relative w-100 mb4 bg-white nested-copy-line-height">
  <div class="bg-white mb3 pa4 gray overflow-hidden">
    <span class="f6 db">Post</span>
    <h1 class="f3 near-black">
      <a href="http://github.wuquantai.com/" class="link black dim">
        编译PYNQ 在ZCU102上的镜像
      </a>
    </h1>
    <div class="nested-links f5 lh-copy nested-copy-line-height">
      由于PYNQ官方没有编译好的ZCU102的镜像，所以需要自己手动编译。这里记录一下编译过程。
因为手头上的ZCU102 批次比较新，所以目前只能使用2018.3 版本的SDK才能BOOT起来。（应该是由于换了DDR型号了，所以老版本的镜像是BOOT不起来的。板子版本是REVISION 1.1的 新批号）
PYNQ 版本Xilinx Tool 版本对应 ** 参考：**
https://blog.csdn.net/vacajk/article/details/84728062 https://github.com/Xilinx/PYNQ/tree/image_v2.4/sdbuild
https://pynq.readthedocs.io/en/latest/pynq_sd_card.html#pynq-sd-card
准备工作  使用事先编译好的文件系统: bionic.aarch64.2.4.img * ZCU102 BSP: xilinx-zcu102-v2018.3-final.bsp * 如果非官方板子，比如黑金的AC7020, 没有BSP, 则可以从vivado 工程导出hdf 文件，给petalinux 生成一个bsp * 安装好SDSoc2018.3, PetaLinux2018.3 * 系统环境 Ubuntu 1604-64  编译步骤 # 下载 pynq $ git clone https://github.com/Xilinx/PYNQ.git $ cd PYNQ $ git checkout image_v2.4 # 检查依赖环境，qemu，crosstool-ng $ cd ./sdbuild/ $ ./scripts/setup_host.sh # 准备 ZCU102 setting $ cp -rf ./boards/ZCU104 ./boards/ZCU102 $ rm -rf .
    </div>
  </div>
</div>

        
      
        <h2 class="f1">
          <a href="/tags/apache" class="link blue hover-black">
            Tag: apache
          </a>
        </h2>
        
          <div class="relative w-100 mb4 bg-white nested-copy-line-height">
  <div class="bg-white mb3 pa4 gray overflow-hidden">
    <span class="f6 db">Post</span>
    <h1 class="f3 near-black">
      <a href="http://github.wuquantai.com/" class="link black dim">
        [转]Apache与Tomcat有什么关系和区别
      </a>
    </h1>
    <div class="nested-links f5 lh-copy nested-copy-line-height">
      经常在用apache和tomcat等这些服务器，可是总感觉还是不清楚他们之间有什么关系，在用tomcat的时候总出现apache，总感到迷惑，到底谁是主谁是次，因此特意在网上查询了一些这方面的资料，总结了一下： 一 apache支持静态页，tomcat支持动态的，比如servlet等，一般使用apache+tomcat的话，apache只是作为一个转发，对jsp的处理是由tomcat来处理的。 apache可以支持php\cgi\perl,但是要使用java的话，你需要tomcat在apache后台支撑，将java请求由apache转发给tomcat处理。 apache是web服务器,Tomcat是应用（java）服务器，它只是一个servlet(jsp也翻译成servlet)容器，可以认为是apache的扩展，但是可以独立于apache运行。 这两个有以下几点可以比较的： 1、两者都是apache组织开发的 2、两者都有HTTP服务的功能 3、两者都是免费的 不同点： Apache是专门用了提供HTTP服务的，以及相关配置的（例如虚拟主机、URL转发等等） Tomcat是Apache组织在符合J2EE的JSP、Servlet标准下开发的一个JSP服务器 二： APACHE是一个web服务器环境程序 启用他可以作为web服务器使用 不过只支持静态网页 如(asp,php,cgi,jsp)等动态网页的就不行 如果要在APACHE环境下运行jsp 的话就需要一个解释器来执行jsp网页 而这个jsp解释器就是TOMCAT, 为什么还要JDK呢？因为jsp需要连接数据库的话
就要jdk来提供连接数据库的驱程，所以要运行jsp的web服务器平台就需要APACHE+TOMCAT+JDK 整合的好处是： 如果客户端请求的是静态页面，则只需要Apache服务器响应请求 如果客户端请求动态页面，则是Tomcat服务器响应请求 因为jsp是服务器端解释代码的，这样整合就可以减少Tomcat的服务开销 三： apache:侧重于http server tomcat:侧重于servlet引擎，如果以standalone方式运行，功能上与apache等效 ， 支持JSP，但对静态网页不太理想； apache是web服务器，tomcat是应用（java）服务器，它只是一个servlet(jsp也翻译成servlet)容器，可以认为是apache的扩展，但是可以独立于apache运行。 换句话说，apache是一辆卡车，上面可以装一些东西如html等。但是不能装水，要装水必须要有容器（桶），而这个桶也可以不放在卡车上。
    </div>
  </div>
</div>

        
      
        <h2 class="f1">
          <a href="/tags/arm" class="link blue hover-black">
            Tag: arm
          </a>
        </h2>
        
          <div class="relative w-100 mb4 bg-white nested-copy-line-height">
  <div class="bg-white mb3 pa4 gray overflow-hidden">
    <span class="f6 db">Post</span>
    <h1 class="f3 near-black">
      <a href="http://github.wuquantai.com/" class="link black dim">
        ARM NEON Usage Note
      </a>
    </h1>
    <div class="nested-links f5 lh-copy nested-copy-line-height">
      简介 SIMD, 即Single Instruction Multiple Data（单指令多数据）的并行操作。CPU 在处理向量数据时有它的局限性。CPU的优势在于处理复杂多变的指令，而对于那种大数据量的重复性操作，ARM 为了增加处理效率，增加了这种并行处理模块, 即NEON(Advanced SIMD)。主要是在ARMv7 架构后的处理器使用。
NEON 的主要 components：
 NEON register file * NEON integer execute pipeline * NEON single-precision floating-point execute pipeline * NEON load/store and permute pipeline  NEON 指令和 floating-point 指令使用的是相同的 register file。不同于ARM core的register file。此 register file 可以以 32-bit, 64-bit, 128-bit 方式访问。 The contents of the NEON registers are vectors of elements of the same data type. A vector is divided into lanes and each lane contains a data value called an element.
    </div>
  </div>
</div>

        
          <div class="relative w-100 mb4 bg-white nested-copy-line-height">
  <div class="bg-white mb3 pa4 gray overflow-hidden">
    <span class="f6 db">Post</span>
    <h1 class="f3 near-black">
      <a href="http://github.wuquantai.com/" class="link black dim">
        Eclipse ARM IDE 开发环境搭建
      </a>
    </h1>
    <div class="nested-links f5 lh-copy nested-copy-line-height">
      一、Eclipse
Eclipse的本身只是一个框架平台，但是众多插件的支持，使得Eclipse拥有较好的灵活性。依托于Java 环境运行，所以必须安装 Jre。
二、CDT
CDT是Eclipse用于扩展Eclipse支持C/C++开发的插件。可直接下载带CDT的Eclipse。
三、Zylin CDT
支持Eclipse用于嵌入式C/C++开发和远程调试的插件。
四、Yagarto
Yagarto是整合了GNU arm的交叉编译工具链，是一个跨平台的 ARM 架构开发平台。他们说了，由于基于MinGW的ToolChain 的GDB 跟Eclipse 配合不是很好，所以Yagarto 出现了。目前Yagarto 项目已经完结。此外Yagrato 建议使用免费的
 * [emIDE](http://www.emide.org/) (free Visual Studio Style IDE including GNU Tools for ARM) 。其集成了GNU Tools。  五、J-LINK GDB Server
A JTAG GDB Debug agent run on Host
六、IDE整体结构框图
安装：
1、安装Java SE
下载地址：http://www.oracle.com/technetwork/java/javase/downloads/jre-7u3-download-1501631.html
设置环境变量:
如果只安装Jre的话就添加 : JAVA_HOME = C:\Program Files\Java\jre1.8.0_65;
若是安装JDK的话就添加 : JAVA_HOME = C:\Program Files\Java\jdk1.8.0_65;
Path = %JAVA_HOME%\bin;%JAVA_HOME%\jre\bin;
//安装JDK时，JDK内部有个jre目录，外部也默认安装了一个jre目录。一般配置jre环境为内部jre目录。
CLASSPATH = .
    </div>
  </div>
</div>

        
      
        <h2 class="f1">
          <a href="/tags/beremiz" class="link blue hover-black">
            Tag: beremiz
          </a>
        </h2>
        
          <div class="relative w-100 mb4 bg-white nested-copy-line-height">
  <div class="bg-white mb3 pa4 gray overflow-hidden">
    <span class="f6 db">Post</span>
    <h1 class="f3 near-black">
      <a href="http://github.wuquantai.com/" class="link black dim">
        Beremiz 简介
      </a>
    </h1>
    <div class="nested-links f5 lh-copy nested-copy-line-height">
      Beremiz 是一各为自动化技术提供开放性源代码的软件，它的PLC平台可以支持IEC61131-3 五种开发语言，Beremiz 提供的子项目：
 1. PLCOpen 编辑器 : 提供自动化技术所需要的多平台 IDE （Integrated Development Environment） ； 2. MatPLC's IEC 编译器 : IEC 61131-3 编译器， 可以将结构化文本和指令表120 直接编译为 C 语言； 3. CanFestival : CANOpen 接口服务于物理的输入/ 输出； 4. SVGUI : 以 SVG为基础的自动化 HMI 工具； 所有软件都是提供源代码的， 使用了 PYTHON MINGW 等语言或者平台。  Beremiz软PLC 开发流程:
MatIEC包含两个工具:
  IEC2IEC工具将标准的IEC61131-3的5种语言统一转成ST格式，
  IEC2C工具将ST格式用户代码转ANSI-C代码。
  然后将所有代码通过GCC 工具编译成机器码运行。
    </div>
  </div>
</div>

        
      
        <h2 class="f1">
          <a href="/tags/c-%E9%93%BE%E6%8E%A5" class="link blue hover-black">
            Tag: c-链接
          </a>
        </h2>
        
          <div class="relative w-100 mb4 bg-white nested-copy-line-height">
  <div class="bg-white mb3 pa4 gray overflow-hidden">
    <span class="f6 db">Post</span>
    <h1 class="f3 near-black">
      <a href="http://github.wuquantai.com/" class="link black dim">
        c/c&#43;&#43;编译相关技巧总结帖
      </a>
    </h1>
    <div class="nested-links f5 lh-copy nested-copy-line-height">
      1. 链接时忽略文件中未用到的函数或者对象。这在移植代码过程中很有用, 我们就不需要去删除或者注释掉那些大量没用到的对象或者不需要去链接的对象。  For GCC, this is accomplished in two stages:
First compile the data but tell the compiler to separate the code into separate sections within the translation unit. This will be done for functions, classes, and external variables by using the following two compiler flags:
&lt;code&gt;&lt;span class=&quot;pun&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;pln&quot;&gt;fdata&lt;/span&gt;&lt;span class=&quot;pun&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;pln&quot;&gt;sections &lt;/span&gt;&lt;span class=&quot;pun&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;pln&quot;&gt;ffunction&lt;/span&gt;&lt;span class=&quot;pun&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;pln&quot;&gt;sections&lt;/span&gt;&lt;/code&gt;  Link the translation units together using the linker optimization flag (this causes the linker to discard unreferenced sections):
    </div>
  </div>
</div>

        
      
        <h2 class="f1">
          <a href="/tags/debug-kernel" class="link blue hover-black">
            Tag: debug-kernel
          </a>
        </h2>
        
          <div class="relative w-100 mb4 bg-white nested-copy-line-height">
  <div class="bg-white mb3 pa4 gray overflow-hidden">
    <span class="f6 db">Post</span>
    <h1 class="f3 near-black">
      <a href="http://github.wuquantai.com/" class="link black dim">
        petalinux use guide summarize
      </a>
    </h1>
    <div class="nested-links f5 lh-copy nested-copy-line-height">
      petalinux 是针对 Xilinx FPGA-based SOC designs 的 embedded linux system development kit 。 包含了:
 1. Yocto Extensible SDK 2. Minimal downloads 3. XSCT and tool chains 4. PetaLinux CLI tools  详情参考 PetaLinux Tools Reference Guide。
 **版本： v2018.2 June 6, 2018 **
不支持 ubuntu1804, 手贱装了ubuntu1804, 结果 build 的时候出现 Bitbake 运行不起来，google 一遍发现这版本petalinux 还是暂时不支持 ubuntu1804 ，遂重新装回1604. 总结：
 * * petalinux 安装, 略。 * BSP 安装 * BSP 是petalinux 的一个参考开发板的基础配置。可以把它作为一个模板创建自己的工程。它提供 了一个 installable BSP files，包含了所有必要的 design 和 configuration files ，pre-built 和 tested hardwrae 和 software images.
    </div>
  </div>
</div>

        
      
        <h2 class="f1">
          <a href="/tags/eclipse" class="link blue hover-black">
            Tag: eclipse
          </a>
        </h2>
        
          <div class="relative w-100 mb4 bg-white nested-copy-line-height">
  <div class="bg-white mb3 pa4 gray overflow-hidden">
    <span class="f6 db">Post</span>
    <h1 class="f3 near-black">
      <a href="http://github.wuquantai.com/" class="link black dim">
        Eclipse ARM IDE 开发环境搭建
      </a>
    </h1>
    <div class="nested-links f5 lh-copy nested-copy-line-height">
      一、Eclipse
Eclipse的本身只是一个框架平台，但是众多插件的支持，使得Eclipse拥有较好的灵活性。依托于Java 环境运行，所以必须安装 Jre。
二、CDT
CDT是Eclipse用于扩展Eclipse支持C/C++开发的插件。可直接下载带CDT的Eclipse。
三、Zylin CDT
支持Eclipse用于嵌入式C/C++开发和远程调试的插件。
四、Yagarto
Yagarto是整合了GNU arm的交叉编译工具链，是一个跨平台的 ARM 架构开发平台。他们说了，由于基于MinGW的ToolChain 的GDB 跟Eclipse 配合不是很好，所以Yagarto 出现了。目前Yagarto 项目已经完结。此外Yagrato 建议使用免费的
 * [emIDE](http://www.emide.org/) (free Visual Studio Style IDE including GNU Tools for ARM) 。其集成了GNU Tools。  五、J-LINK GDB Server
A JTAG GDB Debug agent run on Host
六、IDE整体结构框图
安装：
1、安装Java SE
下载地址：http://www.oracle.com/technetwork/java/javase/downloads/jre-7u3-download-1501631.html
设置环境变量:
如果只安装Jre的话就添加 : JAVA_HOME = C:\Program Files\Java\jre1.8.0_65;
若是安装JDK的话就添加 : JAVA_HOME = C:\Program Files\Java\jdk1.8.0_65;
Path = %JAVA_HOME%\bin;%JAVA_HOME%\jre\bin;
//安装JDK时，JDK内部有个jre目录，外部也默认安装了一个jre目录。一般配置jre环境为内部jre目录。
CLASSPATH = .
    </div>
  </div>
</div>

        
      
        <h2 class="f1">
          <a href="/tags/ecs" class="link blue hover-black">
            Tag: ecs
          </a>
        </h2>
        
          <div class="relative w-100 mb4 bg-white nested-copy-line-height">
  <div class="bg-white mb3 pa4 gray overflow-hidden">
    <span class="f6 db">Post</span>
    <h1 class="f3 near-black">
      <a href="http://github.wuquantai.com/" class="link black dim">
        阿里云ECS推荐码9折 : ceyo2p
      </a>
    </h1>
    <div class="nested-links f5 lh-copy nested-copy-line-height">
      阿里云ECS云服务器推荐码9折 : ceyo2p
    </div>
  </div>
</div>

        
      
        <h2 class="f1">
          <a href="/tags/emide" class="link blue hover-black">
            Tag: emide
          </a>
        </h2>
        
          <div class="relative w-100 mb4 bg-white nested-copy-line-height">
  <div class="bg-white mb3 pa4 gray overflow-hidden">
    <span class="f6 db">Post</span>
    <h1 class="f3 near-black">
      <a href="http://github.wuquantai.com/" class="link black dim">
        Eclipse ARM IDE 开发环境搭建
      </a>
    </h1>
    <div class="nested-links f5 lh-copy nested-copy-line-height">
      一、Eclipse
Eclipse的本身只是一个框架平台，但是众多插件的支持，使得Eclipse拥有较好的灵活性。依托于Java 环境运行，所以必须安装 Jre。
二、CDT
CDT是Eclipse用于扩展Eclipse支持C/C++开发的插件。可直接下载带CDT的Eclipse。
三、Zylin CDT
支持Eclipse用于嵌入式C/C++开发和远程调试的插件。
四、Yagarto
Yagarto是整合了GNU arm的交叉编译工具链，是一个跨平台的 ARM 架构开发平台。他们说了，由于基于MinGW的ToolChain 的GDB 跟Eclipse 配合不是很好，所以Yagarto 出现了。目前Yagarto 项目已经完结。此外Yagrato 建议使用免费的
 * [emIDE](http://www.emide.org/) (free Visual Studio Style IDE including GNU Tools for ARM) 。其集成了GNU Tools。  五、J-LINK GDB Server
A JTAG GDB Debug agent run on Host
六、IDE整体结构框图
安装：
1、安装Java SE
下载地址：http://www.oracle.com/technetwork/java/javase/downloads/jre-7u3-download-1501631.html
设置环境变量:
如果只安装Jre的话就添加 : JAVA_HOME = C:\Program Files\Java\jre1.8.0_65;
若是安装JDK的话就添加 : JAVA_HOME = C:\Program Files\Java\jdk1.8.0_65;
Path = %JAVA_HOME%\bin;%JAVA_HOME%\jre\bin;
//安装JDK时，JDK内部有个jre目录，外部也默认安装了一个jre目录。一般配置jre环境为内部jre目录。
CLASSPATH = .
    </div>
  </div>
</div>

        
      
        <h2 class="f1">
          <a href="/tags/ethercatmaster" class="link blue hover-black">
            Tag: ethercatmaster
          </a>
        </h2>
        
          <div class="relative w-100 mb4 bg-white nested-copy-line-height">
  <div class="bg-white mb3 pa4 gray overflow-hidden">
    <span class="f6 db">Post</span>
    <h1 class="f3 near-black">
      <a href="http://github.wuquantai.com/" class="link black dim">
        [转]开源EtherCAT Master比较
      </a>
    </h1>
    <div class="nested-links f5 lh-copy nested-copy-line-height">
      EtherCAT的主站开发是基于EtherCAT机器人控制系统的开发中非常重要的环节。目前常见开源的主站代码为的RT-LAB开发的SOEM (Simple OpenSource EtherCAT Master)和EtherLab的the IgH EtherCAT® Master。使用起来SOEM的简单一些，而the IgH EtherCAT® Master更复杂一些，但对EtherCAT的实现更为完整。
具体比较如下表：
Blackfin 5xx
Blackfin 6xx
Intel
•e1000 - Intel PRO/1000 Gigabit-Ethernet chipsets (PCI).
•e100 - Intel PRO/100 Fast-Ethernet chipsets.
•r8169 - RealTek 8169/8168/8101 Gigabit-Ethernet chipsets.
•e1000e - Intel PRO/1000 Gigabit-Ethernet chipsets (PCI Express).
    </div>
  </div>
</div>

        
      
        <h2 class="f1">
          <a href="/tags/ethernet" class="link blue hover-black">
            Tag: ethernet
          </a>
        </h2>
        
          <div class="relative w-100 mb4 bg-white nested-copy-line-height">
  <div class="bg-white mb3 pa4 gray overflow-hidden">
    <span class="f6 db">Post</span>
    <h1 class="f3 near-black">
      <a href="http://github.wuquantai.com/" class="link black dim">
        Ethernet 的类型
      </a>
    </h1>
    <div class="nested-links f5 lh-copy nested-copy-line-height">
      通过学习以太网的类型，可以更好的了解以太网的工作原理。 共享式以太网 共享式以太网的典型代表是使用10Base2/10Base5的总线型网络和以集线器为核心的星型网络。在使用集线器的以太网中，集线器将很多以太网设备集中到一台中心设备上，这些设备都连接到集线器中的同一物理总线结构中。从本质上讲，以集线器为核心的以太网同原先的总线型以太网无根本区别。 集线器的工作原理： 集线器并不处理或检查其上的通信量，仅通过将一个端口接收的信号重复分发给其他端口来扩展物理介质。所有连接到集线器的设备共享同一介质，其结果是它们也共享同一冲突域、广播和带宽。因此集线器和它所连接的设备组成了一个单一的冲突域。如果一个节点发出一个广播信息，集线器会将这个广播传播给所有同它相连 的节点，因此它也是一个单一的广播域。 集线器的工作特点： 集线器多用于小规模的以太网，由于集线器一般使用外接电源（有源），对其接收的信号有放大处理。在某些场合，集线器也被称为“多端口中继器”。 集线器同中继器一样都是工作在物理层的网络设备。 共享式以太网存在的弊端：由于所有的节点都接在同一冲突域中，不管一个帧从哪里来或到哪里去，所有的节点都能接受到这个帧。随着节点的增加，大量的冲突将导致网络性能急剧下降。而且集线器同时只能传输一个数据帧，这意味着集线器所 有端口都要共享同一带宽。 交换式以太网 交换式结构： 在交换式以太网中，交换机根据收到的数据帧中的MAC地址决定数据帧应发向交换机的哪个端口。因为端口间的帧传输彼此屏蔽，因此节点就不担心自己发送的帧在通过交换机时是否会与其他节点发送的帧产生冲突。 为什么要用交换式网络替代共享式网络： ·减少冲突：交换机将冲突隔绝在每一个端口（每个端口都是一个冲突域），避免了冲突的扩散。 ·提升带宽：接入交换机的每个节点都可以使用全部的带宽，而不是各个节点共享带宽。
    </div>
  </div>
</div>

        
      
        <h2 class="f1">
          <a href="/tags/ethernet-/ip" class="link blue hover-black">
            Tag: ethernet-/ip
          </a>
        </h2>
        
          <div class="relative w-100 mb4 bg-white nested-copy-line-height">
  <div class="bg-white mb3 pa4 gray overflow-hidden">
    <span class="f6 db">Post</span>
    <h1 class="f3 near-black">
      <a href="http://github.wuquantai.com/" class="link black dim">
        [转]各种工业以太网比较（EtherCAT,EtherNet/IP,ProfiNet,Modbus-TCP,Powerlink）
      </a>
    </h1>
    <div class="nested-links f5 lh-copy nested-copy-line-height">
      EtherCAT（以太网控制自动化技术）是一个以以太网为基础的开放架构的现场总线系统，EterCAT名称中的CAT为ControlAutomation Technology（控制自动化技术）首字母的缩写。最初由德国倍福自动化有限公司(Beckhoff AutomationGmbH)研发。EtherCAT为系统的实时性能和拓扑的灵活性树立了新的标准，同时，它还符合甚至降低了现场总线的使用成本。EtherCAT的特点还包括高精度设备同步，可选线缆冗余，和功能性安全协议(SIL3)。
Ethernet/IP是一个面向工业自动化应用的工业应用层协议。它建立在标准UDP/IP与TCP/IP协议之上，利用固定的以太网硬件和软件，为配置、访问和控制工业自动化设备定义了一个应用层协议西蒙公司开发
PROFINET由PROFIBUS国际组织（PROFIBUS International，PI）推出，是新一代基于工业以太网技术的自动化总线标准。作为一项战略性的技术创新，PROFINET为自动化通信领域提供了一个完整的网络解决方案，囊括了诸如实时以太网、运动控制、分布式自动化、故障安全以及网络安全等当前自动化领域的热点话题，并且，作为跨供应商的技术，可以完全兼容工业以太网和现有的现场总线（如PROFIBUS）技术，保护现有投资。
PROFINET是适用于不同需求的完整解决方案，其功能包括8个主要的模块，依次为实时通信、分布式现场设备、运动控制、分布式自动化、网络安装、IT标准和信息安全、故障安全和过程自动化。
MODBUS/TCP是简单的、中立厂商的用于管理和控制自动化设备的MODBUS系列通讯协议的派生产品。显而易见，它覆盖了使用TCP/IP协议的 “Intranet”和“Internet”环境中MODBUS 报文的用途。协议的最通用用途是为诸如PLC’s，I/O模块，以及连接其它简单域总线或I/O模块的网关服务的。 MODBUS/TCP协议是作为一种（实际的）自动化标准发行的。既然MODBUS已经广为人知，该规范只将别处没有收录的少量信息列入其中。然而，本规范力图阐明MODBUS中哪种功能对于普通自动化设备的互用性有价值，哪些部分是MODBUS作为可编程的协议交替用于PLC’s的“多余部分”。 它通过将配套报文类型“一致性等级”，区别那些普遍适用的和可选的，特别是那些适用于特殊设备如PLC’s的报文。
POWERLINK=CANopen+Ethernet
鉴于以太网的蓬勃发展和CANopen在自动化领域里的广阔应用基础，EthernetPOWERLINK 融合了这两项技术的优点和缺点，即拥有了Ethernet的高速、开放性接口，以及CANopen在工业领域良好的SDO 和PDO 数据定义，在某种意义上说POWERLINK就是Ethernet 上的CANopen，物理层、数据链路层使用了Ethernet介质，而应用层则保留了原有的SDO和PDO对象字典的结构 虽然这些工业以太网都是国际标准，但是指的是IEC 61784里的标准，但是这些工业以太网不都是标准的以太网。即这些工业以太网并不都是符合IEEE802.3U的标准，这当中只有Modbus-TCP和EtherNet/IP是符合IEEE802.3U的，只有符合IEEE802.3U标准的，才能与IT和以太网将来的发展相兼容。而不符合IEEE802.3U标准的，基本上可以讲不是以太网，它们都对以太网进行了修改，或者是硬件或者是软件，已经不是以太网了。
各种工业以太网的区别其实主要就是协议的区别，其中最主要的还是应用层协议的区别，我们知道，按照ISO的参考模型，网络被划分为7层。
a. Modbus TCP和EtherNet/IP的区别主要是应用层不相同，ModbusTCP的应用层采用Modbus协议，而EtherNet/IP采用CIP协议，这两种工业以太网的数据链路层采用的是CSMA/CD，因此是标准的以太网，另外，这两种工业以太网的网络层和传输层采用TCP/IP协议族。还有一个区别是，Modbus协议中迄今没有协议来完成功能安全、高精度同步和运功控制等，而EtherNet/IP有CIPSafety、CIP Sync和CIP Motion来完成上述功能，所以才有Schneider加入ODVA，成为ODVA的核心成员来推广EtherNet/IP。由于这两种网络都是标准的TCP/IP以太网，所以所有标准以太网节点都可以接入这两种网络。
b. b. 至于EthernetPowerLink(EPL), Ethernet PowerLink就是个怪胎，PowerLink虽然在物理层和数据链路层还是采用标准的以太网，但是它又添加了另一个数据链路层，此EPL数据链路层在结构上为于以太网数据链路层之上。我们知道数据链路层的一个子层的MAC(介质访问)层的作用是[color=#FF0000]决定哪一个节点可以占有总线，也即决定哪个节点一个发送数据[/color]。所以本来由以太网的数据链路层来决定哪一个节点占用总线，现在它被位于它之上的EPL数据链路层给架空了，由这个EPL数据链路层通过软件的方式来决定哪个节点发送数据。所有在这样的一个EPL工业以太网系统中，不能使用交换机，只能使用HUB，所以对100M的网络，EPL总的带宽是小于100m,一盘情况下只有40－50M，而如果采用交换机的工业以太网，它的带宽可以达到大几百M,另外在EPL网络上，所有的节点都要实现EPL数据链路。没有实现EPL数据链路层的节点不能接入此网络。
c. PROFINET分为原来划分为v1,v2,v3，现在一般称为ProfiNetCBA、ProfiNet IO和ProfiNet IRT.也就是通过以太网来实现对等通讯、实时控制和运动控制。v1采用TCP/IP协议，采用标准的以太网，而V2和V3不采用tcp/ip协议，这两种都绕过tcp/ip协议，采用另外的网络层和传输层协议，开发ProfiNet采用开发人员人员认为tcp/ip协议增加了数据在网络中的传输延迟，其实这是一种误解，据美国密歇根大学的教授研究后认为数据在TCP/IP中的传输延迟很小，他们研究得出数据在经过TCP,IP栈时延迟只有不到100微秒，如果采用UDP/IP时就更小，同时他们研究也得出数据在不同应用层延时比较大，不同的协议延迟不一样，但是相差不是很大，从200us-800us不等，他们经过实验后认为以太网的基础设施(指交换机、网卡等）和TCP/IP协议并不是影响工业以太网实时性的主要原因，而认为应用层协议才是主要原因。所以密歇根大学的教授认为绕开TCP/IP协议没有丝毫的意义，反而由于缺少了TCP/IP协议，使得设备也就缺少了IT功能，与其它现场总线没有区别。 ProfiNet V3就更特别了，它不完全采用标准以太网的数据链路层，有一不时间采用以太网的数据链路层(CSMA/CD)，而另外一部分时间采用自己的数据链路层，通过一个高精度的时间来完成。所以ProfiNet V3也就不是标准的以太网了，也就给Profinet v3带来如下的问题：不能采用标准的交换机、不能采用标准的以太网芯片、与企业网相连可能会出现问题，与标准以太网相连还要特殊的网关、添加和删除一个节点都需要重新组态网络和重新启动网络、至今没有千兆网络，还有最重要的是，当标准以太网以后发展了后，它不能与标准以太网相兼容，不具有将来以太网所应具有的功能。
d. EtherCat这种工业以太网也很奇怪，它们不使用标准的芯片，一般不使用交换机，软件也不是标准的，对以太网的数据帧进行了一些修改，我们知道一个数据帧只有一个源节点，但是对于EtherCat一个数据可能有多个源节点，即一个数据是由多个节点发送的数据组合而成的。所以对于这样的网络，标准的以太网设备也不能接入这样的网络。
我认为Ethernet/IP和ProfiNet这两种工业以太网都适合各个行业，并不象heidai讲的应用的行业不一样。首先这两种工业以太网都用于传输非实时数据，还可传输实时数据，即可以用于离散控制，也可用于过程控制(当然现在还不能用于本安应用)。其次，这两种工业以太网都可用于网络功能安全传输，Ethernet/IP有CIP Safety协议，而ProfiNet有Profisafe协议,还有在运动控制方面ProfiNet有 ProfiNet IRT，而EtherNet/IP则有CIP Safety,二者都可以用于中高端的运动控制。最后两者都有基于IEEE1588的高精度时钟同步。而Modbus TCP,EtherCat和PowerLink,都只能完成部分控制任务，如Modbus TCP一般只作常规IO实时和非实时数据。而EtherCat和PowerLink则更象是为运动控制而开发的，这二者好像没有功能安全、在PLC和DCS控制方面也没有得到大自动化公司的支持，况且这两者又对以太网进行修改，一个在软件，另一个在软件和硬件方面都进行了修改，都不能兼容标准的以太网设备，个人认为这样做得不偿失，为满足运动控制而不能兼容已有的标准的以太网设备而开发的工业以太网并不是以太网，与其说是工业以太网还不如说是另一种现场总线。 我认为工业以太网的竞争将会在Ethernet/IP和ProfiNet间进行，而其它工业以太网都是这两者的陪衬，将会逐渐退出市场。 EtherNet/IP以后将由罗克韦尔自动化、Omron、施耐德和思科公司来推动，而ProfiNet将由业界老大西门子公司带领一些小公司去奋斗，由国内PLC厂商中的老二、老三和老五对老大，不知谁将引导未来。
其实，工业以太网里还有几个怪胎，举两个例吧：
SynqNet: 丹纳赫主导的，几乎只用在运动控制，而且据说只用在了半导体机械行业（奇怪的是，不才也搞半导体机械很久了，却从来没看到过SynqNet，孤陋寡闻啊）。只用了以太网的硬件，完全和我们平常说的以太网没有任何关系，连MAC层都没有。当然如此运用，速度性能当然好，但未来难说。
Sercos III: 光纤SercosII的新一代以太网版本，背后推手是博世力士乐，只用在运动控制。也基本上是只用了以太网底层硬件，系统里竟然连switch都不允许用。速度当然快，但只比SercosII快了一倍。估计用了SercosII的用户，谁会去更新到一个没快了多少的新系统啊，还没问世，就已经不被业界看好了。
我个人认为，最后一定是大西洋两岸的两大巨人之间的角力，就像以前的现场总线战争，最后还不是Profibus和DeviceNet，别的都只能当陪衬的角色？
当然，现在大家都在看中国这个大西洋两岸以外的单一最大市场，中国把砝码放在谁这一边，可能会使天平倾斜一点。但最后，肯定两者都会存在的。我个人认为，咱们应该选Ethernet/IP这一边站
中国用户和制造商应选择Ethernet/IP还是ProfiNet，各人的看法有所不同，不过我认为firstrazor所说的没错，有于ProfiNet采用了专门的芯片、网卡、交换机等以太网基础设施，虽然ProfiNet应用层协议是公开的，但这些芯片却是专用，国内的制造商要想开发符合ProfiNet标准的设备，确要依赖于这些芯片，受制于提供芯片的公司，也就是西门子公司，因此可以将ProfiNet并不是完全开放的。而相反，Ethernet/IP不论是在软件还是硬件上都是标准和开放的，国内的工业以太网制造商还是选择EtherNet/IP为好，至于最终用户的选择，当然是从可靠性、价格、兼容性和可替换性方面考虑，可靠性方面，二者没有明显区别，在其它方面Ethernet/IP具有明显的优势
    </div>
  </div>
</div>

        
      
        <h2 class="f1">
          <a href="/tags/fg" class="link blue hover-black">
            Tag: fg
          </a>
        </h2>
        
          <div class="relative w-100 mb4 bg-white nested-copy-line-height">
  <div class="bg-white mb3 pa4 gray overflow-hidden">
    <span class="f6 db">Post</span>
    <h1 class="f3 near-black">
      <a href="http://github.wuquantai.com/" class="link black dim">
        FG、LG、PG(PE)的定义及区别
      </a>
    </h1>
    <div class="nested-links f5 lh-copy nested-copy-line-height">
      FG與LG 都是接地端子
FG(Frame Ground): 是針對基板電路屏蔽用的接地端子, 主要是對高頻游離電磁波的屏蔽接地之用, 理論上應接於大地，一般将金属外壳，散热片，信号线缆屏蔽层等接于此，将噪声导入大地，或者防止触电。就是通常所认为的GR、PG(Protective Ground)，接地电阻要小于等于100欧姆。
LG(Line Ground)又叫(Functional Ground)不是(Logic Ground)： 是針對AC電源側低頻濾波器的接地, 主要是保持輸入電壓的電位準之用, 理論應與中性線連接。如果噪声是错误的主要来源 或者 有电击的问题， 则将FG 接入PG并一同接地，接地电阻要小于等于100欧姆。
所以 FG端是屬於信號端的接地, LG端是屬於電源端的接地, 二者雖都是接地, 在設計上端子仍是要分開的, 但一般在使用上, 除非AC中性線有帶電的現像, 否則你可以將FG及LG併接後一次接地既可。
    </div>
  </div>
</div>

        
      
        <h2 class="f1">
          <a href="/tags/gdb" class="link blue hover-black">
            Tag: gdb
          </a>
        </h2>
        
          <div class="relative w-100 mb4 bg-white nested-copy-line-height">
  <div class="bg-white mb3 pa4 gray overflow-hidden">
    <span class="f6 db">Post</span>
    <h1 class="f3 near-black">
      <a href="http://github.wuquantai.com/" class="link black dim">
        gdb 简记
      </a>
    </h1>
    <div class="nested-links f5 lh-copy nested-copy-line-height">
      常用命令如下：（详情可以用 help 命令查看）
 r (run, restart)
s (step into)
n (next state, step over)
finish (step out)
q (quit)
p (print anything you want)
l (list)
b (breakpoint) #设置断点： (gdb) b fileName.c:lineNumber 或者 (gdb) b function
u (until) #运行到指定行
call #调用函数
set #设置变量
set args #设置main 的输入参数
bt (backtrace) #查看堆栈
x #examine memory, (gdb)/FMT ADDRESS
info # show things, (gdb) info break
d # delete somthing (gdb) delete break xx 或者 (gdb) clean lineNumber
    </div>
  </div>
</div>

        
      
        <h2 class="f1">
          <a href="/tags/get" class="link blue hover-black">
            Tag: get
          </a>
        </h2>
        
          <div class="relative w-100 mb4 bg-white nested-copy-line-height">
  <div class="bg-white mb3 pa4 gray overflow-hidden">
    <span class="f6 db">Post</span>
    <h1 class="f3 near-black">
      <a href="http://github.wuquantai.com/" class="link black dim">
        HTTP协议与HTTP表单传输格式
      </a>
    </h1>
    <div class="nested-links f5 lh-copy nested-copy-line-height">
      HTTP请求 从使用者的角度看，一个HTTP请求起始于 用户端浏览器上输入的一个URL地址； 网页中的一个超链接； 提交一个HTML表单。 但本质上说，一个HTTP请求起始于用户端向HTTP服务器发送的一个URL请求。 一个标准的HTTP请求由以下几个部分组成
[code] [] [/code]
在HTTP请求中，第一行是请求行（request-line），用来说明请求类型、要访问的资源（URL）以及使用的HTTP版本； 紧接着是多行头部（headers）信息，用来说明服务器要使用的附加信息； 头部信息之后是一个回车换行符（/r/n），用于标明头部信息的结束。 以上是必须内容，根据需要可在头部信息结束之后增加主体数据（request-body）； 主体数据之后是一个回车换行符（/r/n），用于标明主体数据的结束。
需要注意的是 请求行（request-line）中的URL部分必须以application/x-www-form-urlencoded方式编码。 主体数据（request-body）的编码方式由头部（headers）信息中的Content-Type指定。 主体数据（request-body）的长度由头部（headers）信息中的Content-Length指定。
例如，我们可以在IE浏览器上输入下面的网址： http://localhost:8000/hello/index.html HTTP请求的头部信息如下： [code] GET /hello/index.html HTTP/1.1 Accept: / Accept-Language: zh-cn Accept-Encoding: gzip, deflate Host: localhost:8000 Connection: Keep-Alive Cookie: JSESSIONID=BBBA54D519F7A320A54211F0107F5EA6
[/code] 上述信息没有request-body部分，这是以GET方式发送的HTTP请求。如果请求中需要附加主体数据，即增加request-body部分，则必须使用POST方式发送HTTP请求。HTML超链接（）只能用GET方式提交HTTP请求，HTML表单()则可以使用两种方式提交HTTP请求。 HTML表单 HTML表单的使用方法如下：
[html] &hellip;
表单中存在各种类型的表单域标签，如
[html] 、及。 [/html]
每一种表单域标签均有NAME与VALUE两种标签属性。这两个标签属性决定了表单提交时传送的属性名及相应的值。 目标地址（URL） action标签属性指定了表单提交的目标地址，其值可以是完整的URL。如：
[html] &hellip;
这样的表单是不符合要求的。如果其URL值存在非法字符（如中文字符），应将其进行URL Encoding处理。URL Encoding的处理方法如下： 字母数字字符 &ldquo;a&rdquo; 到 &ldquo;z&rdquo;、&ldquo;A&rdquo; 到 &ldquo;Z&rdquo; 和 &ldquo;0&rdquo; 到 &ldquo;9&rdquo; 保持不变。 特殊字符 &ldquo;.&quot;、&quot;-&quot;、&quot;*&rdquo; 和 &ldquo;_&rdquo; 保持不变。 空格字符 &quot; &quot; 转换为一个加号 &ldquo;+&rdquo;。 所有其他字符都是不安全的，因此首先使用一种编码机制将它们转换为一个或多个字节。然后对每个字节用一个包含 3 个字符的字符串 &ldquo;%xy&rdquo; 表示，其中 xy 为该字节的两位十六进制表示形式。推荐的编码机制是 UTF-8。 将“中文”两个字符进行URL Encoding所得到的值就是“%E4%B8%AD%E6%96%87”。 所以正确的表单应该是：
    </div>
  </div>
</div>

        
      
        <h2 class="f1">
          <a href="/tags/git" class="link blue hover-black">
            Tag: git
          </a>
        </h2>
        
          <div class="relative w-100 mb4 bg-white nested-copy-line-height">
  <div class="bg-white mb3 pa4 gray overflow-hidden">
    <span class="f6 db">Post</span>
    <h1 class="f3 near-black">
      <a href="http://github.wuquantai.com/" class="link black dim">
        git 中心服务搭建
      </a>
    </h1>
    <div class="nested-links f5 lh-copy nested-copy-line-height">
      中心服务方式选择 git 本身是一个分布式的版本管理系统，但如果要设置一个中心库方便很多开发者同步，或者像SVN 一样使用它，就需要搭建一个中心库。有几种方式可以选择：
  gitosis ：
这个是比较老的方式。不推荐
详情参考： https://git-scm.com/book/en/v1/Git-on-the-Server-Gitosis
  GitLab:
git 结合web 服务来管理，方便issue 和权限管理。比较推荐。收费版还可提供更多功能。参考：https://about.gitlab.com/install/
  只用ssh git 用户管理
开一个git 用户，设定好权限，也比较方便。但是缺少管理issue 功能。
参考：https://git-scm.com/book/en/v2/Git-on-the-Server-Setting-Up-the-Server
  ssh git用户设置   ssh key证书生成
$ ssh-keygen –t rsa –C “user@host”
  将id_rsa.pub 发给git服务器管理员添加进/home/git/.ssh/authorized_keys 即可，或者直接用 ssh-copy-id 到服务器即可。
$ git clone git@IP:/srv/git/test.git  有几个注意点：
 使用 ssh key 登陆 git 用户时，home目录只能是git 可写的，否则当git组包含多个用户时会出现不用能ssh key 登录的问题。具体debug ssh key 登录问题，可以查看 /var/log/auth 下的日志来解决。.ssh/ 的权限是700，.ssh/authorized_keys 权限是600。 * 最后用chsh 修改 git用户shell 为 git-shell，不让git 用户有其它多余的权限。 * 创建仓库可以用git 组的其它用户来创建。注意使用newgrp 将创建文件夹时用户的默认组改成git, 这样整个git 组的用户都有读写权限。  一些实用的git 命令记录 git checkout --patch BRANCH FILE git checkout --theirs PATH/FILE git clean -n //演习 git ls-files git ls-files | xargs -n 1 dirname | uniq git diff master sync --name-only git config --global core.
    </div>
  </div>
</div>

        
      
        <h2 class="f1">
          <a href="/tags/h264-structure" class="link blue hover-black">
            Tag: h264-structure
          </a>
        </h2>
        
          <div class="relative w-100 mb4 bg-white nested-copy-line-height">
  <div class="bg-white mb3 pa4 gray overflow-hidden">
    <span class="f6 db">Post</span>
    <h1 class="f3 near-black">
      <a href="http://github.wuquantai.com/" class="link black dim">
        H.264 codec Note
      </a>
    </h1>
    <div class="nested-links f5 lh-copy nested-copy-line-height">
      • Elements of a video Sequence
o Frames
o Slices
o MBs (macroblocks)
• Frame Types
o I-, P-, B-frames
o GOP (group of picture), specifies the order in which intra- and inter-frames are arranged.
o NAL (Network Abstraction Layer)
v SPS (Sequence parameter set)
v PPS (Picture parameter set)
v IDR (Instantaneous Decoder Refresh), every IDR frame is an I-frame, but not vice versa,
• Coding Tools
o Entropy Coding
    </div>
  </div>
</div>

        
      
        <h2 class="f1">
          <a href="/tags/http" class="link blue hover-black">
            Tag: http
          </a>
        </h2>
        
          <div class="relative w-100 mb4 bg-white nested-copy-line-height">
  <div class="bg-white mb3 pa4 gray overflow-hidden">
    <span class="f6 db">Post</span>
    <h1 class="f3 near-black">
      <a href="http://github.wuquantai.com/" class="link black dim">
        HTTP协议与HTTP表单传输格式
      </a>
    </h1>
    <div class="nested-links f5 lh-copy nested-copy-line-height">
      HTTP请求 从使用者的角度看，一个HTTP请求起始于 用户端浏览器上输入的一个URL地址； 网页中的一个超链接； 提交一个HTML表单。 但本质上说，一个HTTP请求起始于用户端向HTTP服务器发送的一个URL请求。 一个标准的HTTP请求由以下几个部分组成
[code] [] [/code]
在HTTP请求中，第一行是请求行（request-line），用来说明请求类型、要访问的资源（URL）以及使用的HTTP版本； 紧接着是多行头部（headers）信息，用来说明服务器要使用的附加信息； 头部信息之后是一个回车换行符（/r/n），用于标明头部信息的结束。 以上是必须内容，根据需要可在头部信息结束之后增加主体数据（request-body）； 主体数据之后是一个回车换行符（/r/n），用于标明主体数据的结束。
需要注意的是 请求行（request-line）中的URL部分必须以application/x-www-form-urlencoded方式编码。 主体数据（request-body）的编码方式由头部（headers）信息中的Content-Type指定。 主体数据（request-body）的长度由头部（headers）信息中的Content-Length指定。
例如，我们可以在IE浏览器上输入下面的网址： http://localhost:8000/hello/index.html HTTP请求的头部信息如下： [code] GET /hello/index.html HTTP/1.1 Accept: / Accept-Language: zh-cn Accept-Encoding: gzip, deflate Host: localhost:8000 Connection: Keep-Alive Cookie: JSESSIONID=BBBA54D519F7A320A54211F0107F5EA6
[/code] 上述信息没有request-body部分，这是以GET方式发送的HTTP请求。如果请求中需要附加主体数据，即增加request-body部分，则必须使用POST方式发送HTTP请求。HTML超链接（）只能用GET方式提交HTTP请求，HTML表单()则可以使用两种方式提交HTTP请求。 HTML表单 HTML表单的使用方法如下：
[html] &hellip;
表单中存在各种类型的表单域标签，如
[html] 、及。 [/html]
每一种表单域标签均有NAME与VALUE两种标签属性。这两个标签属性决定了表单提交时传送的属性名及相应的值。 目标地址（URL） action标签属性指定了表单提交的目标地址，其值可以是完整的URL。如：
[html] &hellip;
这样的表单是不符合要求的。如果其URL值存在非法字符（如中文字符），应将其进行URL Encoding处理。URL Encoding的处理方法如下： 字母数字字符 &ldquo;a&rdquo; 到 &ldquo;z&rdquo;、&ldquo;A&rdquo; 到 &ldquo;Z&rdquo; 和 &ldquo;0&rdquo; 到 &ldquo;9&rdquo; 保持不变。 特殊字符 &ldquo;.&quot;、&quot;-&quot;、&quot;*&rdquo; 和 &ldquo;_&rdquo; 保持不变。 空格字符 &quot; &quot; 转换为一个加号 &ldquo;+&rdquo;。 所有其他字符都是不安全的，因此首先使用一种编码机制将它们转换为一个或多个字节。然后对每个字节用一个包含 3 个字符的字符串 &ldquo;%xy&rdquo; 表示，其中 xy 为该字节的两位十六进制表示形式。推荐的编码机制是 UTF-8。 将“中文”两个字符进行URL Encoding所得到的值就是“%E4%B8%AD%E6%96%87”。 所以正确的表单应该是：
    </div>
  </div>
</div>

        
      
        <h2 class="f1">
          <a href="/tags/http-authorization" class="link blue hover-black">
            Tag: http-authorization
          </a>
        </h2>
        
          <div class="relative w-100 mb4 bg-white nested-copy-line-height">
  <div class="bg-white mb3 pa4 gray overflow-hidden">
    <span class="f6 db">Post</span>
    <h1 class="f3 near-black">
      <a href="http://github.wuquantai.com/" class="link black dim">
        Http Authorization
      </a>
    </h1>
    <div class="nested-links f5 lh-copy nested-copy-line-height">
      Basic Authorization
从最初的基本的授权方式说起。 http头里添加：WWW-Authenticate: Basic realm=&quot;xxx&rdquo; 即可要求浏览器输入授权信息。 浏览器发送时会附带授权信息：Authorization:Basic YWRtaW46YWRtaW4= 它是由base64加密的。如上解密后为：admin:admin
Basic authorization 的授权方式就是每个请求中在http头里都携带着base64加密的授权信息，服务器在每次收到请求时都要进行权限判断，再执行对应的操作。
由于考虑到授权，那自然涉及到了客户端状态。http /0.9是无状态无连接的协议，一个特定的输入就对应一个特定的输出。由于http 不需要很强的实时性，属于一问一答的对话形式，且有时并发性强，不可能是一对一的专人(线程)负责一个会话。所以如果涉及到状态就不如把状态参数放置在请求中，服务端就要先对请求中携带的状态进行判断，再判断对应的操作是否有权限等等。按数字电路的理论，服务端的业务就变成两段式状态机的组合逻辑部分。状态部分可以保存在客户端或者服务端，这就变成了cookie和session了。
http /1.0增加了keep-alive 选项，http /1.1则默认了所有连接都有keep-alive选项。http keep-alive 选项就是说 发送完响应之后不服务端不主动关闭连接(http /0.9 是会主动关闭连接的)。http 的keep-alive 应该通过是tcp的keep-alive 定时心跳来维持的，不过http的keep-alive 还有一层意思是即使tcp 连接断开了，http的session还是keep alive的，http 可能也维护着一个保活定时器去试探每个连接上的客户端是否仍在线(这个不清楚)。
当http涉及到用户的概念时，就需要识别用户了，可能最早http识别一个客户端的方法跟标识一个tcp连接的方法是一样的，即IP+Port的形式来断定。然后变成 client 的（IP+Port+uid+password)的，也就是Basic Authorization的方式。状态信息可以放在url(GET)，http header(authorizatin, cookie) 或者 post content里面。
对安全性的考虑：
由于每次都携带用户名和密码的这种请求方式极不安全，所以衍生版本就是用cookie来替代每次都携带的用户名和密码，这样就算cookie被人获取利用，也不会泄漏用户名和密码。只有在登陆的时候会传输一次用户名和密码。再者base64是可逆的加密方式，后面也使用不可逆的加密方式如md5（因为它是有损的加密，不可能还原出原密是什么）。但是如果被抓包，还是会被黑客冒名向服务器发出请求。所以早期网上支付等等就需要k宝，动态口令卡之类的东西。现在由于TLS/SSL等技术的出现，http on TLS/SSL 就很安全了。传输层或者socket层之上的信息全部使用密钥加双方证书加密，再靠抓包破解就很难了，所以这几年网络支付又火了起来。
PS: 看了一个wordpress登录的时候是直接POST 明文用户名加密码，好危险。
FAQ: Chrome delete authorization information 在使用 header(&lsquo;WWW-Authenticate: Basic realm=&quot;userlogin&rdquo;'); 调试用户登录授权时，浏览器总是会保存之前输入的授权信息。想输入其它用户测试都不行。 所以有两个方法：
 使用隐私窗口调试。 在url之前增加 &ldquo;admin@&rdquo; 就可以输入新的授权信息了。  php 的header函数，和html 中的标签效果的区别 两个都用来产生response header的，不同的是前者应该直接由服务端在http header里的添加值对。后者只是将值对放在html中传送，由浏览器来解析。这可以在浏览器中调试发现它们的区别。
    </div>
  </div>
</div>

        
      
        <h2 class="f1">
          <a href="/tags/httpd-%E5%8D%95%E7%89%87%E6%9C%BA" class="link blue hover-black">
            Tag: httpd-单片机
          </a>
        </h2>
        
          <div class="relative w-100 mb4 bg-white nested-copy-line-height">
  <div class="bg-white mb3 pa4 gray overflow-hidden">
    <span class="f6 db">Post</span>
    <h1 class="f3 near-black">
      <a href="http://github.wuquantai.com/" class="link black dim">
        关于Apache httpd 的SSI和cgi使用和思考
      </a>
    </h1>
    <div class="nested-links f5 lh-copy nested-copy-line-height">
      因为在单片机上的web服务是使用删减版的httpd服务器，只保留最原始的扩展功能，SSI和CGI。无法像pc上的服务器可以使用php,jsp之类的引擎。 SSI主要是为了往网页里面插入实时的变量，CGI主要是处理客户端发送来的请求。这样即使是最古老的浏览器也不会有什么兼容性问题。 但是这样的做法的结果是服务端的编程变繁琐了。作为单片机这种嵌入式web应用，应该尽可能工作量放在客户端来完成，减少服务端的复杂度。而且不需要太考虑兼容古老的浏览器，因为落后的东西就应该被淘汰。
早期的浏览器作为通用的客户端只拥有简单的功能，比如实现get和post等几个方法。大量的跳转和内容生成是在服务端运行的，就造成服务器的负载较大。自从javascript成为浏览器端标准的脚本语言后，各种网站的内容交互方式就变得更加自由了。我这里感受最深的就是使用客户端脚本把动态网页的生成工作放在浏览器端来做，数据由ajax 单独请求更新。嵌入式web经常需要显示一些实时的数据，把单独的数据请求放在后台实时更新，然后由脚本把它填写至网页。不像早期的技术使用SSI，服务端需要检索整个网页的SSI tag，然后查找变量，将数据实时更新至网页，然后发送整张网页。可以想服务端的压力有多大。其实这种思维模式就像网站程序和网站数据分开放一个道理。好处多多！ 因为用单片机的web服务器调试前端代码会比较繁琐，要转码要下载，频繁修改就不方便。所以直接在pc的web服务器上调试前端代码，并且使用SSI和CGI，模仿单片机C后台的动作，这里要有一些技巧。 在Apache httpd web服务器上使用SSI和cgi，可以参考服务器主页上的帮助文档http://httpd.apache.org/docs/current/howto/ssi.html。这里简单做个记录。
 SSI 按照官方介绍把SSI功能打开。怎么设置httpd.conf就不多说。这里简单记录下其使用规则。
想设置某个SSI tag时，可以使用
[html]
[/html]
在需要调用它的地方使用
[html]
[/html]
就可以显示出 xxxx 了。 仅仅是这样使用，跟我们在使用最原始的SSI还是有点不一样。 为了方便调试，我们可以在页面上头加上
[html]
[/html]
重定义这个未找到SSI时的提示语言，原本的提示语言很长，不方便调试。
 CGI有几个要点：
 CGI开启后，默认设置ScriptAlias是只执行cgi-bin下的脚本。你可以将自己的web目录添加进去，因为实际请求的路径不一定是/cgi-bin。 这里可以用perl、python或者bash脚本来模仿单片机c的后端应答动作。这样调试好前端代码后，下进单片机后再慢慢调试后端代码就方便了。注意在perl前面要设置好perl.exe的路径。同时可以修改.pl后缀为我们想要的.cgi它也可以得到执行。完美模仿单片机后端逻辑！ Get!  
    </div>
  </div>
</div>

        
      
        <h2 class="f1">
          <a href="/tags/iar-sprintf-%E4%B8%8D%E6%AD%A3%E5%B8%B8" class="link blue hover-black">
            Tag: iar-sprintf-不正常
          </a>
        </h2>
        
          <div class="relative w-100 mb4 bg-white nested-copy-line-height">
  <div class="bg-white mb3 pa4 gray overflow-hidden">
    <span class="f6 db">Post</span>
    <h1 class="f3 near-black">
      <a href="http://github.wuquantai.com/" class="link black dim">
        IAR sprintf() 输出不正常的问题
      </a>
    </h1>
    <div class="nested-links f5 lh-copy nested-copy-line-height">
      前几天调试了一程序，用到sprintf函数，输出结果一直不正常，同样的输出格式用printf打印则没有问题。然后同样的程序在gcc下sprintf也是正常的。怀疑IAR的sprintf函数有问题。后来发现原因是IAR把sprintf函数简化了，在project-options-general options 里面的Library options 的Tabs里有个printf formatter，默认是选成tiny的选项，结果就不支持一些复杂的输出格式。把它设置成auto，输出结果就正常了，o yeah!
    </div>
  </div>
</div>

        
      
        <h2 class="f1">
          <a href="/tags/kernel-debug" class="link blue hover-black">
            Tag: kernel-debug
          </a>
        </h2>
        
          <div class="relative w-100 mb4 bg-white nested-copy-line-height">
  <div class="bg-white mb3 pa4 gray overflow-hidden">
    <span class="f6 db">Post</span>
    <h1 class="f3 near-black">
      <a href="http://github.wuquantai.com/" class="link black dim">
        使用 qemu 调试 linux kernel
      </a>
    </h1>
    <div class="nested-links f5 lh-copy nested-copy-line-height">
      在 Ubuntu 中build kernel 参考如下：
 * [Ref] [https://wiki.ubuntu.com/KernelTeam/GitKernelBuild](https://wiki.ubuntu.com/KernelTeam/GitKernelBuild)  可以直接在宿主机调试kernel, 但是当发生崩溃之后，工作环境又要重新配置。
 所以考虑用 qemu，因为它有个option: -kernel， 可以直接引导kernel。比 VirtualBox 等虚拟机更快速更方便。    * 尝试使用 qemu 直接启动主机上的kernel * $ sudo qemu-system-x86_64 -kernel /boot/vmlinuz-`uname -r`  这会提示缺少文件系统
 * 可以使用 debootstrap 构建一个rootfs IMG=qemu-image.img DIR=mount-point.dir qemu-img create $IMG 1g mkfs.ext2 $IMG mkdir $DIR sudo mount -o loop $IMG $DIR sudo debootstrap --arch amd64 jessie $DIR sudo umount $DIR rmdir $DIR  这里最好用一下 chroot 和 passwd 更新一下文件系统里的密码，以免启动之后登不进去。
    </div>
  </div>
</div>

        
      
        <h2 class="f1">
          <a href="/tags/libero-%E5%AE%89%E8%A3%85" class="link blue hover-black">
            Tag: libero-安装
          </a>
        </h2>
        
          <div class="relative w-100 mb4 bg-white nested-copy-line-height">
  <div class="bg-white mb3 pa4 gray overflow-hidden">
    <span class="f6 db">Post</span>
    <h1 class="f3 near-black">
      <a href="http://github.wuquantai.com/" class="link black dim">
        Libero 安装教程
      </a>
    </h1>
    <div class="nested-links f5 lh-copy nested-copy-line-height">
      在此记录下各种软件的安装教程，等到重装电脑时就会发现它的好处了。
这里 Libero 的版本是11.5。V11.3的版本有bug，不建议装。
去官网申请一个免费的Gold 1 year 的license.
可使用 Vol C: 查看Disk 序列号。
安装软件完毕后。
 放置license.dat文件到C:\flexlm\ 下。 如果license 不是用你的disk序列号申请的，可用硬盘序列号修改器修改C盘序列号 。 添加系统环境变量。 LM_LICENSE_FILE = c:\flexlm\license.dat; SNPSLMD_LICENSE_FILE = c:\flexlm\license.dat;  完成！
    </div>
  </div>
</div>

        
      
        <h2 class="f1">
          <a href="/tags/lwip" class="link blue hover-black">
            Tag: lwip
          </a>
        </h2>
        
          <div class="relative w-100 mb4 bg-white nested-copy-line-height">
  <div class="bg-white mb3 pa4 gray overflow-hidden">
    <span class="f6 db">Post</span>
    <h1 class="f3 near-black">
      <a href="http://github.wuquantai.com/" class="link black dim">
        LwIP TCP Layer Simple analysis
      </a>
    </h1>
    <div class="nested-links f5 lh-copy nested-copy-line-height">
      LwIP Version : 1.4.1; 这里分享一些阅读LwIP协议栈的心得。 有个经验: 源代码才是最权威的资料。 若想用raw api编程，可以参考httpd_raw的代码。若涉及进程间通讯，请参考netconn接口，避免在其它进程内调用非Thead-Safe的函数。 下面说说对一些函数及过程的认识。 (1)** xxx_accept(void *arg, struct tcp_pcb *pcb, err_t err); ** 这个函数的参数注意点: 回调原型：pcb-&gt;accept(pcb-&gt;callback_arg, pcb, err); @*arg: 这里协议栈传递过来的是lpcb，即监听pcb，不要认为和第二个参数相同。因为在tcp_listen_input()里，当有新连接请求到达时会新建一个npcb并将其加入到tcp_active_list里，在初始化npcb时，继承的是lpcb的callback_arg, 而这个callback_arg在新建监听链接时将其赋为lpcb。 @*pcb: 这里是传递进新创建的pcb。在创建APP过程中，需给其分配新的argument, 指定xxx_recv(),xxx_err(), xxx_poll(), xxx_sent()等函数。
(2) struct tcp_pcb **tcp_listen( struct tcp_pcb pcb);
这里传入了一个original pcb，返回一个lpcb，因为listening状态的pcb 只需包含更少的信息。函数内新分配了一个 lpcb, 拷贝必要信息后，将original pcb释放。 对于SO_REUSE选项，在此函数内对比已经在监听List 中的pcb, 允许本地端口号相同，但本地IP号不同的连接可再次监听。
(3) 服务端口监听过程分析 TCP_LISTEN_BACKLOG 选项
此选项使能 TCP 对监听列表允许监听的数量控制。在tcp_listen_input()函数内，
[c]
&hellip; else if (flags &amp; TCP_SYN) { LWIP_DEBUGF(TCP_DEBUG, (&ldquo;TCP connection request %&ldquo;U16_F&rdquo; -&gt; %&ldquo;U16_F&rdquo;.\n&rdquo;, tcphdr-&gt;src, tcphdr-&gt;dest)); #if TCP_LISTEN_BACKLOG if (pcb-&gt;accepts_pending &gt;= pcb-&gt;backlog) { LWIP_DEBUGF(TCP_DEBUG, (&ldquo;tcp_listen_input: listen backlog exceeded for port %&ldquo;U16_F&rdquo;\n&rdquo;, tcphdr-&gt;dest)); return ERR_ABRT; } #endif /* TCP_LISTEN_BACKLOG */ npcb = tcp_alloc(pcb-&gt;prio); &hellip; #if TCP_LISTEN_BACKLOG pcb-&gt;accepts_pending++; #endif &hellip; [/c]
    </div>
  </div>
</div>

        
      
        <h2 class="f1">
          <a href="/tags/lwip-%E4%BF%A1%E5%8F%B7%E9%87%8F" class="link blue hover-black">
            Tag: lwip-信号量
          </a>
        </h2>
        
          <div class="relative w-100 mb4 bg-white nested-copy-line-height">
  <div class="bg-white mb3 pa4 gray overflow-hidden">
    <span class="f6 db">Post</span>
    <h1 class="f3 near-black">
      <a href="http://github.wuquantai.com/" class="link black dim">
        Lwip 里的信号量、邮箱、线程
      </a>
    </h1>
    <div class="nested-links f5 lh-copy nested-copy-line-height">
      这里简单分析总结一下Lwip sys_arch.c 中的信号量、邮箱、进程相关的内容。系统用的是FreeRTOS。
[c] &ldquo;sys_arch.c&rdquo; /* An array to hold the memory for the available semaphores. */ static sem_t sems[SYS_SEM_MAX];
/* An array to hold the memory for the available mailboxes. */ static mbox_t mboxes[SYS_MBOX_MAX];
&ldquo;sys_arch.h&rdquo; ///* A structure to hold the variables for a sys_sem_t. */ typedef struct { xQueueHandle queue; signed char buffer[sizeof(void *) + portQUEUE_OVERHEAD_BYTES]; } sem_t;
/* A structure to hold the variables for a sys_mbox_t. */ typedef struct { xQueueHandle queue; signed char buffer[(sizeof(void *) * MBOX_MAX) + portQUEUE_OVERHEAD_BYTES]; } mbox_t; [/c]
    </div>
  </div>
</div>

        
      
        <h2 class="f1">
          <a href="/tags/lwip-%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86" class="link blue hover-black">
            Tag: lwip-内存管理
          </a>
        </h2>
        
          <div class="relative w-100 mb4 bg-white nested-copy-line-height">
  <div class="bg-white mb3 pa4 gray overflow-hidden">
    <span class="f6 db">Post</span>
    <h1 class="f3 near-black">
      <a href="http://github.wuquantai.com/" class="link black dim">
        Lwip 内存管理
      </a>
    </h1>
    <div class="nested-links f5 lh-copy nested-copy-line-height">
      Lwip 用它自己的动态内存分配方式替代了标准C的malloc(); 它可以使用MEM_POOL的方式分配内存，即开辟几个不同尺寸的缓冲池，给数据分配合适的缓冲区来存放，就类似于使用数组的方式，可能会比较浪费空间，但是可以有效避免内存碎片产生, 这在第二部分讲。两种方式分别在mem.c memp.c里面实现，下面先总结一般的内存堆分配方式。 (一) 内存堆动态分配方式
[c] //mem.h /** Align a memory pointer to the alignment defined by MEM_ALIGNMENT
 so that ADDR % MEM_ALIGNMENT == 0 */ #ifndef LWIP_MEM_ALIGN #define LWIP_MEM_ALIGN(addr) ((void *)(((mem_ptr_t)(addr) + MEM_ALIGNMENT - 1) &amp; ~(mem_ptr_t)(MEM_ALIGNMENT-1))) #endif [/c]  首先是内存对齐，这里用到的MCU是按4字节对齐的。这一语句功能是将addr 调整成最靠近addr的且能被4整除的值，其实就是(addr+3)&amp;(~(u32)(0x03))，+3之后有余数的自然就进位了然后再舍掉余数。其实也可以用 addr = (addr&amp;0x03)?(addr+1):addr; 这样应该也可以，更容易理解一些，但是没有上面的简便。
[c] #ifndef LWIP_RAM_HEAP_POINTER /** the heap. we need one struct mem at the end and some room for alignment */ u8_t ram_heap[MEM_SIZE_ALIGNED + (2*SIZEOF_STRUCT_MEM) + MEM_ALIGNMENT]; #define LWIP_RAM_HEAP_POINTER ram_heap #endif /* LWIP_RAM_HEAP_POINTER */ &hellip; /**
    </div>
  </div>
</div>

        
      
        <h2 class="f1">
          <a href="/tags/lwip-%E9%82%AE%E7%AE%B1" class="link blue hover-black">
            Tag: lwip-邮箱
          </a>
        </h2>
        
          <div class="relative w-100 mb4 bg-white nested-copy-line-height">
  <div class="bg-white mb3 pa4 gray overflow-hidden">
    <span class="f6 db">Post</span>
    <h1 class="f3 near-black">
      <a href="http://github.wuquantai.com/" class="link black dim">
        Lwip 里的信号量、邮箱、线程
      </a>
    </h1>
    <div class="nested-links f5 lh-copy nested-copy-line-height">
      这里简单分析总结一下Lwip sys_arch.c 中的信号量、邮箱、进程相关的内容。系统用的是FreeRTOS。
[c] &ldquo;sys_arch.c&rdquo; /* An array to hold the memory for the available semaphores. */ static sem_t sems[SYS_SEM_MAX];
/* An array to hold the memory for the available mailboxes. */ static mbox_t mboxes[SYS_MBOX_MAX];
&ldquo;sys_arch.h&rdquo; ///* A structure to hold the variables for a sys_sem_t. */ typedef struct { xQueueHandle queue; signed char buffer[sizeof(void *) + portQUEUE_OVERHEAD_BYTES]; } sem_t;
/* A structure to hold the variables for a sys_mbox_t. */ typedef struct { xQueueHandle queue; signed char buffer[(sizeof(void *) * MBOX_MAX) + portQUEUE_OVERHEAD_BYTES]; } mbox_t; [/c]
    </div>
  </div>
</div>

        
      
        <h2 class="f1">
          <a href="/tags/mac" class="link blue hover-black">
            Tag: mac
          </a>
        </h2>
        
          <div class="relative w-100 mb4 bg-white nested-copy-line-height">
  <div class="bg-white mb3 pa4 gray overflow-hidden">
    <span class="f6 db">Post</span>
    <h1 class="f3 near-black">
      <a href="http://github.wuquantai.com/" class="link black dim">
        Ethernet、IP、TCP、UDP帧头格式、详解
      </a>
    </h1>
    <div class="nested-links f5 lh-copy nested-copy-line-height">
      引用：http://zoufengfu168.blog.163.com/blog/static/5461055200991333616451/ 一、MAC帧头定义 [c] typedef struct _MAC_FRAME_HEADER { char m_cDstMacAddress[6]; //目的mac地址 char m_cSrcMacAddress[6]; //源mac地址 /* 如0x0800代表上一层是IP协议，0x0806为arp, 0x88a4为Ethercat */ short m_cType; //上一层协议类型， }__attribute__((packed))MAC_FRAME_HEADER,*PMAC_FRAME_HEADER; Etherne II 长度为14 byte;
typedef struct _MAC_FRAME_TAIL { unsigned int m_sCheckSum; //数据帧尾校验和 }attribute((packed))MAC_FRAME_TAIL, PMAC_FRAME_TAIL; [/c] 补充VLAN 和ARP： [c] // #define ETHTYPE_ARP 0x0806U #define ETHTYPE_IP 0x0800U #define ETHTYPE_VLAN 0x8100U #define ETHTYPE_PPPOEDISC 0x8863U / PPP Over Ethernet Discovery Stage / #define ETHTYPE_PPPOE 0x8864U / PPP Over Ethernet Session Stage */
/** VLAN header inserted between ethernet header and payload
    </div>
  </div>
</div>

        
      
        <h2 class="f1">
          <a href="/tags/make" class="link blue hover-black">
            Tag: make
          </a>
        </h2>
        
          <div class="relative w-100 mb4 bg-white nested-copy-line-height">
  <div class="bg-white mb3 pa4 gray overflow-hidden">
    <span class="f6 db">Post</span>
    <h1 class="f3 near-black">
      <a href="http://github.wuquantai.com/" class="link black dim">
        make工具使用
      </a>
    </h1>
    <div class="nested-links f5 lh-copy nested-copy-line-height">
      Makefile 正如其名作为一个制作文件的工具，大大方便了进行大批量文件编译时的工作流程。这里简单的记录一个make 工具的基本使用规则。
   Makefile 基本规则：
target&hellip; : prerequisites &hellip; command &hellip; &hellip; &mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;-
  target: 为目标文件，即所要生成的对象;
prerequisites : 为要生成target所需要的文件或是目标;
command: 即make需要执行的命令，(任意的shell命令，即对应编译器或者平台的命令)。
第一行表示依赖关系，第二行是规则。( 第二行必须由Tab键开头 )。
注意：
a. 只敲入make命令默认执行第一个target。
b. command 要用Tab键缩进
2. 比如有源文件：main.c api.c api.h 用gcc 作编译的过程：
gcc -c main.c gcc -c api.c gcc -o main main.o api.o  写成Makefile的话就是:
 main: main.o api.o gcc -o main main.o api.o main.o: main.c gcc -c main.c api.o: api.c api.h gcc -c api.
    </div>
  </div>
</div>

        
      
        <h2 class="f1">
          <a href="/tags/makefile" class="link blue hover-black">
            Tag: makefile
          </a>
        </h2>
        
          <div class="relative w-100 mb4 bg-white nested-copy-line-height">
  <div class="bg-white mb3 pa4 gray overflow-hidden">
    <span class="f6 db">Post</span>
    <h1 class="f3 near-black">
      <a href="http://github.wuquantai.com/" class="link black dim">
        make工具使用
      </a>
    </h1>
    <div class="nested-links f5 lh-copy nested-copy-line-height">
      Makefile 正如其名作为一个制作文件的工具，大大方便了进行大批量文件编译时的工作流程。这里简单的记录一个make 工具的基本使用规则。
   Makefile 基本规则：
target&hellip; : prerequisites &hellip; command &hellip; &hellip; &mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;-
  target: 为目标文件，即所要生成的对象;
prerequisites : 为要生成target所需要的文件或是目标;
command: 即make需要执行的命令，(任意的shell命令，即对应编译器或者平台的命令)。
第一行表示依赖关系，第二行是规则。( 第二行必须由Tab键开头 )。
注意：
a. 只敲入make命令默认执行第一个target。
b. command 要用Tab键缩进
2. 比如有源文件：main.c api.c api.h 用gcc 作编译的过程：
gcc -c main.c gcc -c api.c gcc -o main main.o api.o  写成Makefile的话就是:
 main: main.o api.o gcc -o main main.o api.o main.o: main.c gcc -c main.c api.o: api.c api.h gcc -c api.
    </div>
  </div>
</div>

        
      
        <h2 class="f1">
          <a href="/tags/neon" class="link blue hover-black">
            Tag: neon
          </a>
        </h2>
        
          <div class="relative w-100 mb4 bg-white nested-copy-line-height">
  <div class="bg-white mb3 pa4 gray overflow-hidden">
    <span class="f6 db">Post</span>
    <h1 class="f3 near-black">
      <a href="http://github.wuquantai.com/" class="link black dim">
        ARM NEON Usage Note
      </a>
    </h1>
    <div class="nested-links f5 lh-copy nested-copy-line-height">
      简介 SIMD, 即Single Instruction Multiple Data（单指令多数据）的并行操作。CPU 在处理向量数据时有它的局限性。CPU的优势在于处理复杂多变的指令，而对于那种大数据量的重复性操作，ARM 为了增加处理效率，增加了这种并行处理模块, 即NEON(Advanced SIMD)。主要是在ARMv7 架构后的处理器使用。
NEON 的主要 components：
 NEON register file * NEON integer execute pipeline * NEON single-precision floating-point execute pipeline * NEON load/store and permute pipeline  NEON 指令和 floating-point 指令使用的是相同的 register file。不同于ARM core的register file。此 register file 可以以 32-bit, 64-bit, 128-bit 方式访问。 The contents of the NEON registers are vectors of elements of the same data type. A vector is divided into lanes and each lane contains a data value called an element.
    </div>
  </div>
</div>

        
      
        <h2 class="f1">
          <a href="/tags/nfs" class="link blue hover-black">
            Tag: nfs
          </a>
        </h2>
        
          <div class="relative w-100 mb4 bg-white nested-copy-line-height">
  <div class="bg-white mb3 pa4 gray overflow-hidden">
    <span class="f6 db">Post</span>
    <h1 class="f3 near-black">
      <a href="http://github.wuquantai.com/" class="link black dim">
        嵌入式linux 开发中常用工具安装笔记
      </a>
    </h1>
    <div class="nested-links f5 lh-copy nested-copy-line-height">
      * Samba server   # apt install samba samba-common # vim /etc/samba/smb.conf 添加： security = user [shuji] comment = share dir path = /srv/samba browseable = yes writable = yes # useradd public (不要用adduser, 否则还要禁用shell） # smbpasswd –a public # service smbd restart    * Samba client   smbclient -L //192.168.1.10 -U dev smbclient //192.168.1.10 -U dev     * nfs   # vim /etc/exports    /srv/nfs *(rw,sync,nosubtree_check)    # 查看nfs # showmount -e 192.
    </div>
  </div>
</div>

        
      
        <h2 class="f1">
          <a href="/tags/openvpn-ubuntu" class="link blue hover-black">
            Tag: openvpn-ubuntu
          </a>
        </h2>
        
          <div class="relative w-100 mb4 bg-white nested-copy-line-height">
  <div class="bg-white mb3 pa4 gray overflow-hidden">
    <span class="f6 db">Post</span>
    <h1 class="f3 near-black">
      <a href="http://github.wuquantai.com/" class="link black dim">
        ubuntu 上部署OpenVPN服务
      </a>
    </h1>
    <div class="nested-links f5 lh-copy nested-copy-line-height">
      缘起： 最近家里的长城宽带通往海外的线路堵得厉害(感觉长城宽带就是GFW的实验场)，用ss翻墙都难连上服务器，apple store也难连上。于是不得不在国内阿里云的服务器上搭一个VPN。不仅可以解决长城宽带的问题，平时手机在外面连接不安全的wifi时也不用担心信息会泄漏了。另外VPN还可以将分布在各处的内网主机组成局域网，VPN服务就相当于是在中间的虚拟路由器。 参考了以上几个链接的博客总结一下安装过程。 http://www.linuxidc.com/Linux/2014-08/105925p2.htm http://www.linuxidc.com/Linux/2012-01/51702.htm https://help.ubuntu.com/lts/serverguide/openvpn.html http://blog.csdn.net/joyous/article/details/8034132
OpenVPN 是在TCP/UDP 端口上建立一个安全IP网络通道，支持SSL/TLS 对数据加密、授权等。简单点理解就是在传输层上建立一个虚拟线路，作IP包的交换，相当于一个虚拟网卡。原文是这么说的：
 OpenVPN &ndash; An application to securely tunnel IP networks   over a single TCP/UDP port, with support for SSL/TLS-based     session authentication and key exchange,     packet encryption, packet authentication, and     packet compression.    一、安装OpenVPN [bash] ~$ apt-get install openvpn dnsmasq [/bash] dnsmasq 在用来在vpn路由器功能里面充当域名服务器的作用。有的版本openvpn包含了 easy-rsa ，不用再安装easy-rsa。如果没有再自行安装easy-rsa，它包含生成密钥用的脚本文件。 注：更新本地仓库：apt-get update 安装完查看openvpn相关安装包位置的命令： [bash] ~$ dpkg -L openvpn |more [/bash] 找到 easy-rsa 所在的文件夹，把它拷到/etc/openvpn/底下。如果没有就另行安装 easy-rsa。 [bash] ~$ cp -r /usr/share/doc/openvpn/examples/easy-rsa/2.
    </div>
  </div>
</div>

        
      
        <h2 class="f1">
          <a href="/tags/petalinux" class="link blue hover-black">
            Tag: petalinux
          </a>
        </h2>
        
          <div class="relative w-100 mb4 bg-white nested-copy-line-height">
  <div class="bg-white mb3 pa4 gray overflow-hidden">
    <span class="f6 db">Post</span>
    <h1 class="f3 near-black">
      <a href="http://github.wuquantai.com/" class="link black dim">
        petalinux use guide summarize
      </a>
    </h1>
    <div class="nested-links f5 lh-copy nested-copy-line-height">
      petalinux 是针对 Xilinx FPGA-based SOC designs 的 embedded linux system development kit 。 包含了:
 1. Yocto Extensible SDK 2. Minimal downloads 3. XSCT and tool chains 4. PetaLinux CLI tools  详情参考 PetaLinux Tools Reference Guide。
 **版本： v2018.2 June 6, 2018 **
不支持 ubuntu1804, 手贱装了ubuntu1804, 结果 build 的时候出现 Bitbake 运行不起来，google 一遍发现这版本petalinux 还是暂时不支持 ubuntu1804 ，遂重新装回1604. 总结：
 * * petalinux 安装, 略。 * BSP 安装 * BSP 是petalinux 的一个参考开发板的基础配置。可以把它作为一个模板创建自己的工程。它提供 了一个 installable BSP files，包含了所有必要的 design 和 configuration files ，pre-built 和 tested hardwrae 和 software images.
    </div>
  </div>
</div>

        
      
        <h2 class="f1">
          <a href="/tags/post" class="link blue hover-black">
            Tag: post
          </a>
        </h2>
        
          <div class="relative w-100 mb4 bg-white nested-copy-line-height">
  <div class="bg-white mb3 pa4 gray overflow-hidden">
    <span class="f6 db">Post</span>
    <h1 class="f3 near-black">
      <a href="http://github.wuquantai.com/" class="link black dim">
        HTTP协议与HTTP表单传输格式
      </a>
    </h1>
    <div class="nested-links f5 lh-copy nested-copy-line-height">
      HTTP请求 从使用者的角度看，一个HTTP请求起始于 用户端浏览器上输入的一个URL地址； 网页中的一个超链接； 提交一个HTML表单。 但本质上说，一个HTTP请求起始于用户端向HTTP服务器发送的一个URL请求。 一个标准的HTTP请求由以下几个部分组成
[code] [] [/code]
在HTTP请求中，第一行是请求行（request-line），用来说明请求类型、要访问的资源（URL）以及使用的HTTP版本； 紧接着是多行头部（headers）信息，用来说明服务器要使用的附加信息； 头部信息之后是一个回车换行符（/r/n），用于标明头部信息的结束。 以上是必须内容，根据需要可在头部信息结束之后增加主体数据（request-body）； 主体数据之后是一个回车换行符（/r/n），用于标明主体数据的结束。
需要注意的是 请求行（request-line）中的URL部分必须以application/x-www-form-urlencoded方式编码。 主体数据（request-body）的编码方式由头部（headers）信息中的Content-Type指定。 主体数据（request-body）的长度由头部（headers）信息中的Content-Length指定。
例如，我们可以在IE浏览器上输入下面的网址： http://localhost:8000/hello/index.html HTTP请求的头部信息如下： [code] GET /hello/index.html HTTP/1.1 Accept: / Accept-Language: zh-cn Accept-Encoding: gzip, deflate Host: localhost:8000 Connection: Keep-Alive Cookie: JSESSIONID=BBBA54D519F7A320A54211F0107F5EA6
[/code] 上述信息没有request-body部分，这是以GET方式发送的HTTP请求。如果请求中需要附加主体数据，即增加request-body部分，则必须使用POST方式发送HTTP请求。HTML超链接（）只能用GET方式提交HTTP请求，HTML表单()则可以使用两种方式提交HTTP请求。 HTML表单 HTML表单的使用方法如下：
[html] &hellip;
表单中存在各种类型的表单域标签，如
[html] 、及。 [/html]
每一种表单域标签均有NAME与VALUE两种标签属性。这两个标签属性决定了表单提交时传送的属性名及相应的值。 目标地址（URL） action标签属性指定了表单提交的目标地址，其值可以是完整的URL。如：
[html] &hellip;
这样的表单是不符合要求的。如果其URL值存在非法字符（如中文字符），应将其进行URL Encoding处理。URL Encoding的处理方法如下： 字母数字字符 &ldquo;a&rdquo; 到 &ldquo;z&rdquo;、&ldquo;A&rdquo; 到 &ldquo;Z&rdquo; 和 &ldquo;0&rdquo; 到 &ldquo;9&rdquo; 保持不变。 特殊字符 &ldquo;.&quot;、&quot;-&quot;、&quot;*&rdquo; 和 &ldquo;_&rdquo; 保持不变。 空格字符 &quot; &quot; 转换为一个加号 &ldquo;+&rdquo;。 所有其他字符都是不安全的，因此首先使用一种编码机制将它们转换为一个或多个字节。然后对每个字节用一个包含 3 个字符的字符串 &ldquo;%xy&rdquo; 表示，其中 xy 为该字节的两位十六进制表示形式。推荐的编码机制是 UTF-8。 将“中文”两个字符进行URL Encoding所得到的值就是“%E4%B8%AD%E6%96%87”。 所以正确的表单应该是：
    </div>
  </div>
</div>

        
      
        <h2 class="f1">
          <a href="/tags/profinet" class="link blue hover-black">
            Tag: profinet
          </a>
        </h2>
        
          <div class="relative w-100 mb4 bg-white nested-copy-line-height">
  <div class="bg-white mb3 pa4 gray overflow-hidden">
    <span class="f6 db">Post</span>
    <h1 class="f3 near-black">
      <a href="http://github.wuquantai.com/" class="link black dim">
        Profinet 简介
      </a>
    </h1>
    <div class="nested-links f5 lh-copy nested-copy-line-height">
      Profinet 主要包括8个主要模块：实时通信、分布式现场设备、运动控制、分布式自动化、网络安装、IT标准和信息安全、故障安全和过程自动化。
 1. Profinet 实时通信  PROFINET提供适应各种类型 设备的三种通信通道，而且在同 一个网络或设备上能够同时运行。
1.1 TCP/IP 标准通讯;
标准通道适用于具有100ms典型响应时间的简单设备。它能够用于设备的参数化和组态，例如用于读取诊断数据。
1.2 实时(RT)通讯;
对于典型循环时间低于10ms的场合，RT通道具有与最新现场总线系统相同级别的性能，在设备中RT通道能够采用软件方案实现，通道支持用户数据、事件驱动报文和报警等高性能周期传输。
传感器与执行器之间， 5~10ms。
1.3 同步实时(IRT)通讯;
循环时间小于1ms和抖动低于1μs的IRT通道用于高动态的驱动应用。IRT基于一个以太网芯片，用它在IRT网络中创建高动态特性。
运动控制， 响应时间&lt; 1ms, 抖动误差&lt;1us。
 1. 兼容“开放的以太网  世界” 为了实现制造过程最佳化，可直接访问控制和生产级的所有自动化数据应该是生产计划管理系统最重要的因素。PROFINET使用以太网标准通信技术和IT技术，如OPC、XML、COM/DCOM、DHCP、SNMP、FTP或HTTP，与TCP/IP和RT技术一起共同将上述需求付诸实践。 2. Profinet 分布式现场设备
可以通过代理服务器将其它现场总线网络接入到Profinet中。
 3. Profinet 运动控制  IRT中将通讯周期分成两个部分，一个是循环的、确定的实时通道；另外一个是标准通道，标准的TCP/IP数据通过这个通道传输。
。。。
    </div>
  </div>
</div>

        
      
        <h2 class="f1">
          <a href="/tags/pynq" class="link blue hover-black">
            Tag: pynq
          </a>
        </h2>
        
          <div class="relative w-100 mb4 bg-white nested-copy-line-height">
  <div class="bg-white mb3 pa4 gray overflow-hidden">
    <span class="f6 db">Post</span>
    <h1 class="f3 near-black">
      <a href="http://github.wuquantai.com/" class="link black dim">
        编译PYNQ 在ZCU102上的镜像
      </a>
    </h1>
    <div class="nested-links f5 lh-copy nested-copy-line-height">
      由于PYNQ官方没有编译好的ZCU102的镜像，所以需要自己手动编译。这里记录一下编译过程。
因为手头上的ZCU102 批次比较新，所以目前只能使用2018.3 版本的SDK才能BOOT起来。（应该是由于换了DDR型号了，所以老版本的镜像是BOOT不起来的。板子版本是REVISION 1.1的 新批号）
PYNQ 版本Xilinx Tool 版本对应 ** 参考：**
https://blog.csdn.net/vacajk/article/details/84728062 https://github.com/Xilinx/PYNQ/tree/image_v2.4/sdbuild
https://pynq.readthedocs.io/en/latest/pynq_sd_card.html#pynq-sd-card
准备工作  使用事先编译好的文件系统: bionic.aarch64.2.4.img * ZCU102 BSP: xilinx-zcu102-v2018.3-final.bsp * 如果非官方板子，比如黑金的AC7020, 没有BSP, 则可以从vivado 工程导出hdf 文件，给petalinux 生成一个bsp * 安装好SDSoc2018.3, PetaLinux2018.3 * 系统环境 Ubuntu 1604-64  编译步骤 # 下载 pynq $ git clone https://github.com/Xilinx/PYNQ.git $ cd PYNQ $ git checkout image_v2.4 # 检查依赖环境，qemu，crosstool-ng $ cd ./sdbuild/ $ ./scripts/setup_host.sh # 准备 ZCU102 setting $ cp -rf ./boards/ZCU104 ./boards/ZCU102 $ rm -rf .
    </div>
  </div>
</div>

        
      
        <h2 class="f1">
          <a href="/tags/qemu" class="link blue hover-black">
            Tag: qemu
          </a>
        </h2>
        
          <div class="relative w-100 mb4 bg-white nested-copy-line-height">
  <div class="bg-white mb3 pa4 gray overflow-hidden">
    <span class="f6 db">Post</span>
    <h1 class="f3 near-black">
      <a href="http://github.wuquantai.com/" class="link black dim">
        使用 qemu 调试 linux kernel
      </a>
    </h1>
    <div class="nested-links f5 lh-copy nested-copy-line-height">
      在 Ubuntu 中build kernel 参考如下：
 * [Ref] [https://wiki.ubuntu.com/KernelTeam/GitKernelBuild](https://wiki.ubuntu.com/KernelTeam/GitKernelBuild)  可以直接在宿主机调试kernel, 但是当发生崩溃之后，工作环境又要重新配置。
 所以考虑用 qemu，因为它有个option: -kernel， 可以直接引导kernel。比 VirtualBox 等虚拟机更快速更方便。    * 尝试使用 qemu 直接启动主机上的kernel * $ sudo qemu-system-x86_64 -kernel /boot/vmlinuz-`uname -r`  这会提示缺少文件系统
 * 可以使用 debootstrap 构建一个rootfs IMG=qemu-image.img DIR=mount-point.dir qemu-img create $IMG 1g mkfs.ext2 $IMG mkdir $DIR sudo mount -o loop $IMG $DIR sudo debootstrap --arch amd64 jessie $DIR sudo umount $DIR rmdir $DIR  这里最好用一下 chroot 和 passwd 更新一下文件系统里的密码，以免启动之后登不进去。
    </div>
  </div>
</div>

        
          <div class="relative w-100 mb4 bg-white nested-copy-line-height">
  <div class="bg-white mb3 pa4 gray overflow-hidden">
    <span class="f6 db">Post</span>
    <h1 class="f3 near-black">
      <a href="http://github.wuquantai.com/" class="link black dim">
        petalinux use guide summarize
      </a>
    </h1>
    <div class="nested-links f5 lh-copy nested-copy-line-height">
      petalinux 是针对 Xilinx FPGA-based SOC designs 的 embedded linux system development kit 。 包含了:
 1. Yocto Extensible SDK 2. Minimal downloads 3. XSCT and tool chains 4. PetaLinux CLI tools  详情参考 PetaLinux Tools Reference Guide。
 **版本： v2018.2 June 6, 2018 **
不支持 ubuntu1804, 手贱装了ubuntu1804, 结果 build 的时候出现 Bitbake 运行不起来，google 一遍发现这版本petalinux 还是暂时不支持 ubuntu1804 ，遂重新装回1604. 总结：
 * * petalinux 安装, 略。 * BSP 安装 * BSP 是petalinux 的一个参考开发板的基础配置。可以把它作为一个模板创建自己的工程。它提供 了一个 installable BSP files，包含了所有必要的 design 和 configuration files ，pre-built 和 tested hardwrae 和 software images.
    </div>
  </div>
</div>

        
      
        <h2 class="f1">
          <a href="/tags/samba" class="link blue hover-black">
            Tag: samba
          </a>
        </h2>
        
          <div class="relative w-100 mb4 bg-white nested-copy-line-height">
  <div class="bg-white mb3 pa4 gray overflow-hidden">
    <span class="f6 db">Post</span>
    <h1 class="f3 near-black">
      <a href="http://github.wuquantai.com/" class="link black dim">
        嵌入式linux 开发中常用工具安装笔记
      </a>
    </h1>
    <div class="nested-links f5 lh-copy nested-copy-line-height">
      * Samba server   # apt install samba samba-common # vim /etc/samba/smb.conf 添加： security = user [shuji] comment = share dir path = /srv/samba browseable = yes writable = yes # useradd public (不要用adduser, 否则还要禁用shell） # smbpasswd –a public # service smbd restart    * Samba client   smbclient -L //192.168.1.10 -U dev smbclient //192.168.1.10 -U dev     * nfs   # vim /etc/exports    /srv/nfs *(rw,sync,nosubtree_check)    # 查看nfs # showmount -e 192.
    </div>
  </div>
</div>

        
      
        <h2 class="f1">
          <a href="/tags/shell-completion" class="link blue hover-black">
            Tag: shell-completion
          </a>
        </h2>
        
          <div class="relative w-100 mb4 bg-white nested-copy-line-height">
  <div class="bg-white mb3 pa4 gray overflow-hidden">
    <span class="f6 db">Post</span>
    <h1 class="f3 near-black">
      <a href="http://github.wuquantai.com/" class="link black dim">
        linux bash shell 像cmd.exe 一样的滚动补齐功能
      </a>
    </h1>
    <div class="nested-links f5 lh-copy nested-copy-line-height">
      有些情况下，比如我们遇到文件名含有一些字符不容易输入时就很着急了，这时候就需要让linux shell像windows cmd.exe 一样自动补全部的文件名，且可自动按顺序一个个滚动切换。方法如下： 在用户目录创建 ~/.inputrc (若不存在则自己创建) 文件里添加一行：
[code]TAB: menu-complete[/code]
。 登出再登陆用户就可以了。 For more details see the READLINE section in man bash.
    </div>
  </div>
</div>

        
      
        <h2 class="f1">
          <a href="/tags/shtm" class="link blue hover-black">
            Tag: shtm
          </a>
        </h2>
        
          <div class="relative w-100 mb4 bg-white nested-copy-line-height">
  <div class="bg-white mb3 pa4 gray overflow-hidden">
    <span class="f6 db">Post</span>
    <h1 class="f3 near-black">
      <a href="http://github.wuquantai.com/" class="link black dim">
        SSI Tag的使用
      </a>
    </h1>
    <div class="nested-links f5 lh-copy nested-copy-line-height">
      这里先说最原始的使用SSI tag的方式，因为这样做在C开发中最简单。跟后来通用的web服务器的SSI有点不一样，因为后来为了使上层开发更方便，又进行了一些封装。 最原始的SSI是这样规定的，如在html中嵌入SSI tag。使用
[code]&lt;&ndash;#tagname&ndash;&gt;[/code]
;，则当Web服务器生成网页时，会将当前的标签后插入所指定的内容。这就是SSI Tag的作用。 SSI可以说是最初动态生成网页的方法，不仅仅是用来插入一些变量也可以直接插入javascript、json等等你想要发送给客户端的内容！一般用SSI来插入静态变量比较方便，如果是插入input框的当前值的话，可以往SSI中插入一段javascript代码或者是json格式的数据，再用javascript把这些实时的值加载进input框。
[html]
其Tag 在Web 服务端代码中作如下定义,并定义其序号的宏。
[c] static const char *g_pcConfigSSITags[] = { &ldquo;ipaddr&rdquo;, // SSI_INDEX_IPADDR &ldquo;macaddr&rdquo;, // SSI_INDEX_MACADDR &ldquo;p0br&rdquo;, // SSI_INDEX_P0BR &ldquo;p0sb&rdquo;, // SSI_INDEX_P0SB &ldquo;p0p&rdquo;, // SSI_INDEX_P0P &ldquo;p0bc&rdquo;, // SSI_INDEX_P0BC &ldquo;p0fc&rdquo;, // SSI_INDEX_P0FC &ldquo;p0tt&rdquo;, // SSI_INDEX_P0TT &ldquo;p0tlp&rdquo;, // SSI_INDEX_P0TLP &ldquo;p0trp&rdquo;, // SSI_INDEX_P0TRP &ldquo;p0tip&rdquo;, // SSI_INDEX_P0TIP &ldquo;p0tip1&rdquo;, // SSI_INDEX_P0TIP1 &ldquo;p0tip2&rdquo;, // SSI_INDEX_P0TIP2 &ldquo;p0tip3&rdquo;, // SSI_INDEX_P0TIP3 &ldquo;p0tip4&rdquo;, // SSI_INDEX_P0TIP4 &ldquo;p0tnm&rdquo;, // SSI_INDEX_P0TNM &ldquo;p1br&rdquo;, // SSI_INDEX_P1BR &ldquo;p1sb&rdquo;, // SSI_INDEX_P1SB &ldquo;p1p&rdquo;, // SSI_INDEX_P1P &ldquo;p1bc&rdquo;, // SSI_INDEX_P1BC &ldquo;p1fc&rdquo;, // SSI_INDEX_P1FC &ldquo;p1tt&rdquo;, // SSI_INDEX_P1TT &ldquo;p1tlp&rdquo;, // SSI_INDEX_P1TLP &ldquo;p1trp&rdquo;, // SSI_INDEX_P1TRP &ldquo;p1tip&rdquo;, // SSI_INDEX_P1TIP &ldquo;p1tip1&rdquo;, // SSI_INDEX_P1TIP1 &ldquo;p1tip2&rdquo;, // SSI_INDEX_P1TIP2 &ldquo;p1tip3&rdquo;, // SSI_INDEX_P1TIP3 &ldquo;p1tip4&rdquo;, // SSI_INDEX_P1TIP4 &ldquo;p1tnm&rdquo;, // SSI_INDEX_P1TNM &ldquo;modname&rdquo;, // SSI_INDEX_MODNAME &ldquo;pnpport&rdquo;, // SSI_INDEX_PNPPORT &ldquo;disable&rdquo;, // SSI_INDEX_DISABLE &hellip; }; [/c]
    </div>
  </div>
</div>

        
      
        <h2 class="f1">
          <a href="/tags/shtml" class="link blue hover-black">
            Tag: shtml
          </a>
        </h2>
        
          <div class="relative w-100 mb4 bg-white nested-copy-line-height">
  <div class="bg-white mb3 pa4 gray overflow-hidden">
    <span class="f6 db">Post</span>
    <h1 class="f3 near-black">
      <a href="http://github.wuquantai.com/" class="link black dim">
        SSI Tag的使用
      </a>
    </h1>
    <div class="nested-links f5 lh-copy nested-copy-line-height">
      这里先说最原始的使用SSI tag的方式，因为这样做在C开发中最简单。跟后来通用的web服务器的SSI有点不一样，因为后来为了使上层开发更方便，又进行了一些封装。 最原始的SSI是这样规定的，如在html中嵌入SSI tag。使用
[code]&lt;&ndash;#tagname&ndash;&gt;[/code]
;，则当Web服务器生成网页时，会将当前的标签后插入所指定的内容。这就是SSI Tag的作用。 SSI可以说是最初动态生成网页的方法，不仅仅是用来插入一些变量也可以直接插入javascript、json等等你想要发送给客户端的内容！一般用SSI来插入静态变量比较方便，如果是插入input框的当前值的话，可以往SSI中插入一段javascript代码或者是json格式的数据，再用javascript把这些实时的值加载进input框。
[html]
其Tag 在Web 服务端代码中作如下定义,并定义其序号的宏。
[c] static const char *g_pcConfigSSITags[] = { &ldquo;ipaddr&rdquo;, // SSI_INDEX_IPADDR &ldquo;macaddr&rdquo;, // SSI_INDEX_MACADDR &ldquo;p0br&rdquo;, // SSI_INDEX_P0BR &ldquo;p0sb&rdquo;, // SSI_INDEX_P0SB &ldquo;p0p&rdquo;, // SSI_INDEX_P0P &ldquo;p0bc&rdquo;, // SSI_INDEX_P0BC &ldquo;p0fc&rdquo;, // SSI_INDEX_P0FC &ldquo;p0tt&rdquo;, // SSI_INDEX_P0TT &ldquo;p0tlp&rdquo;, // SSI_INDEX_P0TLP &ldquo;p0trp&rdquo;, // SSI_INDEX_P0TRP &ldquo;p0tip&rdquo;, // SSI_INDEX_P0TIP &ldquo;p0tip1&rdquo;, // SSI_INDEX_P0TIP1 &ldquo;p0tip2&rdquo;, // SSI_INDEX_P0TIP2 &ldquo;p0tip3&rdquo;, // SSI_INDEX_P0TIP3 &ldquo;p0tip4&rdquo;, // SSI_INDEX_P0TIP4 &ldquo;p0tnm&rdquo;, // SSI_INDEX_P0TNM &ldquo;p1br&rdquo;, // SSI_INDEX_P1BR &ldquo;p1sb&rdquo;, // SSI_INDEX_P1SB &ldquo;p1p&rdquo;, // SSI_INDEX_P1P &ldquo;p1bc&rdquo;, // SSI_INDEX_P1BC &ldquo;p1fc&rdquo;, // SSI_INDEX_P1FC &ldquo;p1tt&rdquo;, // SSI_INDEX_P1TT &ldquo;p1tlp&rdquo;, // SSI_INDEX_P1TLP &ldquo;p1trp&rdquo;, // SSI_INDEX_P1TRP &ldquo;p1tip&rdquo;, // SSI_INDEX_P1TIP &ldquo;p1tip1&rdquo;, // SSI_INDEX_P1TIP1 &ldquo;p1tip2&rdquo;, // SSI_INDEX_P1TIP2 &ldquo;p1tip3&rdquo;, // SSI_INDEX_P1TIP3 &ldquo;p1tip4&rdquo;, // SSI_INDEX_P1TIP4 &ldquo;p1tnm&rdquo;, // SSI_INDEX_P1TNM &ldquo;modname&rdquo;, // SSI_INDEX_MODNAME &ldquo;pnpport&rdquo;, // SSI_INDEX_PNPPORT &ldquo;disable&rdquo;, // SSI_INDEX_DISABLE &hellip; }; [/c]
    </div>
  </div>
</div>

        
      
        <h2 class="f1">
          <a href="/tags/soem" class="link blue hover-black">
            Tag: soem
          </a>
        </h2>
        
          <div class="relative w-100 mb4 bg-white nested-copy-line-height">
  <div class="bg-white mb3 pa4 gray overflow-hidden">
    <span class="f6 db">Post</span>
    <h1 class="f3 near-black">
      <a href="http://github.wuquantai.com/" class="link black dim">
        [转]开源EtherCAT Master比较
      </a>
    </h1>
    <div class="nested-links f5 lh-copy nested-copy-line-height">
      EtherCAT的主站开发是基于EtherCAT机器人控制系统的开发中非常重要的环节。目前常见开源的主站代码为的RT-LAB开发的SOEM (Simple OpenSource EtherCAT Master)和EtherLab的the IgH EtherCAT® Master。使用起来SOEM的简单一些，而the IgH EtherCAT® Master更复杂一些，但对EtherCAT的实现更为完整。
具体比较如下表：
Blackfin 5xx
Blackfin 6xx
Intel
•e1000 - Intel PRO/1000 Gigabit-Ethernet chipsets (PCI).
•e100 - Intel PRO/100 Fast-Ethernet chipsets.
•r8169 - RealTek 8169/8168/8101 Gigabit-Ethernet chipsets.
•e1000e - Intel PRO/1000 Gigabit-Ethernet chipsets (PCI Express).
    </div>
  </div>
</div>

        
      
        <h2 class="f1">
          <a href="/tags/ssi" class="link blue hover-black">
            Tag: ssi
          </a>
        </h2>
        
          <div class="relative w-100 mb4 bg-white nested-copy-line-height">
  <div class="bg-white mb3 pa4 gray overflow-hidden">
    <span class="f6 db">Post</span>
    <h1 class="f3 near-black">
      <a href="http://github.wuquantai.com/" class="link black dim">
        SSI Tag的使用
      </a>
    </h1>
    <div class="nested-links f5 lh-copy nested-copy-line-height">
      这里先说最原始的使用SSI tag的方式，因为这样做在C开发中最简单。跟后来通用的web服务器的SSI有点不一样，因为后来为了使上层开发更方便，又进行了一些封装。 最原始的SSI是这样规定的，如在html中嵌入SSI tag。使用
[code]&lt;&ndash;#tagname&ndash;&gt;[/code]
;，则当Web服务器生成网页时，会将当前的标签后插入所指定的内容。这就是SSI Tag的作用。 SSI可以说是最初动态生成网页的方法，不仅仅是用来插入一些变量也可以直接插入javascript、json等等你想要发送给客户端的内容！一般用SSI来插入静态变量比较方便，如果是插入input框的当前值的话，可以往SSI中插入一段javascript代码或者是json格式的数据，再用javascript把这些实时的值加载进input框。
[html]
其Tag 在Web 服务端代码中作如下定义,并定义其序号的宏。
[c] static const char *g_pcConfigSSITags[] = { &ldquo;ipaddr&rdquo;, // SSI_INDEX_IPADDR &ldquo;macaddr&rdquo;, // SSI_INDEX_MACADDR &ldquo;p0br&rdquo;, // SSI_INDEX_P0BR &ldquo;p0sb&rdquo;, // SSI_INDEX_P0SB &ldquo;p0p&rdquo;, // SSI_INDEX_P0P &ldquo;p0bc&rdquo;, // SSI_INDEX_P0BC &ldquo;p0fc&rdquo;, // SSI_INDEX_P0FC &ldquo;p0tt&rdquo;, // SSI_INDEX_P0TT &ldquo;p0tlp&rdquo;, // SSI_INDEX_P0TLP &ldquo;p0trp&rdquo;, // SSI_INDEX_P0TRP &ldquo;p0tip&rdquo;, // SSI_INDEX_P0TIP &ldquo;p0tip1&rdquo;, // SSI_INDEX_P0TIP1 &ldquo;p0tip2&rdquo;, // SSI_INDEX_P0TIP2 &ldquo;p0tip3&rdquo;, // SSI_INDEX_P0TIP3 &ldquo;p0tip4&rdquo;, // SSI_INDEX_P0TIP4 &ldquo;p0tnm&rdquo;, // SSI_INDEX_P0TNM &ldquo;p1br&rdquo;, // SSI_INDEX_P1BR &ldquo;p1sb&rdquo;, // SSI_INDEX_P1SB &ldquo;p1p&rdquo;, // SSI_INDEX_P1P &ldquo;p1bc&rdquo;, // SSI_INDEX_P1BC &ldquo;p1fc&rdquo;, // SSI_INDEX_P1FC &ldquo;p1tt&rdquo;, // SSI_INDEX_P1TT &ldquo;p1tlp&rdquo;, // SSI_INDEX_P1TLP &ldquo;p1trp&rdquo;, // SSI_INDEX_P1TRP &ldquo;p1tip&rdquo;, // SSI_INDEX_P1TIP &ldquo;p1tip1&rdquo;, // SSI_INDEX_P1TIP1 &ldquo;p1tip2&rdquo;, // SSI_INDEX_P1TIP2 &ldquo;p1tip3&rdquo;, // SSI_INDEX_P1TIP3 &ldquo;p1tip4&rdquo;, // SSI_INDEX_P1TIP4 &ldquo;p1tnm&rdquo;, // SSI_INDEX_P1TNM &ldquo;modname&rdquo;, // SSI_INDEX_MODNAME &ldquo;pnpport&rdquo;, // SSI_INDEX_PNPPORT &ldquo;disable&rdquo;, // SSI_INDEX_DISABLE &hellip; }; [/c]
    </div>
  </div>
</div>

        
      
        <h2 class="f1">
          <a href="/tags/svn%E6%9C%8D%E5%8A%A1%E6%90%AD%E5%BB%BA" class="link blue hover-black">
            Tag: svn服务搭建
          </a>
        </h2>
        
          <div class="relative w-100 mb4 bg-white nested-copy-line-height">
  <div class="bg-white mb3 pa4 gray overflow-hidden">
    <span class="f6 db">Post</span>
    <h1 class="f3 near-black">
      <a href="http://github.wuquantai.com/" class="link black dim">
        用ECS在云端搭建SVN服务
      </a>
    </h1>
    <div class="nested-links f5 lh-copy nested-copy-line-height">
      应用环境： ECS 云端系统：Ubuntu 14.04-x64 本地系统：window 使用工具：cygwin + ssh 原版文档： http://www.shayanderson.com/linux/install-and-setup-subversion-server-on-ubuntu-1210-server-with-multiple-repositories.htm 一、安装及目录配置
  登录云端服务器 ssh xxx@[IP]
  安装subversion apt-get install subversion 检查是否安装完成 svn --version
  先建立一个Repositories 目录放置工程 mkdir /home/repos  在目录底下再建立工程 svnadmin create /home/repos/project1 svnadmin create /home/repos/project2 注：删除则用 svnadmin deltify
  修改目录组权限让一用户组都可管理此目录  chmod -R g+rws /home/repos //设置组权限  sudo groupadd svn //添加组  chgrp -R svn /home/repos //修改group ownership  usermod -a -G svn [username] //添加用户进组 groups // 检查用户是否被添加进组 二、云端上测试SVN服务
    </div>
  </div>
</div>

        
      
        <h2 class="f1">
          <a href="/tags/tar" class="link blue hover-black">
            Tag: tar
          </a>
        </h2>
        
          <div class="relative w-100 mb4 bg-white nested-copy-line-height">
  <div class="bg-white mb3 pa4 gray overflow-hidden">
    <span class="f6 db">Post</span>
    <h1 class="f3 near-black">
      <a href="http://github.wuquantai.com/" class="link black dim">
        linux 常用命令笔记
      </a>
    </h1>
    <div class="nested-links f5 lh-copy nested-copy-line-height">
      * 1. 修改文件夹所有者  chown -R [owner] .. ; 修改当前目录下所有文件夹的所有都为owner, -R表示递归调用。
 * 2. 解压命令  tar -zxvf xxx;
-c: 建立压缩档案 -x：解压 -t：查看内容 -r：向压缩归档文件末尾追加文件 -u：更新原压缩包中的文件
这五个是独立的命令，压缩解压都要用到其中一个，可以和别的命令连用但只能用其中一个。下面的参数是根据需要在压缩或解压档案时可选的。
-z：有gzip属性的 -j：有bz2属性的 -Z：有compress属性的 -v：显示所有过程 -O：将文件解开到标准输出
下面的参数-f是必须的
-f: 使用档案名字，切记，这个参数是最后一个参数，后面只能接档案名。
创建用户 useradd 修改密码 passwd 安装包 apt-get install apt-get update //更新源 iptables iptables -nv -L //列出 netstat ps aux 查看进程
    </div>
  </div>
</div>

        
      
        <h2 class="f1">
          <a href="/tags/tcp-multi-connections" class="link blue hover-black">
            Tag: tcp-multi-connections
          </a>
        </h2>
        
          <div class="relative w-100 mb4 bg-white nested-copy-line-height">
  <div class="bg-white mb3 pa4 gray overflow-hidden">
    <span class="f6 db">Post</span>
    <h1 class="f3 near-black">
      <a href="http://github.wuquantai.com/" class="link black dim">
        methods of handling multiple connections as lwip
      </a>
    </h1>
    <div class="nested-links f5 lh-copy nested-copy-line-height">
      这里分享一些一个服务handle多client连接的经验。
(1) 多线程/进程方法 每accept并创建一个新连接之后，就create一个task来处理这个连接的事务。linux使用fork()来创建分支线程。freertos 不支持fork方法，只能创建新的线程来管理连接。此方法内存开销较大。
(2) non-blocking socket 和 select 此方法由单线程处理并发事务，即最原始的轮询方式。在系统不支持fork()的情况下经常用到。首先，accpet/recv函数都必须的non-blocking的，需立即返回，否则其它任务就得不到轮询。这种模式在跑单片机裸机程序时经常是这样的，另外在labview里面也经常是这样的轮询的方式。这个例程可以在lwip 1.4.1 contrib下app demo:chargen 里可以学习到。这种方式会占用很多cpu资源，这样的任务优先级要放低，并设置一定的轮询间隔(类比在labview里，while循环通常会插入一个等待时间)。否则 freertos 中低优先级任务就得不到运行，同优先级的任务也只能分时间片轮流运行。 这里简单总结下 select方法。 协议栈内核在每次有accept 或 recv事件到达后都会调用 event_callback(); 增加一个事件记录。在上层接收后都会减掉一个记录。select 函数通过查询socket的对应event来置位fd_set对应的比特位。本质就类似查询一个计数信号量。
(3) 使用 raw api， 基于事件触发(基于回调)方式。 此方式适合编写只进行简单处理的应用，每次接收到包就会调用相应的回调函数。多连接是由协议栈的active_pcb_lists直接管理，每个连接都创建属于自己的state argument。如果需要运算量比较大占用时间较长的服务则不适合此方式，会影响的协议栈对其它服务的响应速度。
后记，从事务的角度来看，一个tcp连接代表一个session，一句udp 请求也代表一个session。一个session从接收到返回就是一条事务线。若不能一气呵成，则就必须用一条线程去管理它，或者说维护一个工作现场，等待它的后台任务完成再回来应答这个事务。一条线程就对应一个事务现场，多任务操作系统就是在不同的工作现场的中交替工作，模拟多个人工作的情况，每一个工作现场都保存的对应工作事务的进展情况和所有需要用到的工具。 或者还有一种做法，就是一件事做完一部分后丢给后台，让它处理完之后调用我给它的办法帮我把剩下的事处理完，节省了任务之间信息传递和任务切换带来的开销。 其实一个session对应一个任务确实有点浪费，我想一般handle几百上千万个连接的服务应该不会这样做的，每个连接只需将它当前的状态变量连同数据包传给每个部门来做就可以了，毕竟每个连接的状态的数据量不是很多，没必要开辟一个专门的任务去Handle.
    </div>
  </div>
</div>

        
      
        <h2 class="f1">
          <a href="/tags/tcp/ip" class="link blue hover-black">
            Tag: tcp/ip
          </a>
        </h2>
        
          <div class="relative w-100 mb4 bg-white nested-copy-line-height">
  <div class="bg-white mb3 pa4 gray overflow-hidden">
    <span class="f6 db">Post</span>
    <h1 class="f3 near-black">
      <a href="http://github.wuquantai.com/" class="link black dim">
        Ethernet、IP、TCP、UDP帧头格式、详解
      </a>
    </h1>
    <div class="nested-links f5 lh-copy nested-copy-line-height">
      引用：http://zoufengfu168.blog.163.com/blog/static/5461055200991333616451/ 一、MAC帧头定义 [c] typedef struct _MAC_FRAME_HEADER { char m_cDstMacAddress[6]; //目的mac地址 char m_cSrcMacAddress[6]; //源mac地址 /* 如0x0800代表上一层是IP协议，0x0806为arp, 0x88a4为Ethercat */ short m_cType; //上一层协议类型， }__attribute__((packed))MAC_FRAME_HEADER,*PMAC_FRAME_HEADER; Etherne II 长度为14 byte;
typedef struct _MAC_FRAME_TAIL { unsigned int m_sCheckSum; //数据帧尾校验和 }attribute((packed))MAC_FRAME_TAIL, PMAC_FRAME_TAIL; [/c] 补充VLAN 和ARP： [c] // #define ETHTYPE_ARP 0x0806U #define ETHTYPE_IP 0x0800U #define ETHTYPE_VLAN 0x8100U #define ETHTYPE_PPPOEDISC 0x8863U / PPP Over Ethernet Discovery Stage / #define ETHTYPE_PPPOE 0x8864U / PPP Over Ethernet Session Stage */
/** VLAN header inserted between ethernet header and payload
    </div>
  </div>
</div>

        
      
        <h2 class="f1">
          <a href="/tags/tomcat" class="link blue hover-black">
            Tag: tomcat
          </a>
        </h2>
        
          <div class="relative w-100 mb4 bg-white nested-copy-line-height">
  <div class="bg-white mb3 pa4 gray overflow-hidden">
    <span class="f6 db">Post</span>
    <h1 class="f3 near-black">
      <a href="http://github.wuquantai.com/" class="link black dim">
        [转]Apache与Tomcat有什么关系和区别
      </a>
    </h1>
    <div class="nested-links f5 lh-copy nested-copy-line-height">
      经常在用apache和tomcat等这些服务器，可是总感觉还是不清楚他们之间有什么关系，在用tomcat的时候总出现apache，总感到迷惑，到底谁是主谁是次，因此特意在网上查询了一些这方面的资料，总结了一下： 一 apache支持静态页，tomcat支持动态的，比如servlet等，一般使用apache+tomcat的话，apache只是作为一个转发，对jsp的处理是由tomcat来处理的。 apache可以支持php\cgi\perl,但是要使用java的话，你需要tomcat在apache后台支撑，将java请求由apache转发给tomcat处理。 apache是web服务器,Tomcat是应用（java）服务器，它只是一个servlet(jsp也翻译成servlet)容器，可以认为是apache的扩展，但是可以独立于apache运行。 这两个有以下几点可以比较的： 1、两者都是apache组织开发的 2、两者都有HTTP服务的功能 3、两者都是免费的 不同点： Apache是专门用了提供HTTP服务的，以及相关配置的（例如虚拟主机、URL转发等等） Tomcat是Apache组织在符合J2EE的JSP、Servlet标准下开发的一个JSP服务器 二： APACHE是一个web服务器环境程序 启用他可以作为web服务器使用 不过只支持静态网页 如(asp,php,cgi,jsp)等动态网页的就不行 如果要在APACHE环境下运行jsp 的话就需要一个解释器来执行jsp网页 而这个jsp解释器就是TOMCAT, 为什么还要JDK呢？因为jsp需要连接数据库的话
就要jdk来提供连接数据库的驱程，所以要运行jsp的web服务器平台就需要APACHE+TOMCAT+JDK 整合的好处是： 如果客户端请求的是静态页面，则只需要Apache服务器响应请求 如果客户端请求动态页面，则是Tomcat服务器响应请求 因为jsp是服务器端解释代码的，这样整合就可以减少Tomcat的服务开销 三： apache:侧重于http server tomcat:侧重于servlet引擎，如果以standalone方式运行，功能上与apache等效 ， 支持JSP，但对静态网页不太理想； apache是web服务器，tomcat是应用（java）服务器，它只是一个servlet(jsp也翻译成servlet)容器，可以认为是apache的扩展，但是可以独立于apache运行。 换句话说，apache是一辆卡车，上面可以装一些东西如html等。但是不能装水，要装水必须要有容器（桶），而这个桶也可以不放在卡车上。
    </div>
  </div>
</div>

        
      
        <h2 class="f1">
          <a href="/tags/ubuntu16-php5" class="link blue hover-black">
            Tag: ubuntu16-php5
          </a>
        </h2>
        
          <div class="relative w-100 mb4 bg-white nested-copy-line-height">
  <div class="bg-white mb3 pa4 gray overflow-hidden">
    <span class="f6 db">Post</span>
    <h1 class="f3 near-black">
      <a href="http://github.wuquantai.com/" class="link black dim">
        网站迁移笔记
      </a>
    </h1>
    <div class="nested-links f5 lh-copy nested-copy-line-height">
      * _**迁移参考：**_ * _[https://www.digitalocean.com/community/tutorials/how-to-move-an-apache-web-root-to-a-new-location-on-ubuntu-16-04](https://www.digitalocean.com/community/tutorials/how-to-move-an-apache-web-root-to-a-new-location-on-ubuntu-16-04)_ * * **Ubuntu1604 安装php5.6** * 由于Ubuntu1604 默认安装的是php7。由于网站兼容性问题，需要装php5。 * 步骤参考：_[https://phpraxis.wordpress.com/2016/05/16/install-php-5-6-or-5-5-in-ubuntu-16-04-lts-xenial-xerus/](https://phpraxis.wordpress.com/2016/05/16/install-php-5-6-or-5-5-in-ubuntu-16-04-lts-xenial-xerus/)_ * &gt; add-apt-repository ppa:ondrej/php   apt-get update apt-get install php5.6 php5.6-mbstring php5.6-mysql php5.6-sqlite3 还有这些按需要装 php5.6-cli php5.6-curl php5.6-json php5.6-mcrypt php5.6-curl php-xdebug libapache2-mod-php5.6 libapache2-mod-php7.0 mysql-server-5.7 apache2
  * # php 版本切换方法2   sudo a2dismod php7.0 ; sudo a2enmod php5.6 ; sudo service apache2 restart ; echo 1 | sudo update-alternatives &ndash;config php sudo a2dismod php5.6 ; sudo a2enmod php7.
    </div>
  </div>
</div>

        
      
        <h2 class="f1">
          <a href="/tags/udp" class="link blue hover-black">
            Tag: udp
          </a>
        </h2>
        
          <div class="relative w-100 mb4 bg-white nested-copy-line-height">
  <div class="bg-white mb3 pa4 gray overflow-hidden">
    <span class="f6 db">Post</span>
    <h1 class="f3 near-black">
      <a href="http://github.wuquantai.com/" class="link black dim">
        Ethernet、IP、TCP、UDP帧头格式、详解
      </a>
    </h1>
    <div class="nested-links f5 lh-copy nested-copy-line-height">
      引用：http://zoufengfu168.blog.163.com/blog/static/5461055200991333616451/ 一、MAC帧头定义 [c] typedef struct _MAC_FRAME_HEADER { char m_cDstMacAddress[6]; //目的mac地址 char m_cSrcMacAddress[6]; //源mac地址 /* 如0x0800代表上一层是IP协议，0x0806为arp, 0x88a4为Ethercat */ short m_cType; //上一层协议类型， }__attribute__((packed))MAC_FRAME_HEADER,*PMAC_FRAME_HEADER; Etherne II 长度为14 byte;
typedef struct _MAC_FRAME_TAIL { unsigned int m_sCheckSum; //数据帧尾校验和 }attribute((packed))MAC_FRAME_TAIL, PMAC_FRAME_TAIL; [/c] 补充VLAN 和ARP： [c] // #define ETHTYPE_ARP 0x0806U #define ETHTYPE_IP 0x0800U #define ETHTYPE_VLAN 0x8100U #define ETHTYPE_PPPOEDISC 0x8863U / PPP Over Ethernet Discovery Stage / #define ETHTYPE_PPPOE 0x8864U / PPP Over Ethernet Session Stage */
/** VLAN header inserted between ethernet header and payload
    </div>
  </div>
</div>

        
      
        <h2 class="f1">
          <a href="/tags/yagarto" class="link blue hover-black">
            Tag: yagarto
          </a>
        </h2>
        
          <div class="relative w-100 mb4 bg-white nested-copy-line-height">
  <div class="bg-white mb3 pa4 gray overflow-hidden">
    <span class="f6 db">Post</span>
    <h1 class="f3 near-black">
      <a href="http://github.wuquantai.com/" class="link black dim">
        Eclipse ARM IDE 开发环境搭建
      </a>
    </h1>
    <div class="nested-links f5 lh-copy nested-copy-line-height">
      一、Eclipse
Eclipse的本身只是一个框架平台，但是众多插件的支持，使得Eclipse拥有较好的灵活性。依托于Java 环境运行，所以必须安装 Jre。
二、CDT
CDT是Eclipse用于扩展Eclipse支持C/C++开发的插件。可直接下载带CDT的Eclipse。
三、Zylin CDT
支持Eclipse用于嵌入式C/C++开发和远程调试的插件。
四、Yagarto
Yagarto是整合了GNU arm的交叉编译工具链，是一个跨平台的 ARM 架构开发平台。他们说了，由于基于MinGW的ToolChain 的GDB 跟Eclipse 配合不是很好，所以Yagarto 出现了。目前Yagarto 项目已经完结。此外Yagrato 建议使用免费的
 * [emIDE](http://www.emide.org/) (free Visual Studio Style IDE including GNU Tools for ARM) 。其集成了GNU Tools。  五、J-LINK GDB Server
A JTAG GDB Debug agent run on Host
六、IDE整体结构框图
安装：
1、安装Java SE
下载地址：http://www.oracle.com/technetwork/java/javase/downloads/jre-7u3-download-1501631.html
设置环境变量:
如果只安装Jre的话就添加 : JAVA_HOME = C:\Program Files\Java\jre1.8.0_65;
若是安装JDK的话就添加 : JAVA_HOME = C:\Program Files\Java\jdk1.8.0_65;
Path = %JAVA_HOME%\bin;%JAVA_HOME%\jre\bin;
//安装JDK时，JDK内部有个jre目录，外部也默认安装了一个jre目录。一般配置jre环境为内部jre目录。
CLASSPATH = .
    </div>
  </div>
</div>

        
      
        <h2 class="f1">
          <a href="/tags/zcu102" class="link blue hover-black">
            Tag: zcu102
          </a>
        </h2>
        
          <div class="relative w-100 mb4 bg-white nested-copy-line-height">
  <div class="bg-white mb3 pa4 gray overflow-hidden">
    <span class="f6 db">Post</span>
    <h1 class="f3 near-black">
      <a href="http://github.wuquantai.com/" class="link black dim">
        编译PYNQ 在ZCU102上的镜像
      </a>
    </h1>
    <div class="nested-links f5 lh-copy nested-copy-line-height">
      由于PYNQ官方没有编译好的ZCU102的镜像，所以需要自己手动编译。这里记录一下编译过程。
因为手头上的ZCU102 批次比较新，所以目前只能使用2018.3 版本的SDK才能BOOT起来。（应该是由于换了DDR型号了，所以老版本的镜像是BOOT不起来的。板子版本是REVISION 1.1的 新批号）
PYNQ 版本Xilinx Tool 版本对应 ** 参考：**
https://blog.csdn.net/vacajk/article/details/84728062 https://github.com/Xilinx/PYNQ/tree/image_v2.4/sdbuild
https://pynq.readthedocs.io/en/latest/pynq_sd_card.html#pynq-sd-card
准备工作  使用事先编译好的文件系统: bionic.aarch64.2.4.img * ZCU102 BSP: xilinx-zcu102-v2018.3-final.bsp * 如果非官方板子，比如黑金的AC7020, 没有BSP, 则可以从vivado 工程导出hdf 文件，给petalinux 生成一个bsp * 安装好SDSoc2018.3, PetaLinux2018.3 * 系统环境 Ubuntu 1604-64  编译步骤 # 下载 pynq $ git clone https://github.com/Xilinx/PYNQ.git $ cd PYNQ $ git checkout image_v2.4 # 检查依赖环境，qemu，crosstool-ng $ cd ./sdbuild/ $ ./scripts/setup_host.sh # 准备 ZCU102 setting $ cp -rf ./boards/ZCU104 ./boards/ZCU102 $ rm -rf .
    </div>
  </div>
</div>

        
      
        <h2 class="f1">
          <a href="/tags/zynq-linux" class="link blue hover-black">
            Tag: zynq-linux
          </a>
        </h2>
        
          <div class="relative w-100 mb4 bg-white nested-copy-line-height">
  <div class="bg-white mb3 pa4 gray overflow-hidden">
    <span class="f6 db">Post</span>
    <h1 class="f3 near-black">
      <a href="http://github.wuquantai.com/" class="link black dim">
        zynq 嵌入式开发总结
      </a>
    </h1>
    <div class="nested-links f5 lh-copy nested-copy-line-height">
      传统开发步骤 基础设计
&lt;code&gt;# 使用Vidado 设计硬件工程，导出硬件设计 bitstream. $ File-&gt; Export-&gt; Export Hardware... # 使用SDK 生成 fsbl.elf # 编译U-boot $ make CROSS_COMPILE=arm-xilinx-linux-gnueabi- zynq_ac7020_defconfig # 使用SDK， Xilinx Tools-&gt;Create Boot Image 生成BOOT.BIN。 即: fsbl.elf + system_wrapper.bit + u-boot.elf&lt;/code&gt;  编译kernel
&lt;code&gt;$ make ARCH=arm CROSS_COMPILE=arm-xilinx-linux-gnueabi- uImage LOADADDR=0x00008000 # 生成 /arch/arm/boot/uImage&lt;/code&gt;  编译device tree
&lt;code&gt;$ dtc -I dts -O dtb devicetree.dtb ./arch/arm/boot/dts/AC7020.dts&lt;/code&gt;  制作文件系统
&lt;code&gt;$ 基于RAM 的 ramdisk $ 基于Flash 的 jffs2 $ 基于network 的 NFS&lt;/code&gt;  将 BOOT.
    </div>
  </div>
</div>

        
      
        <h2 class="f1">
          <a href="/tags/%E4%BA%92%E6%96%A5%E9%87%8F" class="link blue hover-black">
            Tag: 互斥量
          </a>
        </h2>
        
          <div class="relative w-100 mb4 bg-white nested-copy-line-height">
  <div class="bg-white mb3 pa4 gray overflow-hidden">
    <span class="f6 db">Post</span>
    <h1 class="f3 near-black">
      <a href="http://github.wuquantai.com/" class="link black dim">
        一个例子讲清楚线程间同步、互斥量、条件变量、队列、内存池
      </a>
    </h1>
    <div class="nested-links f5 lh-copy nested-copy-line-height">
      前段时间有朋友想要了解一下多线程编程，正好有个项目上有这么个例子可以抽出来讲一讲。只要搞清楚这个例子，就一下子掌握了线程间同步、互斥量、条件变量、队列、内存池的概念和使用。
首先，线程间同步的概念。
比如，学过数字电路的人都知道，两个时钟域的信号如果没有经过同步直接接到一起的话，会引起亚稳态。原因是如果恰好输入信号在时钟边沿附近变化的话（不满足建立保持时间的情况下），信号可能处于一个中间电平，这样会导致触发器处于一个振荡状态，引起整块数字电路的不稳定。这就是数字电路中异步的概念，两个时钟都是各自free running，彼此没有关系。
再比如单片机程序中，各个不同的中断程序或者跟主程序间是异步的，因为主程序在执行的过程中随时可能被进来的中断打断，如果中断和主程序之间要通过一个共享的变量传递数据，你就要注意这个共享的变量的保护。假如主程序只读取了一半的数据而被中断打断，然后中断程序中又更新了整个变量，这样的回到主程序继续执行时读到的数据就有一半是上一次的，一半是更新过的。这样的结果显然不是我们想要的。这里只是举了一个很明显的例子。更多的情况可以搜索一下“原子操作”。
所以在多线程环境下，我们就要注意线程间共享变量的保护，这块敏感区域叫临界区(Critical area)。在单片机中，我们用中断开关来保护共享变量读写操作的完整性。在操作系统中，我们用的是互斥锁（mutex）来占有这个变量，防止它被多个线程同时访问。当一个线程访问当前已经被另一个线程占有的变量时，就会进入阻塞态，直到另一个线程完成解锁操作后，这个线程将得到继续执行。
互斥锁(mutex)是多线程编程时最重要的一个工具，用来解决多线程竞争同个资源的问题。其最底层的实现都是一个原子操作来界定lock or unlock。
接下来的例子创建了两个线程，一个是producer, 另一个是cusumer, 它们两个是异步的，中间通过一个队列来通讯。producer 向队列中发送数据，cusumer读取数据。模拟了一个场景：producer 以较快的速度向队列写数据，cusumer 处理数据较慢。这在图像帧处理时经常会碰到CPU处理和发送数据较慢，而外设采集速度较快的情况，这样多余的帧将被丢弃。队列节点使用自己写的一个内存池来分配，在malloc_node 从内存池(free_queue)里取出node; release_node 时把节点放回资源池。当对free_queue 进行操作的时候都要加锁，因为malloc_node 和release_node 可能被不同的线程调用，必须对free_queue 进行保护。这样的函数称之为是线程安全的。同理对enqueue，dequeue的操作也要对队列进行保护。
然后使用条件变量来通知consumer 队列有新数据到来。条件变量同样是被多个线程调用，也是需要带一个mutex 来进行保护的。当条件不满足时，线程会解锁mutex 进入block状态等待消息，这样才不会一直占有CPU。当条件满足或者超时时，才继续执行下面的程序。
例子中使用了pthread(POSIX thread) 的实现。其实各大操作系统都有自己的实现，FreeRTOS, Linux kernel等等，都可以拿代码过来看看学习。
请看这个多线程的例子，可以在online gdb 中运行调试：
#include &lt;stdio.h&gt; #include &lt;stdlib.h&gt; #include &lt;stdint.h&gt; #include &lt;string.h&gt; #include &lt;pthread.h&gt; #include &lt;stdbool.h&gt; #include &lt;assert.h&gt; #include &lt;sys/time.h&gt; #include &lt;errno.h&gt; /************ queue manage ***********/ typedef struct Node { void *data; struct Node *next; }queue_node_t; #define BUFFER_POOL_SIZE (640 * 480) #define BUFFER_POOL_NUM 5 struct pbuf{ uint32_t len; uint8_t payload[BUFFER_POOL_SIZE]; }; typedef struct QueueList { int sizeOfQueue; uint16_t memSize; queue_node_t *head; queue_node_t *tail; }queue_t; /* to inform consumer_thread */ static pthread_cond_t cap_cond; static pthread_mutex_t cap_mutex; /* stream queue for communicate between two threads */ static queue_t strm_queue; static pthread_mutex_t strmq_mutex; int strm_queue_init(){ queue_t *q = &amp;strm_queue; q-&gt;sizeOfQueue = 0; q-&gt;memSize = 0; q-&gt;head = q-&gt;tail = NULL; if (pthread_cond_init(&amp;cap_cond, NULL) !
    </div>
  </div>
</div>

        
      
        <h2 class="f1">
          <a href="/tags/%E5%B7%A5%E4%B8%9A%E4%BB%A5%E5%A4%AA%E7%BD%91" class="link blue hover-black">
            Tag: 工业以太网
          </a>
        </h2>
        
          <div class="relative w-100 mb4 bg-white nested-copy-line-height">
  <div class="bg-white mb3 pa4 gray overflow-hidden">
    <span class="f6 db">Post</span>
    <h1 class="f3 near-black">
      <a href="http://github.wuquantai.com/" class="link black dim">
        [转]各种工业以太网比较（EtherCAT,EtherNet/IP,ProfiNet,Modbus-TCP,Powerlink）
      </a>
    </h1>
    <div class="nested-links f5 lh-copy nested-copy-line-height">
      EtherCAT（以太网控制自动化技术）是一个以以太网为基础的开放架构的现场总线系统，EterCAT名称中的CAT为ControlAutomation Technology（控制自动化技术）首字母的缩写。最初由德国倍福自动化有限公司(Beckhoff AutomationGmbH)研发。EtherCAT为系统的实时性能和拓扑的灵活性树立了新的标准，同时，它还符合甚至降低了现场总线的使用成本。EtherCAT的特点还包括高精度设备同步，可选线缆冗余，和功能性安全协议(SIL3)。
Ethernet/IP是一个面向工业自动化应用的工业应用层协议。它建立在标准UDP/IP与TCP/IP协议之上，利用固定的以太网硬件和软件，为配置、访问和控制工业自动化设备定义了一个应用层协议西蒙公司开发
PROFINET由PROFIBUS国际组织（PROFIBUS International，PI）推出，是新一代基于工业以太网技术的自动化总线标准。作为一项战略性的技术创新，PROFINET为自动化通信领域提供了一个完整的网络解决方案，囊括了诸如实时以太网、运动控制、分布式自动化、故障安全以及网络安全等当前自动化领域的热点话题，并且，作为跨供应商的技术，可以完全兼容工业以太网和现有的现场总线（如PROFIBUS）技术，保护现有投资。
PROFINET是适用于不同需求的完整解决方案，其功能包括8个主要的模块，依次为实时通信、分布式现场设备、运动控制、分布式自动化、网络安装、IT标准和信息安全、故障安全和过程自动化。
MODBUS/TCP是简单的、中立厂商的用于管理和控制自动化设备的MODBUS系列通讯协议的派生产品。显而易见，它覆盖了使用TCP/IP协议的 “Intranet”和“Internet”环境中MODBUS 报文的用途。协议的最通用用途是为诸如PLC’s，I/O模块，以及连接其它简单域总线或I/O模块的网关服务的。 MODBUS/TCP协议是作为一种（实际的）自动化标准发行的。既然MODBUS已经广为人知，该规范只将别处没有收录的少量信息列入其中。然而，本规范力图阐明MODBUS中哪种功能对于普通自动化设备的互用性有价值，哪些部分是MODBUS作为可编程的协议交替用于PLC’s的“多余部分”。 它通过将配套报文类型“一致性等级”，区别那些普遍适用的和可选的，特别是那些适用于特殊设备如PLC’s的报文。
POWERLINK=CANopen+Ethernet
鉴于以太网的蓬勃发展和CANopen在自动化领域里的广阔应用基础，EthernetPOWERLINK 融合了这两项技术的优点和缺点，即拥有了Ethernet的高速、开放性接口，以及CANopen在工业领域良好的SDO 和PDO 数据定义，在某种意义上说POWERLINK就是Ethernet 上的CANopen，物理层、数据链路层使用了Ethernet介质，而应用层则保留了原有的SDO和PDO对象字典的结构 虽然这些工业以太网都是国际标准，但是指的是IEC 61784里的标准，但是这些工业以太网不都是标准的以太网。即这些工业以太网并不都是符合IEEE802.3U的标准，这当中只有Modbus-TCP和EtherNet/IP是符合IEEE802.3U的，只有符合IEEE802.3U标准的，才能与IT和以太网将来的发展相兼容。而不符合IEEE802.3U标准的，基本上可以讲不是以太网，它们都对以太网进行了修改，或者是硬件或者是软件，已经不是以太网了。
各种工业以太网的区别其实主要就是协议的区别，其中最主要的还是应用层协议的区别，我们知道，按照ISO的参考模型，网络被划分为7层。
a. Modbus TCP和EtherNet/IP的区别主要是应用层不相同，ModbusTCP的应用层采用Modbus协议，而EtherNet/IP采用CIP协议，这两种工业以太网的数据链路层采用的是CSMA/CD，因此是标准的以太网，另外，这两种工业以太网的网络层和传输层采用TCP/IP协议族。还有一个区别是，Modbus协议中迄今没有协议来完成功能安全、高精度同步和运功控制等，而EtherNet/IP有CIPSafety、CIP Sync和CIP Motion来完成上述功能，所以才有Schneider加入ODVA，成为ODVA的核心成员来推广EtherNet/IP。由于这两种网络都是标准的TCP/IP以太网，所以所有标准以太网节点都可以接入这两种网络。
b. b. 至于EthernetPowerLink(EPL), Ethernet PowerLink就是个怪胎，PowerLink虽然在物理层和数据链路层还是采用标准的以太网，但是它又添加了另一个数据链路层，此EPL数据链路层在结构上为于以太网数据链路层之上。我们知道数据链路层的一个子层的MAC(介质访问)层的作用是[color=#FF0000]决定哪一个节点可以占有总线，也即决定哪个节点一个发送数据[/color]。所以本来由以太网的数据链路层来决定哪一个节点占用总线，现在它被位于它之上的EPL数据链路层给架空了，由这个EPL数据链路层通过软件的方式来决定哪个节点发送数据。所有在这样的一个EPL工业以太网系统中，不能使用交换机，只能使用HUB，所以对100M的网络，EPL总的带宽是小于100m,一盘情况下只有40－50M，而如果采用交换机的工业以太网，它的带宽可以达到大几百M,另外在EPL网络上，所有的节点都要实现EPL数据链路。没有实现EPL数据链路层的节点不能接入此网络。
c. PROFINET分为原来划分为v1,v2,v3，现在一般称为ProfiNetCBA、ProfiNet IO和ProfiNet IRT.也就是通过以太网来实现对等通讯、实时控制和运动控制。v1采用TCP/IP协议，采用标准的以太网，而V2和V3不采用tcp/ip协议，这两种都绕过tcp/ip协议，采用另外的网络层和传输层协议，开发ProfiNet采用开发人员人员认为tcp/ip协议增加了数据在网络中的传输延迟，其实这是一种误解，据美国密歇根大学的教授研究后认为数据在TCP/IP中的传输延迟很小，他们研究得出数据在经过TCP,IP栈时延迟只有不到100微秒，如果采用UDP/IP时就更小，同时他们研究也得出数据在不同应用层延时比较大，不同的协议延迟不一样，但是相差不是很大，从200us-800us不等，他们经过实验后认为以太网的基础设施(指交换机、网卡等）和TCP/IP协议并不是影响工业以太网实时性的主要原因，而认为应用层协议才是主要原因。所以密歇根大学的教授认为绕开TCP/IP协议没有丝毫的意义，反而由于缺少了TCP/IP协议，使得设备也就缺少了IT功能，与其它现场总线没有区别。 ProfiNet V3就更特别了，它不完全采用标准以太网的数据链路层，有一不时间采用以太网的数据链路层(CSMA/CD)，而另外一部分时间采用自己的数据链路层，通过一个高精度的时间来完成。所以ProfiNet V3也就不是标准的以太网了，也就给Profinet v3带来如下的问题：不能采用标准的交换机、不能采用标准的以太网芯片、与企业网相连可能会出现问题，与标准以太网相连还要特殊的网关、添加和删除一个节点都需要重新组态网络和重新启动网络、至今没有千兆网络，还有最重要的是，当标准以太网以后发展了后，它不能与标准以太网相兼容，不具有将来以太网所应具有的功能。
d. EtherCat这种工业以太网也很奇怪，它们不使用标准的芯片，一般不使用交换机，软件也不是标准的，对以太网的数据帧进行了一些修改，我们知道一个数据帧只有一个源节点，但是对于EtherCat一个数据可能有多个源节点，即一个数据是由多个节点发送的数据组合而成的。所以对于这样的网络，标准的以太网设备也不能接入这样的网络。
我认为Ethernet/IP和ProfiNet这两种工业以太网都适合各个行业，并不象heidai讲的应用的行业不一样。首先这两种工业以太网都用于传输非实时数据，还可传输实时数据，即可以用于离散控制，也可用于过程控制(当然现在还不能用于本安应用)。其次，这两种工业以太网都可用于网络功能安全传输，Ethernet/IP有CIP Safety协议，而ProfiNet有Profisafe协议,还有在运动控制方面ProfiNet有 ProfiNet IRT，而EtherNet/IP则有CIP Safety,二者都可以用于中高端的运动控制。最后两者都有基于IEEE1588的高精度时钟同步。而Modbus TCP,EtherCat和PowerLink,都只能完成部分控制任务，如Modbus TCP一般只作常规IO实时和非实时数据。而EtherCat和PowerLink则更象是为运动控制而开发的，这二者好像没有功能安全、在PLC和DCS控制方面也没有得到大自动化公司的支持，况且这两者又对以太网进行修改，一个在软件，另一个在软件和硬件方面都进行了修改，都不能兼容标准的以太网设备，个人认为这样做得不偿失，为满足运动控制而不能兼容已有的标准的以太网设备而开发的工业以太网并不是以太网，与其说是工业以太网还不如说是另一种现场总线。 我认为工业以太网的竞争将会在Ethernet/IP和ProfiNet间进行，而其它工业以太网都是这两者的陪衬，将会逐渐退出市场。 EtherNet/IP以后将由罗克韦尔自动化、Omron、施耐德和思科公司来推动，而ProfiNet将由业界老大西门子公司带领一些小公司去奋斗，由国内PLC厂商中的老二、老三和老五对老大，不知谁将引导未来。
其实，工业以太网里还有几个怪胎，举两个例吧：
SynqNet: 丹纳赫主导的，几乎只用在运动控制，而且据说只用在了半导体机械行业（奇怪的是，不才也搞半导体机械很久了，却从来没看到过SynqNet，孤陋寡闻啊）。只用了以太网的硬件，完全和我们平常说的以太网没有任何关系，连MAC层都没有。当然如此运用，速度性能当然好，但未来难说。
Sercos III: 光纤SercosII的新一代以太网版本，背后推手是博世力士乐，只用在运动控制。也基本上是只用了以太网底层硬件，系统里竟然连switch都不允许用。速度当然快，但只比SercosII快了一倍。估计用了SercosII的用户，谁会去更新到一个没快了多少的新系统啊，还没问世，就已经不被业界看好了。
我个人认为，最后一定是大西洋两岸的两大巨人之间的角力，就像以前的现场总线战争，最后还不是Profibus和DeviceNet，别的都只能当陪衬的角色？
当然，现在大家都在看中国这个大西洋两岸以外的单一最大市场，中国把砝码放在谁这一边，可能会使天平倾斜一点。但最后，肯定两者都会存在的。我个人认为，咱们应该选Ethernet/IP这一边站
中国用户和制造商应选择Ethernet/IP还是ProfiNet，各人的看法有所不同，不过我认为firstrazor所说的没错，有于ProfiNet采用了专门的芯片、网卡、交换机等以太网基础设施，虽然ProfiNet应用层协议是公开的，但这些芯片却是专用，国内的制造商要想开发符合ProfiNet标准的设备，确要依赖于这些芯片，受制于提供芯片的公司，也就是西门子公司，因此可以将ProfiNet并不是完全开放的。而相反，Ethernet/IP不论是在软件还是硬件上都是标准和开放的，国内的工业以太网制造商还是选择EtherNet/IP为好，至于最终用户的选择，当然是从可靠性、价格、兼容性和可替换性方面考虑，可靠性方面，二者没有明显区别，在其它方面Ethernet/IP具有明显的优势
    </div>
  </div>
</div>

        
      
        <h2 class="f1">
          <a href="/tags/%E7%BA%BF%E7%A8%8B%E5%90%8C%E6%AD%A5" class="link blue hover-black">
            Tag: 线程同步
          </a>
        </h2>
        
          <div class="relative w-100 mb4 bg-white nested-copy-line-height">
  <div class="bg-white mb3 pa4 gray overflow-hidden">
    <span class="f6 db">Post</span>
    <h1 class="f3 near-black">
      <a href="http://github.wuquantai.com/" class="link black dim">
        一个例子讲清楚线程间同步、互斥量、条件变量、队列、内存池
      </a>
    </h1>
    <div class="nested-links f5 lh-copy nested-copy-line-height">
      前段时间有朋友想要了解一下多线程编程，正好有个项目上有这么个例子可以抽出来讲一讲。只要搞清楚这个例子，就一下子掌握了线程间同步、互斥量、条件变量、队列、内存池的概念和使用。
首先，线程间同步的概念。
比如，学过数字电路的人都知道，两个时钟域的信号如果没有经过同步直接接到一起的话，会引起亚稳态。原因是如果恰好输入信号在时钟边沿附近变化的话（不满足建立保持时间的情况下），信号可能处于一个中间电平，这样会导致触发器处于一个振荡状态，引起整块数字电路的不稳定。这就是数字电路中异步的概念，两个时钟都是各自free running，彼此没有关系。
再比如单片机程序中，各个不同的中断程序或者跟主程序间是异步的，因为主程序在执行的过程中随时可能被进来的中断打断，如果中断和主程序之间要通过一个共享的变量传递数据，你就要注意这个共享的变量的保护。假如主程序只读取了一半的数据而被中断打断，然后中断程序中又更新了整个变量，这样的回到主程序继续执行时读到的数据就有一半是上一次的，一半是更新过的。这样的结果显然不是我们想要的。这里只是举了一个很明显的例子。更多的情况可以搜索一下“原子操作”。
所以在多线程环境下，我们就要注意线程间共享变量的保护，这块敏感区域叫临界区(Critical area)。在单片机中，我们用中断开关来保护共享变量读写操作的完整性。在操作系统中，我们用的是互斥锁（mutex）来占有这个变量，防止它被多个线程同时访问。当一个线程访问当前已经被另一个线程占有的变量时，就会进入阻塞态，直到另一个线程完成解锁操作后，这个线程将得到继续执行。
互斥锁(mutex)是多线程编程时最重要的一个工具，用来解决多线程竞争同个资源的问题。其最底层的实现都是一个原子操作来界定lock or unlock。
接下来的例子创建了两个线程，一个是producer, 另一个是cusumer, 它们两个是异步的，中间通过一个队列来通讯。producer 向队列中发送数据，cusumer读取数据。模拟了一个场景：producer 以较快的速度向队列写数据，cusumer 处理数据较慢。这在图像帧处理时经常会碰到CPU处理和发送数据较慢，而外设采集速度较快的情况，这样多余的帧将被丢弃。队列节点使用自己写的一个内存池来分配，在malloc_node 从内存池(free_queue)里取出node; release_node 时把节点放回资源池。当对free_queue 进行操作的时候都要加锁，因为malloc_node 和release_node 可能被不同的线程调用，必须对free_queue 进行保护。这样的函数称之为是线程安全的。同理对enqueue，dequeue的操作也要对队列进行保护。
然后使用条件变量来通知consumer 队列有新数据到来。条件变量同样是被多个线程调用，也是需要带一个mutex 来进行保护的。当条件不满足时，线程会解锁mutex 进入block状态等待消息，这样才不会一直占有CPU。当条件满足或者超时时，才继续执行下面的程序。
例子中使用了pthread(POSIX thread) 的实现。其实各大操作系统都有自己的实现，FreeRTOS, Linux kernel等等，都可以拿代码过来看看学习。
请看这个多线程的例子，可以在online gdb 中运行调试：
#include &lt;stdio.h&gt; #include &lt;stdlib.h&gt; #include &lt;stdint.h&gt; #include &lt;string.h&gt; #include &lt;pthread.h&gt; #include &lt;stdbool.h&gt; #include &lt;assert.h&gt; #include &lt;sys/time.h&gt; #include &lt;errno.h&gt; /************ queue manage ***********/ typedef struct Node { void *data; struct Node *next; }queue_node_t; #define BUFFER_POOL_SIZE (640 * 480) #define BUFFER_POOL_NUM 5 struct pbuf{ uint32_t len; uint8_t payload[BUFFER_POOL_SIZE]; }; typedef struct QueueList { int sizeOfQueue; uint16_t memSize; queue_node_t *head; queue_node_t *tail; }queue_t; /* to inform consumer_thread */ static pthread_cond_t cap_cond; static pthread_mutex_t cap_mutex; /* stream queue for communicate between two threads */ static queue_t strm_queue; static pthread_mutex_t strmq_mutex; int strm_queue_init(){ queue_t *q = &amp;strm_queue; q-&gt;sizeOfQueue = 0; q-&gt;memSize = 0; q-&gt;head = q-&gt;tail = NULL; if (pthread_cond_init(&amp;cap_cond, NULL) !
    </div>
  </div>
</div>

        
      
        <h2 class="f1">
          <a href="/tags/%E7%BD%91%E7%AB%99%E8%BF%81%E7%A7%BB" class="link blue hover-black">
            Tag: 网站迁移
          </a>
        </h2>
        
          <div class="relative w-100 mb4 bg-white nested-copy-line-height">
  <div class="bg-white mb3 pa4 gray overflow-hidden">
    <span class="f6 db">Post</span>
    <h1 class="f3 near-black">
      <a href="http://github.wuquantai.com/" class="link black dim">
        网站迁移笔记
      </a>
    </h1>
    <div class="nested-links f5 lh-copy nested-copy-line-height">
      * _**迁移参考：**_ * _[https://www.digitalocean.com/community/tutorials/how-to-move-an-apache-web-root-to-a-new-location-on-ubuntu-16-04](https://www.digitalocean.com/community/tutorials/how-to-move-an-apache-web-root-to-a-new-location-on-ubuntu-16-04)_ * * **Ubuntu1604 安装php5.6** * 由于Ubuntu1604 默认安装的是php7。由于网站兼容性问题，需要装php5。 * 步骤参考：_[https://phpraxis.wordpress.com/2016/05/16/install-php-5-6-or-5-5-in-ubuntu-16-04-lts-xenial-xerus/](https://phpraxis.wordpress.com/2016/05/16/install-php-5-6-or-5-5-in-ubuntu-16-04-lts-xenial-xerus/)_ * &gt; add-apt-repository ppa:ondrej/php   apt-get update apt-get install php5.6 php5.6-mbstring php5.6-mysql php5.6-sqlite3 还有这些按需要装 php5.6-cli php5.6-curl php5.6-json php5.6-mcrypt php5.6-curl php-xdebug libapache2-mod-php5.6 libapache2-mod-php7.0 mysql-server-5.7 apache2
  * # php 版本切换方法2   sudo a2dismod php7.0 ; sudo a2enmod php5.6 ; sudo service apache2 restart ; echo 1 | sudo update-alternatives &ndash;config php sudo a2dismod php5.6 ; sudo a2enmod php7.
    </div>
  </div>
</div>

        
      
        <h2 class="f1">
          <a href="/tags/%E8%A1%A8%E5%8D%95%E6%A0%BC%E5%BC%8F" class="link blue hover-black">
            Tag: 表单格式
          </a>
        </h2>
        
          <div class="relative w-100 mb4 bg-white nested-copy-line-height">
  <div class="bg-white mb3 pa4 gray overflow-hidden">
    <span class="f6 db">Post</span>
    <h1 class="f3 near-black">
      <a href="http://github.wuquantai.com/" class="link black dim">
        HTTP协议与HTTP表单传输格式
      </a>
    </h1>
    <div class="nested-links f5 lh-copy nested-copy-line-height">
      HTTP请求 从使用者的角度看，一个HTTP请求起始于 用户端浏览器上输入的一个URL地址； 网页中的一个超链接； 提交一个HTML表单。 但本质上说，一个HTTP请求起始于用户端向HTTP服务器发送的一个URL请求。 一个标准的HTTP请求由以下几个部分组成
[code] [] [/code]
在HTTP请求中，第一行是请求行（request-line），用来说明请求类型、要访问的资源（URL）以及使用的HTTP版本； 紧接着是多行头部（headers）信息，用来说明服务器要使用的附加信息； 头部信息之后是一个回车换行符（/r/n），用于标明头部信息的结束。 以上是必须内容，根据需要可在头部信息结束之后增加主体数据（request-body）； 主体数据之后是一个回车换行符（/r/n），用于标明主体数据的结束。
需要注意的是 请求行（request-line）中的URL部分必须以application/x-www-form-urlencoded方式编码。 主体数据（request-body）的编码方式由头部（headers）信息中的Content-Type指定。 主体数据（request-body）的长度由头部（headers）信息中的Content-Length指定。
例如，我们可以在IE浏览器上输入下面的网址： http://localhost:8000/hello/index.html HTTP请求的头部信息如下： [code] GET /hello/index.html HTTP/1.1 Accept: / Accept-Language: zh-cn Accept-Encoding: gzip, deflate Host: localhost:8000 Connection: Keep-Alive Cookie: JSESSIONID=BBBA54D519F7A320A54211F0107F5EA6
[/code] 上述信息没有request-body部分，这是以GET方式发送的HTTP请求。如果请求中需要附加主体数据，即增加request-body部分，则必须使用POST方式发送HTTP请求。HTML超链接（）只能用GET方式提交HTTP请求，HTML表单()则可以使用两种方式提交HTTP请求。 HTML表单 HTML表单的使用方法如下：
[html] &hellip;
表单中存在各种类型的表单域标签，如
[html] 、及。 [/html]
每一种表单域标签均有NAME与VALUE两种标签属性。这两个标签属性决定了表单提交时传送的属性名及相应的值。 目标地址（URL） action标签属性指定了表单提交的目标地址，其值可以是完整的URL。如：
[html] &hellip;
这样的表单是不符合要求的。如果其URL值存在非法字符（如中文字符），应将其进行URL Encoding处理。URL Encoding的处理方法如下： 字母数字字符 &ldquo;a&rdquo; 到 &ldquo;z&rdquo;、&ldquo;A&rdquo; 到 &ldquo;Z&rdquo; 和 &ldquo;0&rdquo; 到 &ldquo;9&rdquo; 保持不变。 特殊字符 &ldquo;.&quot;、&quot;-&quot;、&quot;*&rdquo; 和 &ldquo;_&rdquo; 保持不变。 空格字符 &quot; &quot; 转换为一个加号 &ldquo;+&rdquo;。 所有其他字符都是不安全的，因此首先使用一种编码机制将它们转换为一个或多个字节。然后对每个字节用一个包含 3 个字符的字符串 &ldquo;%xy&rdquo; 表示，其中 xy 为该字节的两位十六进制表示形式。推荐的编码机制是 UTF-8。 将“中文”两个字符进行URL Encoding所得到的值就是“%E4%B8%AD%E6%96%87”。 所以正确的表单应该是：
    </div>
  </div>
</div>

        
      
        <h2 class="f1">
          <a href="/tags/%E9%98%BF%E9%87%8C%E4%BA%91%E6%8E%A8%E8%8D%90%E7%A0%81" class="link blue hover-black">
            Tag: 阿里云推荐码
          </a>
        </h2>
        
          <div class="relative w-100 mb4 bg-white nested-copy-line-height">
  <div class="bg-white mb3 pa4 gray overflow-hidden">
    <span class="f6 db">Post</span>
    <h1 class="f3 near-black">
      <a href="http://github.wuquantai.com/" class="link black dim">
        阿里云ECS推荐码9折 : ceyo2p
      </a>
    </h1>
    <div class="nested-links f5 lh-copy nested-copy-line-height">
      阿里云ECS云服务器推荐码9折 : ceyo2p
    </div>
  </div>
</div>

        
      
    </section>
  </div>

    </main>
    <footer class="bg-black bottom-0 w-100 pa3" role="contentinfo">
  <div class="flex justify-between">
  <a class="f4 fw4 hover-white no-underline white-70 dn dib-ns pv2 ph3" href="http://github.wuquantai.com" >
    &copy;  Tagore's Studio 2020 
  </a>
    <div>




<a href="https://twitter.com/TagoreWu" target="_blank" class="link-transition twitter link dib z-999 pt3 pt0-l mr1" title="Twitter link" rel="noopener" aria-label="follow on Twitter——Opens in a new window">
  <svg height="32px"  style="enable-background:new 0 0 67 67;" version="1.1" viewBox="0 0 67 67" width="32px" xml:space="preserve" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink"><path d="M37.167,22.283c-2.619,0.953-4.274,3.411-4.086,6.101  l0.063,1.038l-1.048-0.127c-3.813-0.487-7.145-2.139-9.974-4.915l-1.383-1.377l-0.356,1.017c-0.754,2.267-0.272,4.661,1.299,6.271  c0.838,0.89,0.649,1.017-0.796,0.487c-0.503-0.169-0.943-0.296-0.985-0.233c-0.146,0.149,0.356,2.076,0.754,2.839  c0.545,1.06,1.655,2.097,2.871,2.712l1.027,0.487l-1.215,0.021c-1.173,0-1.215,0.021-1.089,0.467  c0.419,1.377,2.074,2.839,3.918,3.475l1.299,0.444l-1.131,0.678c-1.676,0.976-3.646,1.526-5.616,1.568  C19.775,43.256,19,43.341,19,43.405c0,0.211,2.557,1.397,4.044,1.864c4.463,1.377,9.765,0.783,13.746-1.568  c2.829-1.673,5.657-5,6.978-8.221c0.713-1.716,1.425-4.851,1.425-6.354c0-0.975,0.063-1.102,1.236-2.267  c0.692-0.678,1.341-1.419,1.467-1.631c0.21-0.403,0.188-0.403-0.88-0.043c-1.781,0.636-2.033,0.551-1.152-0.402  c0.649-0.678,1.425-1.907,1.425-2.267c0-0.063-0.314,0.042-0.671,0.233c-0.377,0.212-1.215,0.53-1.844,0.72l-1.131,0.361l-1.027-0.7  c-0.566-0.381-1.361-0.805-1.781-0.932C39.766,21.902,38.131,21.944,37.167,22.283z M33,64C16.432,64,3,50.569,3,34S16.432,4,33,4  s30,13.431,30,30S49.568,64,33,64z" style="fill-rule:evenodd;clip-rule:evenodd;fill:;"/></svg>

<span class="new-window"><svg  height="8px"  style="enable-background:new 0 0 1000 1000;" version="1.1" viewBox="0 0 1000 1000" width="8px" xml:space="preserve" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" >
<path d="M598 128h298v298h-86v-152l-418 418-60-60 418-418h-152v-86zM810 810v-298h86v298c0 46-40 86-86 86h-596c-48 0-86-40-86-86v-596c0-46 38-86 86-86h298v86h-298v596h596z" style="fill-rule:evenodd;clip-rule:evenodd;fill:;"/>
</svg>
</span></a>










</div>
  </div>
</footer>

    

  <script src="/dist/js/app.3fc0f988d21662902933.js"></script>


  </body>
</html>
