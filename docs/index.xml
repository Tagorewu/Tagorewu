<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Tagore&#39;s Studio</title>
    <link>/</link>
    <description>Recent content on Tagore&#39;s Studio</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>zh-CN</language>
    <lastBuildDate>Sun, 01 Dec 2013 15:50:13 +0000</lastBuildDate>
    
	<atom:link href="/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>又折腾网站迁移</title>
      <link>/post/%E5%8F%88%E6%8A%98%E8%85%BE%E7%BD%91%E7%AB%99%E8%BF%81%E7%A7%BB/</link>
      <pubDate>Tue, 14 Apr 2020 21:29:56 +0800</pubDate>
      
      <guid>/post/%E5%8F%88%E6%8A%98%E8%85%BE%E7%BD%91%E7%AB%99%E8%BF%81%E7%A7%BB/</guid>
      <description>终于把wordpress 的博客用hugo 转成静态网站放到github 了, 不过还很多细节要调整。
前段时间国内的域名空间备案被注销了，因为域名和空间不在同一家，真是无语。
之前是因为备案的那家空间续费太贵了，然后就把网站搬到另一家做活动的服务器上了。结果半年后就被警告备案的域名没有指向他家的服务器，要被注销。查了一下它家服务器还是贵，还让不让人活了。索性把网站做成纯静态的搬到github 上了。真是不容易。
也难怪这几年国内中文搜索的内容质量起来越差了。
这就有种像住出租房付不起房租，被赶来赶去的感觉。国内这一套真是被玩得越来越溜了。</description>
    </item>
    
    <item>
      <title>域内的PC 访问非域内的samba服务器</title>
      <link>/post/%E5%9F%9F%E5%86%85%E7%9A%84pc-%E8%AE%BF%E9%97%AE%E9%9D%9E%E5%9F%9F%E5%86%85%E7%9A%84samba%E6%9C%8D%E5%8A%A1%E5%99%A8/</link>
      <pubDate>Tue, 23 Apr 2019 01:22:22 +0000</pubDate>
      
      <guid>/post/%E5%9F%9F%E5%86%85%E7%9A%84pc-%E8%AE%BF%E9%97%AE%E9%9D%9E%E5%9F%9F%E5%86%85%E7%9A%84samba%E6%9C%8D%E5%8A%A1%E5%99%A8/</guid>
      <description>加入某个域内的PC 在登录samba服务器的时候，默认会在USERNAME 前加上DOMAIN\, 所以一直登录失败。登陆窗口上也无法取消加 DOMAIN\。
解决方法：
控制面板-&amp;gt;凭据管理器(Credential Manager) -&amp;gt; 手动添加Windows 凭据， 这样就可以用此用户账户正常登录了。</description>
    </item>
    
    <item>
      <title>zynq 嵌入式开发总结</title>
      <link>/post/zynq-%E5%B5%8C%E5%85%A5%E5%BC%8F%E5%BC%80%E5%8F%91%E6%80%BB%E7%BB%93/</link>
      <pubDate>Sat, 20 Apr 2019 13:59:51 +0000</pubDate>
      
      <guid>/post/zynq-%E5%B5%8C%E5%85%A5%E5%BC%8F%E5%BC%80%E5%8F%91%E6%80%BB%E7%BB%93/</guid>
      <description>传统开发步骤 基础设计
# 使用Vidado 设计硬件工程，导出硬件设计 bitstream.$ File-&amp;gt; Export-&amp;gt; Export Hardware...# 使用SDK 生成 fsbl.elf# 编译U-boot $ make CROSS_COMPILE=arm-xilinx-linux-gnueabi- zynq_ac7020_defconfig # 使用SDK， Xilinx Tools-&amp;gt;Create Boot Image 生成BOOT.BIN。即: fsbl.elf + system_wrapper.bit + u-boot.elf编译kernel
$ make ARCH=arm CROSS_COMPILE=arm-xilinx-linux-gnueabi- uImage LOADADDR=0x00008000 # 生成 /arch/arm/boot/uImage编译device tree
$ dtc -I dts -O dtb devicetree.dtb ./arch/arm/boot/dts/AC7020.dts制作文件系统
$ 基于RAM 的 ramdisk$ 基于Flash 的 jffs2$ 基于network 的 NFS将 BOOT.bin, devicetree.dtb, uImage 拷贝至SD卡的FAT 分区。文件系统拷贝至ext 分区即可。</description>
    </item>
    
    <item>
      <title>编译PYNQ 在ZCU102上的镜像</title>
      <link>/post/%E7%BC%96%E8%AF%91pynq-%E5%9C%A8zcu102%E4%B8%8A%E7%9A%84%E9%95%9C%E5%83%8F/</link>
      <pubDate>Fri, 05 Apr 2019 12:46:54 +0000</pubDate>
      
      <guid>/post/%E7%BC%96%E8%AF%91pynq-%E5%9C%A8zcu102%E4%B8%8A%E7%9A%84%E9%95%9C%E5%83%8F/</guid>
      <description>由于PYNQ官方没有编译好的ZCU102的镜像，所以需要自己手动编译。这里记录一下编译过程。
因为手头上的ZCU102 批次比较新，所以目前只能使用2018.3 版本的SDK才能BOOT起来。（应该是由于换了DDR型号了，所以老版本的镜像是BOOT不起来的。板子版本是REVISION 1.1的 新批号）
PYNQ 版本Xilinx Tool 版本对应 Release version
Xilinx Tool Version
v1.4
2015.4
v2.0
2016.1
v2.1
2017.4
v2.2
2017.4
v2.3
2018.2
v2.4
2018.3
参考：
https://blog.csdn.net/vacajk/article/details/84728062
https://github.com/Xilinx/PYNQ/tree/image_v2.4/sdbuild
https://pynq.readthedocs.io/en/latest/pynq_sd_card.html#pynq-sd-card
准备工作  使用事先编译好的文件系统: bionic.aarch64.2.4.img ZCU102 BSP: xilinx-zcu102-v2018.3-final.bsp  如果非官方板子，比如黑金的AC7020, 没有BSP, 则可以从vivado 工程导出hdf 文件，给petalinux 生成一个bsp   安装好SDSoc2018.3, PetaLinux2018.3 系统环境 Ubuntu 1604-64  编译步骤 \# 下载 pynq$ git clone https://github.com/Xilinx/PYNQ.git$ cd PYNQ$ git checkout image\_v2.4# 检查依赖环境，qemu，crosstool-ng$ cd .</description>
    </item>
    
    <item>
      <title>一个例子讲清楚线程间同步、互斥量、条件变量、队列、内存池</title>
      <link>/post/%E4%B8%80%E4%B8%AA%E4%BE%8B%E5%AD%90%E8%AE%B2%E6%B8%85%E6%A5%9A%E7%BA%BF%E7%A8%8B%E9%97%B4%E5%90%8C%E6%AD%A5%E4%BA%92%E6%96%A5%E9%87%8F%E6%9D%A1%E4%BB%B6%E5%8F%98%E9%87%8F%E9%98%9F%E5%88%97%E5%86%85%E5%AD%98%E6%B1%A0/</link>
      <pubDate>Sun, 27 Jan 2019 12:37:31 +0000</pubDate>
      
      <guid>/post/%E4%B8%80%E4%B8%AA%E4%BE%8B%E5%AD%90%E8%AE%B2%E6%B8%85%E6%A5%9A%E7%BA%BF%E7%A8%8B%E9%97%B4%E5%90%8C%E6%AD%A5%E4%BA%92%E6%96%A5%E9%87%8F%E6%9D%A1%E4%BB%B6%E5%8F%98%E9%87%8F%E9%98%9F%E5%88%97%E5%86%85%E5%AD%98%E6%B1%A0/</guid>
      <description>前段时间有朋友想要了解一下多线程编程，正好有个项目上有这么个例子可以抽出来讲一讲。只要搞清楚这个例子，就一下子掌握了线程间同步、互斥量、条件变量、队列、内存池的概念和使用。
首先，线程间同步的概念。
比如，学过数字电路的人都知道，两个时钟域的信号如果没有经过同步直接接到一起的话，会引起亚稳态。原因是如果恰好输入信号在时钟边沿附近变化的话（不满足建立保持时间的情况下），信号可能处于一个中间电平，这样会导致触发器处于一个振荡状态，引起整块数字电路的不稳定。这就是数字电路中异步的概念，两个时钟都是各自free running，彼此没有关系。
再比如单片机程序中，各个不同的中断程序或者跟主程序间是异步的，因为主程序在执行的过程中随时可能被进来的中断打断，如果中断和主程序之间要通过一个共享的变量传递数据，你就要注意这个共享的变量的保护。假如主程序只读取了一半的数据而被中断打断，然后中断程序中又更新了整个变量，这样的回到主程序继续执行时读到的数据就有一半是上一次的，一半是更新过的。这样的结果显然不是我们想要的。这里只是举了一个很明显的例子。更多的情况可以搜索一下“原子操作”。
所以在多线程环境下，我们就要注意线程间共享变量的保护，这块敏感区域叫临界区(Critical area)。在单片机中，我们用中断开关来保护共享变量读写操作的完整性。在操作系统中，我们用的是互斥锁（mutex）来占有这个变量，防止它被多个线程同时访问。当一个线程访问当前已经被另一个线程占有的变量时，就会进入阻塞态，直到另一个线程完成解锁操作后，这个线程将得到继续执行。
互斥锁(mutex)是多线程编程时最重要的一个工具，用来解决多线程竞争同个资源的问题。其最底层的实现都是一个原子操作来界定lock or unlock。
接下来的例子创建了两个线程，一个是producer, 另一个是cusumer, 它们两个是异步的，中间通过一个队列来通讯。producer 向队列中发送数据，cusumer读取数据。模拟了一个场景：producer 以较快的速度向队列写数据，cusumer 处理数据较慢。这在图像帧处理时经常会碰到CPU处理和发送数据较慢，而外设采集速度较快的情况，这样多余的帧将被丢弃。队列节点使用自己写的一个内存池来分配，在malloc_node 从内存池(free_queue)里取出node; release_node 时把节点放回资源池。当对free_queue 进行操作的时候都要加锁，因为malloc_node 和release_node 可能被不同的线程调用，必须对free_queue 进行保护。这样的函数称之为是线程安全的。同理对enqueue，dequeue的操作也要对队列进行保护。
然后使用条件变量来通知consumer 队列有新数据到来。条件变量同样是被多个线程调用，也是需要带一个mutex 来进行保护的。当条件不满足时，线程会解锁mutex 进入block状态等待消息，这样才不会一直占有CPU。当条件满足或者超时时，才继续执行下面的程序。
例子中使用了pthread(POSIX thread) 的实现。其实各大操作系统都有自己的实现，FreeRTOS, Linux kernel等等，都可以拿代码过来看看学习。
请看这个多线程的例子，可以在online gdb 中运行调试：
#include &amp;lt;stdio.h&amp;gt;#include &amp;lt;stdlib.h&amp;gt;#include &amp;lt;stdint.h&amp;gt;#include &amp;lt;string.h&amp;gt;#include &amp;lt;pthread.h&amp;gt;#include &amp;lt;stdbool.h&amp;gt;#include &amp;lt;assert.h&amp;gt;#include &amp;lt;sys/time.h&amp;gt;#include &amp;lt;errno.h&amp;gt;/\*\*\*\*\*\*\*\*\*\*\*\* queue manage \*\*\*\*\*\*\*\*\*\*\*/typedef struct Node{void \*data;struct Node \*next;}queue\_node\_t;#define BUFFER\_POOL\_SIZE (640 \* 480)#define BUFFER\_POOL\_NUM 5struct pbuf{uint32\_t len;uint8\_t payload\[BUFFER\_POOL\_SIZE\];};typedef struct QueueList{int sizeOfQueue;uint16\_t memSize;queue\_node\_t \*head;queue\_node\_t \*tail;}queue\_t;/\* to inform consumer\_thread \*/static pthread\_cond\_t cap\_cond;static pthread\_mutex\_t cap\_mutex;/\* stream queue for communicate between two threads \*/static queue\_t strm\_queue;static pthread\_mutex\_t strmq\_mutex;int strm\_queue\_init(){queue\_t \*q = &amp;amp;strm\_queue;q-&amp;gt;sizeOfQueue = 0;q-&amp;gt;memSize = 0;q-&amp;gt;head = q-&amp;gt;tail = NULL;if (pthread\_cond\_init(&amp;amp;cap\_cond, NULL) !</description>
    </item>
    
    <item>
      <title>Linux 网络设置相关</title>
      <link>/post/linux-%E7%BD%91%E7%BB%9C%E8%AE%BE%E7%BD%AE%E7%9B%B8%E5%85%B3/</link>
      <pubDate>Sun, 09 Dec 2018 15:06:59 +0000</pubDate>
      
      <guid>/post/linux-%E7%BD%91%E7%BB%9C%E8%AE%BE%E7%BD%AE%E7%9B%B8%E5%85%B3/</guid>
      <description>参考</description>
    </item>
    
    <item>
      <title>ARM NEON Usage Note</title>
      <link>/post/arm-neon-usage-note/</link>
      <pubDate>Fri, 07 Dec 2018 08:02:10 +0000</pubDate>
      
      <guid>/post/arm-neon-usage-note/</guid>
      <description>简介 SIMD, 即Single Instruction Multiple Data（单指令多数据）的并行操作。CPU 在处理向量数据时有它的局限性。CPU的优势在于处理复杂多变的指令，而对于那种大数据量的重复性操作，ARM 为了增加处理效率，增加了这种并行处理模块, 即NEON(Advanced SIMD)。主要是在ARMv7 架构后的处理器使用。
NEON 的主要 components：
 NEON register file NEON integer execute pipeline NEON single-precision floating-point execute pipeline NEON load/store and permute pipeline  NEON 指令和 floating-point 指令使用的是相同的 register file。不同于ARM core的register file。此 register file 可以以 32-bit, 64-bit, 128-bit 方式访问。 The contents of the NEON registers are vectors of elements of the same data type. A vector is divided into lanes and each lane contains a data value called an element.</description>
    </item>
    
    <item>
      <title>H.264 codec Note</title>
      <link>/post/h-264-codec-note/</link>
      <pubDate>Mon, 19 Nov 2018 05:47:12 +0000</pubDate>
      
      <guid>/post/h-264-codec-note/</guid>
      <description>• Elements of a video Sequence
o Frames
o Slices
o MBs (macroblocks)
• Frame Types
o I-, P-, B-frames
o GOP (group of picture), specifies the order in which intra- and inter-frames are arranged.
o NAL (Network Abstraction Layer)
v SPS (Sequence parameter set)
v PPS (Picture parameter set)
v IDR (Instantaneous Decoder Refresh), every IDR frame is an I-frame, but not vice versa,
• Coding Tools
o Entropy Coding</description>
    </item>
    
    <item>
      <title>Plans</title>
      <link>/post/plans/</link>
      <pubDate>Fri, 28 Sep 2018 10:18:42 +0000</pubDate>
      
      <guid>/post/plans/</guid>
      <description>Recently, I want to do some hardware acceleration applcations like using zynq to mining. This will help me more skillful in software and hardware combinational developments. This type of use case may be used in lot of scenes. Such hardware like DSP, VPU, GPU, neural stick and many fpga cores outside of CPU.
I have to spend some time to read《FPGA based hardware accelerator for Dash mining》this thesis. Let&amp;rsquo;s go&amp;hellip;</description>
    </item>
    
    <item>
      <title>使用 qemu 调试 linux kernel</title>
      <link>/post/%E4%BD%BF%E7%94%A8-qemu-%E8%B0%83%E8%AF%95-linux-kernel/</link>
      <pubDate>Tue, 04 Sep 2018 11:06:50 +0000</pubDate>
      
      <guid>/post/%E4%BD%BF%E7%94%A8-qemu-%E8%B0%83%E8%AF%95-linux-kernel/</guid>
      <description>在 Ubuntu 中build kernel 参考如下：
 [Ref] https://wiki.ubuntu.com/KernelTeam/GitKernelBuild   可以直接在宿主机调试kernel, 但是当发生崩溃之后，工作环境又要重新配置。
 所以考虑用 qemu，因为它有个option: -kernel， 可以直接引导kernel。比 VirtualBox 等虚拟机更快速更方便。
   尝试使用 qemu 直接启动主机上的kernel   $ sudo qemu-system-x86\_64 -kernel /boot/vmlinuz-\`uname -r\`  这会提示缺少文件系统
 可以使用 debootstrap 构建一个rootfs ``` IMG=qemu-image.img DIR=mount-point.dir qemu-img create $IMG 1g mkfs.ext2 $IMG mkdir $DIR sudo mount -o loop $IMG $DIR sudo debootstrap &amp;ndash;arch amd64 jessie $DIR sudo umount $DIR rmdir $DIR   这里最好用一下 chroot 和 passwd 更新一下文件系统里的密码，以免启动之后登不进去。</description>
    </item>
    
    <item>
      <title>git 中心服务搭建</title>
      <link>/post/git-%E4%B8%AD%E5%BF%83%E6%9C%8D%E5%8A%A1%E6%90%AD%E5%BB%BA/</link>
      <pubDate>Wed, 22 Aug 2018 12:47:34 +0000</pubDate>
      
      <guid>/post/git-%E4%B8%AD%E5%BF%83%E6%9C%8D%E5%8A%A1%E6%90%AD%E5%BB%BA/</guid>
      <description>中心服务方式选择 git 本身是一个分布式的版本管理系统，但如果要设置一个中心库方便很多开发者同步，或者像SVN 一样使用它，就需要搭建一个中心库。有几种方式可以选择：
  gitosis ：
这个是比较老的方式。不推荐
详情参考： https://git-scm.com/book/en/v1/Git-on-the-Server-Gitosis
  GitLab: git 结合web 服务来管理，方便issue 和权限管理。比较推荐。收费版还可提供更多功能。参考：https://about.gitlab.com/install/
  只用ssh git 用户管理
开一个git 用户，设定好权限，也比较方便。但是缺少管理issue 功能。
参考：https://git-scm.com/book/en/v2/Git-on-the-Server-Setting-Up-the-Server
  ssh git用户设置   ssh key证书生成  $ ssh-keygen –t rsa –C “user@host” 将id_rsa.pub 发给git服务器管理员添加进/home/git/.ssh/authorized_keys 即可，或者直接用 ssh-copy-id 到服务器即可。
$ git clone git@IP:/srv/git/test.git有几个注意点：
 使用 ssh key 登陆 git 用户时，home目录只能是git 可写的，否则当git组包含多个用户时会出现不用能ssh key 登录的问题。具体debug ssh key 登录问题，可以查看 /var/log/auth 下的日志来解决。.ssh/ 的权限是700，.ssh/authorized_keys 权限是600。 最后用chsh 修改 git用户shell 为 git-shell，不让git 用户有其它多余的权限。 创建仓库可以用git 组的其它用户来创建。注意使用newgrp 将创建文件夹时用户的默认组改成git, 这样整个git 组的用户都有读写权限。  一些实用的git 命令记录 git checkout --patch BRANCH FILE git checkout --theirs PATH/FILEgit clean -n //演习git ls-filesgit ls-files | xargs -n 1 dirname | uniqgit diff master sync --name-onlygit config --global core.</description>
    </item>
    
    <item>
      <title>YUV 图像格式</title>
      <link>/post/yuv-%E5%9B%BE%E5%83%8F%E6%A0%BC%E5%BC%8F/</link>
      <pubDate>Wed, 22 Aug 2018 12:05:34 +0000</pubDate>
      
      <guid>/post/yuv-%E5%9B%BE%E5%83%8F%E6%A0%BC%E5%BC%8F/</guid>
      <description>Y：亮度分量 UV：色度分量
Y与RGB的演算关系为：Y = 0.2126 R + 0.7152 G + 0.0722 B
YUV4:2:2或4：2：0都是指的Y分量和UV分量在一个像素点中占有的平均比例。
YUV422:水平方向上的UV分量减半了
YUV420:水平垂直方向都会减半
YUV 4:4:4采样，每一个Y对应一组UV分量。 eg： YUVYUV
YUV 4:2:2采样，每两个Y共用一组UV分量。 eg： YUYVYUYV
YUV 4:2:0采样，每四个Y共用一组UV分量。 eg: YUYVYUYV YYYY
  以黑点表示采样该像素点的Y分量，以空心圆圈表示采用该像素点的UV分量。</description>
    </item>
    
    <item>
      <title>嵌入式linux 开发中常用工具安装笔记</title>
      <link>/post/%E5%B5%8C%E5%85%A5%E5%BC%8Flinux-%E5%BC%80%E5%8F%91%E4%B8%AD%E5%B8%B8%E7%94%A8%E5%B7%A5%E5%85%B7%E5%AE%89%E8%A3%85%E7%AC%94%E8%AE%B0/</link>
      <pubDate>Wed, 22 Aug 2018 11:25:05 +0000</pubDate>
      
      <guid>/post/%E5%B5%8C%E5%85%A5%E5%BC%8Flinux-%E5%BC%80%E5%8F%91%E4%B8%AD%E5%B8%B8%E7%94%A8%E5%B7%A5%E5%85%B7%E5%AE%89%E8%A3%85%E7%AC%94%E8%AE%B0/</guid>
      <description>Samba server    \# apt install samba samba-common# vim /etc/samba/smb.conf 添加：security = user\[shuji\]comment = share dirpath = /srv/sambabrowseable = yeswritable = yes# useradd public (不要用adduser, 否则还要禁用shell）# smbpasswd –a public # service smbd restart  Samba client   smbclient -L //192.168.1.10 -U devsmbclient //192.168.1.10 -U dev    nfs   \# vim /etc/exports/srv/nfs *(rw,sync,nosubtree_check)</description>
    </item>
    
    <item>
      <title>petalinux use guide summarize</title>
      <link>/post/petalinux-use-guide-summarize/</link>
      <pubDate>Wed, 22 Aug 2018 03:12:29 +0000</pubDate>
      
      <guid>/post/petalinux-use-guide-summarize/</guid>
      <description>petalinux 是针对 Xilinx FPGA-based SOC designs 的 embedded linux system development kit 。 包含了:
 Yocto Extensible SDK Minimal downloads XSCT and tool chains PetaLinux CLI tools  详情参考 PetaLinux Tools Reference Guide。
 **版本： v2018.2 June 6, 2018 **
不支持 ubuntu1804, 手贱装了ubuntu1804, 结果 build 的时候出现 Bitbake 运行不起来，google 一遍发现这版本petalinux 还是暂时不支持 ubuntu1804 ，遂重新装回1604. 总结：
   petalinux 安装, 略。 BSP 安装  BSP 是petalinux 的一个参考开发板的基础配置。可以把它作为一个模板创建自己的工程。它提供 了一个 installable BSP files，包含了所有必要的 design 和 configuration files ，pre-built 和 tested hardwrae 和 software images.</description>
    </item>
    
    <item>
      <title>recent new tech need to analysis and learn</title>
      <link>/post/recent-new-tech-need-to-analysis-and-learn/</link>
      <pubDate>Fri, 01 Jun 2018 02:44:51 +0000</pubDate>
      
      <guid>/post/recent-new-tech-need-to-analysis-and-learn/</guid>
      <description>reverse ssh tunnel nohup ssh -NfR 2222:localhost:22 root@106.12.13.xxx -p22 expect script strip command Some useful line editing key bindings provided by the Readline library:
 Ctrl-A: go to the beginning of line Ctrl-E: go to the end of line Alt-B: skip one word backward Alt-F: skip one word forward Ctrl-U: delete to the beginning of line Ctrl-K: delete to the end of line Alt-D: delete to the end of word  https://askubuntu.</description>
    </item>
    
    <item>
      <title>c/c&#43;&#43;编译相关技巧总结帖</title>
      <link>/post/cc&#43;&#43;%E7%BC%96%E8%AF%91%E7%9B%B8%E5%85%B3%E6%8A%80%E5%B7%A7%E6%80%BB%E7%BB%93%E5%B8%96/</link>
      <pubDate>Wed, 04 Apr 2018 07:35:04 +0000</pubDate>
      
      <guid>/post/cc&#43;&#43;%E7%BC%96%E8%AF%91%E7%9B%B8%E5%85%B3%E6%8A%80%E5%B7%A7%E6%80%BB%E7%BB%93%E5%B8%96/</guid>
      <description>链接时忽略文件中未用到的函数或者对象。这在移植代码过程中很有用, 我们就不需要去删除或者注释掉那些大量没用到的对象或者不需要去链接的对象。  For GCC, this is accomplished in two stages: First compile the data but tell the compiler to separate the code into separate sections within the translation unit. This will be done for functions, classes, and external variables by using the following two compiler flags:-fdata-sections -ffunction-sectionsLink the translation units together using the linker optimization flag (this causes the linker to discard unreferenced sections):-Wl,--gc-sectionsSo if you had one file called test.</description>
    </item>
    
    <item>
      <title>网站迁移笔记</title>
      <link>/post/%E7%BD%91%E7%AB%99%E8%BF%81%E7%A7%BB%E7%AC%94%E8%AE%B0/</link>
      <pubDate>Fri, 02 Feb 2018 12:27:24 +0000</pubDate>
      
      <guid>/post/%E7%BD%91%E7%AB%99%E8%BF%81%E7%A7%BB%E7%AC%94%E8%AE%B0/</guid>
      <description>迁移参考：
 https://www.digitalocean.com/community/tutorials/how-to-move-an-apache-web-root-to-a-new-location-on-ubuntu-16-04    Ubuntu1604 安装php5.6
 由于Ubuntu1604 默认安装的是php7。由于网站兼容性问题，需要装php5。 步骤参考：https://phpraxis.wordpress.com/2016/05/16/install-php-5-6-or-5-5-in-ubuntu-16-04-lts-xenial-xerus/ &amp;gt; add-apt-repository ppa:ondrej/php &amp;gt; apt-get update &amp;gt; apt-get install php5.6 php5.6-mbstring php5.6-mysql php5.6-sqlite3 &amp;gt; 还有这些按需要装 php5.6-cli php5.6-curl php5.6-json php5.6-mcrypt php5.6-curl php-xdebug libapache2-mod-php5.6 libapache2-mod-php7.0 mysql-server-5.7 apache2 # php 版本切换方法2 &amp;gt; sudo a2dismod php7.0 ; sudo a2enmod php5.6 ; sudo service apache2 restart ; echo 1 | sudo update-alternatives &amp;ndash;config php &amp;gt; sudo a2dismod php5.6 ; sudo a2enmod php7.</description>
    </item>
    
    <item>
      <title>linux bash shell 像cmd.exe 一样的滚动补齐功能</title>
      <link>/post/linux-bash-shell-%E5%83%8Fcmd.exe-%E4%B8%80%E6%A0%B7%E7%9A%84%E6%BB%9A%E5%8A%A8%E8%A1%A5%E9%BD%90%E5%8A%9F%E8%83%BD/</link>
      <pubDate>Sun, 19 Nov 2017 14:40:14 +0000</pubDate>
      
      <guid>/post/linux-bash-shell-%E5%83%8Fcmd.exe-%E4%B8%80%E6%A0%B7%E7%9A%84%E6%BB%9A%E5%8A%A8%E8%A1%A5%E9%BD%90%E5%8A%9F%E8%83%BD/</guid>
      <description>有些情况下，比如我们遇到文件名含有一些字符不容易输入时就很着急了，这时候就需要让linux shell像windows cmd.exe 一样自动补全部的文件名，且可自动按顺序一个个滚动切换。方法如下： 在用户目录创建 ~/.inputrc (若不存在则自己创建) 文件里添加一行： [code]TAB: menu-complete[/code] 。 登出再登陆用户就可以了。 For more details see the READLINE section in man bash .</description>
    </item>
    
    <item>
      <title>gdb 简记</title>
      <link>/post/gdb-%E7%AE%80%E8%AE%B0/</link>
      <pubDate>Wed, 21 Dec 2016 09:41:23 +0000</pubDate>
      
      <guid>/post/gdb-%E7%AE%80%E8%AE%B0/</guid>
      <description>常用命令如下：（详情可以用 help 命令查看）
 r (run, restart) s (step into) n (next state, step over) finish (step out) q (quit) p (print anything you want) l (list) b (breakpoint) #设置断点： (gdb) b fileName.c:lineNumber 或者 (gdb) b function u (until) #运行到指定行 call #调用函数 set #设置变量 set args #设置main 的输入参数 bt (backtrace) #查看堆栈 x #examine memory, (gdb)/FMT ADDRESS info # show things, (gdb) info break d # delete somthing (gdb) delete break xx 或者 (gdb) clean lineNumber 如果print 的内容比较长导致后面的内容是&amp;hellip;，可以重新设置print长度的上限，或者无限制： set print element 0 如果要生成带调试信息的程序，在gcc时要加上-g参数。 target remote 192.</description>
    </item>
    
    <item>
      <title>关于Apache httpd 的SSI和cgi使用和思考</title>
      <link>/post/%E5%85%B3%E4%BA%8Eapache-httpd-%E7%9A%84ssi%E5%92%8Ccgi%E4%BD%BF%E7%94%A8%E5%92%8C%E6%80%9D%E8%80%83/</link>
      <pubDate>Wed, 14 Dec 2016 14:25:28 +0000</pubDate>
      
      <guid>/post/%E5%85%B3%E4%BA%8Eapache-httpd-%E7%9A%84ssi%E5%92%8Ccgi%E4%BD%BF%E7%94%A8%E5%92%8C%E6%80%9D%E8%80%83/</guid>
      <description>因为在单片机上的web服务是使用删减版的httpd服务器，只保留最原始的扩展功能，SSI和CGI。无法像pc上的服务器可以使用php,jsp之类的引擎。 SSI主要是为了往网页里面插入实时的变量，CGI主要是处理客户端发送来的请求。这样即使是最古老的浏览器也不会有什么兼容性问题。 但是这样的做法的结果是服务端的编程变繁琐了。作为单片机这种嵌入式web应用，应该尽可能工作量放在客户端来完成，减少服务端的复杂度。而且不需要太考虑兼容古老的浏览器，因为落后的东西就应该被淘汰。 早期的浏览器作为通用的客户端只拥有简单的功能，比如实现get和post等几个方法。大量的跳转和内容生成是在服务端运行的，就造成服务器的负载较大。自从javascript成为浏览器端标准的脚本语言后，各种网站的内容交互方式就变得更加自由了。我这里感受最深的就是使用客户端脚本把动态网页的生成工作放在浏览器端来做，数据由ajax 单独请求更新。嵌入式web经常需要显示一些实时的数据，把单独的数据请求放在后台实时更新，然后由脚本把它填写至网页。不像早期的技术使用SSI，服务端需要检索整个网页的SSI tag，然后查找变量，将数据实时更新至网页，然后发送整张网页。可以想服务端的压力有多大。其实这种思维模式就像网站程序和网站数据分开放一个道理。好处多多！ 因为用单片机的web服务器调试前端代码会比较繁琐，要转码要下载，频繁修改就不方便。所以直接在pc的web服务器上调试前端代码，并且使用SSI和CGI，模仿单片机C后台的动作，这里要有一些技巧。 在Apache httpd web服务器上使用SSI和cgi，可以参考服务器主页上的帮助文档 http://httpd.apache.org/docs/current/howto/ssi.html。这里简单做个记录。
 SSI 按照官方介绍把SSI功能打开。怎么设置httpd.conf就不多说。这里简单记录下其使用规则。 想设置某个SSI tag时，可以使用 [html] [/html] 在需要调用它的地方使用 [html] [/html] 就可以显示出 xxxx 了。 仅仅是这样使用，跟我们在使用最原始的SSI还是有点不一样。 为了方便调试，我们可以在页面上头加上 [html] [/html] 重定义这个未找到SSI时的提示语言，原本的提示语言很长，不方便调试。
 CGI有几个要点： 1. CGI开启后，默认设置ScriptAlias是只执行cgi-bin下的脚本。你可以将自己的web目录添加进去，因为实际请求的路径不一定是/cgi-bin。 2. 这里可以用perl、python或者bash脚本来模仿单片机c的后端应答动作。这样调试好前端代码后，下进单片机后再慢慢调试后端代码就方便了。注意在perl前面要设置好perl.exe的路径。同时可以修改.pl后缀为我们想要的.cgi它也可以得到执行。完美模仿单片机后端逻辑！ Get!</description>
    </item>
    
    <item>
      <title>总结几个C 语言比较高级的编写技巧</title>
      <link>/post/%E6%80%BB%E7%BB%93%E5%87%A0%E4%B8%AAc-%E8%AF%AD%E8%A8%80%E6%AF%94%E8%BE%83%E9%AB%98%E7%BA%A7%E7%9A%84%E7%BC%96%E5%86%99%E6%8A%80%E5%B7%A7/</link>
      <pubDate>Fri, 25 Nov 2016 08:51:40 +0000</pubDate>
      
      <guid>/post/%E6%80%BB%E7%BB%93%E5%87%A0%E4%B8%AAc-%E8%AF%AD%E8%A8%80%E6%AF%94%E8%BE%83%E9%AB%98%E7%BA%A7%E7%9A%84%E7%BC%96%E5%86%99%E6%8A%80%E5%B7%A7/</guid>
      <description>看了一些源代码，这里总结几个不常见的，但是比较好用的C 用法。也许这些功能在C++中有扩展，但是个人基本不用C++。其实这些应该是属于预处理器的功能。若是之前没有见过，遇到时会感觉云里雾里的。
  直接定义字符串：  我们可以用#define 定义字符串常量，比如： #define HELLO &amp;ldquo;hello&amp;rdquo; 这样就相当于是： char *HELLO= &amp;ldquo;hello&amp;rdquo;; 而且使用#define 来定义的好处是可以直接拼接字符串，这些应该都是由预处理器来帮我们处理的（没有仔细考证，但想像其中原理应该是这样）。比如：``` #define HELLO &amp;ldquo;hello&amp;rdquo; #define WORLD &amp;ldquo;world&amp;rdquo;
puts( HELLO WORLD );
* * ** **定义内存池：**在嵌入式系统中一般不用内存堆的动态分配，因为容易产生内存碎片导致大块内存分配不到（可以用带小块内存合并功能内存管理方式），或者是会因为某个模块把内存堆耗尽了导致其它模块不能工作。通常会使用内存池的方式，而且每个软件模块有自己的不同大小固定数量内存池，这样可以做到每个模块内存互不干扰。说白一点就是一系列的分配好空间的数组。这可以参考lwip中内存池的分配。 #define LWIP\_MEMPOOL(name,num,size,desc) u8\_t memp\_memory\_ ## name ## \_base \[((num) \* (MEMP\_SIZE + MEMP\_ALIGN\_SIZE(size)))\];</description>
    </item>
    
    <item>
      <title>Http Authorization</title>
      <link>/post/basic-authorization/</link>
      <pubDate>Wed, 23 Nov 2016 09:24:20 +0000</pubDate>
      
      <guid>/post/basic-authorization/</guid>
      <description>Basic Authorization 从最初的基本的授权方式说起。 http头里添加：WWW-Authenticate: Basic realm=&amp;quot;xxx&amp;rdquo; 即可要求浏览器输入授权信息。 浏览器发送时会附带授权信息：Authorization:Basic YWRtaW46YWRtaW4= 它是由base64加密的。如上解密后为：admin:admin Basic authorization 的授权方式就是每个请求中在http头里都携带着base64加密的授权信息，服务器在每次收到请求时都要进行权限判断，再执行对应的操作。 由于考虑到授权，那自然涉及到了客户端状态。http /0.9是无状态无连接的协议，一个特定的输入就对应一个特定的输出。由于http 不需要很强的实时性，属于一问一答的对话形式，且有时并发性强，不可能是一对一的专人(线程)负责一个会话。所以如果涉及到状态就不如把状态参数放置在请求中，服务端就要先对请求中携带的状态进行判断，再判断对应的操作是否有权限等等。按数字电路的理论，服务端的业务就变成两段式状态机的组合逻辑部分。状态部分可以保存在客户端或者服务端，这就变成了cookie和session了。 http /1.0增加了keep-alive 选项，http /1.1则默认了所有连接都有keep-alive选项。http keep-alive 选项就是说 发送完响应之后不服务端不主动关闭连接(http /0.9 是会主动关闭连接的)。http 的keep-alive 应该通过是tcp的keep-alive 定时心跳来维持的，不过http的keep-alive 还有一层意思是即使tcp 连接断开了，http的session还是keep alive的，http 可能也维护着一个保活定时器去试探每个连接上的客户端是否仍在线(这个不清楚)。 当http涉及到用户的概念时，就需要识别用户了，可能最早http识别一个客户端的方法跟标识一个tcp连接的方法是一样的，即IP+Port的形式来断定。然后变成 client 的（IP+Port+uid+password)的，也就是Basic Authorization的方式。状态信息可以放在url(GET)，http header(authorizatin, cookie) 或者 post content里面。 对安全性的考虑： 由于每次都携带用户名和密码的这种请求方式极不安全，所以衍生版本就是用cookie来替代每次都携带的用户名和密码，这样就算cookie被人获取利用，也不会泄漏用户名和密码。只有在登陆的时候会传输一次用户名和密码。再者base64是可逆的加密方式，后面也使用不可逆的加密方式如md5（因为它是有损的加密，不可能还原出原密是什么）。但是如果被抓包，还是会被黑客冒名向服务器发出请求。所以早期网上支付等等就需要k宝，动态口令卡之类的东西。现在由于TLS/SSL等技术的出现，http on TLS/SSL 就很安全了。传输层或者socket层之上的信息全部使用密钥加双方证书加密，再靠抓包破解就很难了，所以这几年网络支付又火了起来。 PS: 看了一个wordpress登录的时候是直接POST 明文用户名加密码，好危险。 FAQ: Chrome delete authorization information 在使用 header(&amp;lsquo;WWW-Authenticate: Basic realm=&amp;quot;userlogin&amp;rdquo;&#39;); 调试用户登录授权时，浏览器总是会保存之前输入的授权信息。想输入其它用户测试都不行。 所以有两个方法： 1. 使用隐私窗口调试。 2. 在url之前增加 &amp;ldquo;admin@&amp;rdquo; 就可以输入新的授权信息了。 php 的header函数，和html 中的标签效果的区别 两个都用来产生response header的，不同的是前者应该直接由服务端在http header里的添加值对。后者只是将值对放在html中传送，由浏览器来解析。这可以在浏览器中调试发现它们的区别。 Session and Cookie Session 是服务端维护的会话信息, cookie是用于标识客户对象和携带客户状态参数的变量。最初由客户端发送，服务端即认识了这个访问对象（可能还要加上ip+port信息），每次客户端有相应的操作之后，服务端即会把一些状态参数加入cookie中返回给客户端。这样服务端就不需保存用户操作状态了。session 保存着这次会话的信息，超时无操作之后就会结束这次会话。 以上纯属个人理解，因为目前在应用层的使用经验比较少，只是在嵌入式开发中涉及到一些初级的简单的应用层开发。属于http的一些最初的实现，只求简单可靠，服务端处理只有C语言。不过也有必要了解一下所谓“未来”的解决方案。有高级的框架的比如 jQuery.</description>
    </item>
    
    <item>
      <title>ss安装笔记</title>
      <link>/post/ss%E5%AE%89%E8%A3%85%E7%AC%94%E8%AE%B0/</link>
      <pubDate>Fri, 04 Nov 2016 09:54:02 +0000</pubDate>
      
      <guid>/post/ss%E5%AE%89%E8%A3%85%E7%AC%94%E8%AE%B0/</guid>
      <description>现在的上网安全性越来越差了，感觉随时有人在监视你上网。电信送的政企网关更是漏洞百出，dns经常被劫持，而且电信留有后门，非常不安全。再加上之前出现的同事邮件被监视，诈骗邮件、短信等等的问题，公司的网络真的是问题很大。 之前部署的openvpn服务在手机端用，似乎dns有问题不能用，不用dns的服务则可正常使用。而PC端使用OpenVPN无任何问题。所以打算在国内的服务器上也部署一个SS来上网。 pip安装方式简单记录下： [bash] #apt-get intsall python-pip #pip install shadowsocks #vim /etc/shadowsocks.json 如下 { &amp;ldquo;server&amp;rdquo;:&amp;ldquo;my_server_ip&amp;rdquo;, &amp;ldquo;server_port&amp;rdquo;:8388, &amp;ldquo;local_address&amp;rdquo;: &amp;ldquo;127.0.0.1&amp;rdquo;, &amp;ldquo;local_port&amp;rdquo;:1080, &amp;ldquo;password&amp;rdquo;:&amp;ldquo;mypassword&amp;rdquo;, &amp;ldquo;timeout&amp;rdquo;:300, &amp;ldquo;method&amp;rdquo;:&amp;ldquo;aes-256-cfb&amp;rdquo;, &amp;ldquo;fast_open&amp;rdquo;: false } #ssserver -c /etc/shadowsocks.json -d start 若要开机启动则将本条添加到 /etc/rc.local 里 [/bash] 由于在 pip install 的时候出了问题，估计是国内访问pypi资源很慢，安装失败。于是就打算使用源码安装方式。 1. 用scp 拷贝源码到服务器。 2. [bash] #python setup.py build #python setup.py install #等待安装完成，之后就跟上面的一样配置就可以了。 [/bash] 要赶紧把ss的源码好好学学，不然哪天翻不出去也要会自力更生，嘿嘿。 特别 github 还有python大牛源码解析的版本和其它衍生版本可以下哦！这里不贴出来，以免被封。 tips: 对于长城宽带，ss代理若使用常用的443端口经常遇到出不去的情况，可以用telnet 通一下443端口，然后就神奇的可以出去了。这也是无意中发现的，长宽真是个神奇的存在！电信就很少遇到这个问题，不过有极少情况可能是因为找不到路由，可以tracert 一下服务器应该就能出去了。</description>
    </item>
    
    <item>
      <title>ubuntu 上部署OpenVPN服务</title>
      <link>/post/ubuntu-%E4%B8%8A%E9%83%A8%E7%BD%B2openvpn%E6%9C%8D%E5%8A%A1/</link>
      <pubDate>Fri, 19 Aug 2016 15:28:48 +0000</pubDate>
      
      <guid>/post/ubuntu-%E4%B8%8A%E9%83%A8%E7%BD%B2openvpn%E6%9C%8D%E5%8A%A1/</guid>
      <description>缘起： 最近家里的长城宽带通往海外的线路堵得厉害(感觉长城宽带就是GFW的实验场)，用ss翻墙都难连上服务器，apple store也难连上。于是不得不在国内阿里云的服务器上搭一个VPN。不仅可以解决长城宽带的问题，平时手机在外面连接不安全的wifi时也不用担心信息会泄漏了。另外VPN还可以将分布在各处的内网主机组成局域网，VPN服务就相当于是在中间的虚拟路由器。 参考了以上几个链接的博客总结一下安装过程。 http://www.linuxidc.com/Linux/2014-08/105925p2.htm http://www.linuxidc.com/Linux/2012-01/51702.htm https://help.ubuntu.com/lts/serverguide/openvpn.html http://blog.csdn.net/joyous/article/details/8034132 OpenVPN 是在TCP/UDP 端口上建立一个安全IP网络通道，支持SSL/TLS 对数据加密、授权等。简单点理解就是在传输层上建立一个虚拟线路，作IP包的交换，相当于一个虚拟网卡。原文是这么说的： * OpenVPN &amp;ndash; An application to securely tunnel IP networks * over a single TCP/UDP port, with support for SSL/TLS-based * session authentication and key exchange, * packet encryption, packet authentication, and * packet compression. 一、安装OpenVPN [bash] ~$ apt-get install openvpn dnsmasq [/bash] dnsmasq 在用来在vpn路由器功能里面充当域名服务器的作用。有的版本openvpn包含了 easy-rsa ，不用再安装easy-rsa。如果没有再自行安装easy-rsa，它包含生成密钥用的脚本文件。 注：更新本地仓库：apt-get update 安装完查看openvpn相关安装包位置的命令： [bash] ~$ dpkg -L openvpn |more [/bash] 找到 easy-rsa 所在的文件夹，把它拷到/etc/openvpn/底下。如果没有就另行安装 easy-rsa。 [bash] ~$ cp -r /usr/share/doc/openvpn/examples/easy-rsa/2.</description>
    </item>
    
    <item>
      <title>Lwip 内存管理</title>
      <link>/post/lwip-%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/</link>
      <pubDate>Wed, 17 Aug 2016 08:01:24 +0000</pubDate>
      
      <guid>/post/lwip-%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/</guid>
      <description>Lwip 用它自己的动态内存分配方式替代了标准C的malloc(); 它可以使用MEM_POOL的方式分配内存，即开辟几个不同尺寸的缓冲池，给数据分配合适的缓冲区来存放，就类似于使用数组的方式，可能会比较浪费空间，但是可以有效避免内存碎片产生, 这在第二部分讲。两种方式分别在mem.c memp.c里面实现，下面先总结一般的内存堆分配方式。 (一) 内存堆动态分配方式 [c] //mem.h /** Align a memory pointer to the alignment defined by MEM_ALIGNMENT * so that ADDR % MEM_ALIGNMENT == 0 */ #ifndef LWIP_MEM_ALIGN #define LWIP_MEM_ALIGN(addr) ((void *)(((mem_ptr_t)(addr) + MEM_ALIGNMENT - 1) &amp;amp; ~(mem_ptr_t)(MEM_ALIGNMENT-1))) #endif [/c] 首先是内存对齐，这里用到的MCU是按4字节对齐的。这一语句功能是将addr 调整成最靠近addr的且能被4整除的值，其实就是(addr+3)&amp;amp;(~(u32)(0x03))，+3之后有余数的自然就进位了然后再舍掉余数。其实也可以用 addr = (addr&amp;amp;0x03)?(addr+1):addr; 这样应该也可以，更容易理解一些，但是没有上面的简便。 [c] #ifndef LWIP_RAM_HEAP_POINTER /** the heap. we need one struct mem at the end and some room for alignment */ u8_t ram_heap[MEM_SIZE_ALIGNED + (2*SIZEOF_STRUCT_MEM) + MEM_ALIGNMENT]; #define LWIP_RAM_HEAP_POINTER ram_heap #endif /* LWIP_RAM_HEAP_POINTER */ &amp;hellip; /** * The heap is made up as a list of structs of this type.</description>
    </item>
    
    <item>
      <title>IAR sprintf() 输出不正常的问题</title>
      <link>/post/iar-sprintf-%E8%BE%93%E5%87%BA%E4%B8%8D%E6%AD%A3%E5%B8%B8%E7%9A%84%E9%97%AE%E9%A2%98/</link>
      <pubDate>Mon, 15 Aug 2016 00:57:44 +0000</pubDate>
      
      <guid>/post/iar-sprintf-%E8%BE%93%E5%87%BA%E4%B8%8D%E6%AD%A3%E5%B8%B8%E7%9A%84%E9%97%AE%E9%A2%98/</guid>
      <description>前几天调试了一程序，用到sprintf函数，输出结果一直不正常，同样的输出格式用printf打印则没有问题。然后同样的程序在gcc下sprintf也是正常的。怀疑IAR的sprintf函数有问题。后来发现原因是IAR把sprintf函数简化了，在project-options-general options 里面的Library options 的Tabs里有个printf formatter，默认是选成tiny的选项，结果就不支持一些复杂的输出格式。把它设置成auto，输出结果就正常了，o yeah!</description>
    </item>
    
    <item>
      <title>methods of handling multiple connections as lwip</title>
      <link>/post/methods-of-handling-multiple-connections-as-lwip/</link>
      <pubDate>Thu, 21 Jul 2016 09:37:59 +0000</pubDate>
      
      <guid>/post/methods-of-handling-multiple-connections-as-lwip/</guid>
      <description>这里分享一些一个服务handle多client连接的经验。 (1) 多线程/进程方法 每accept并创建一个新连接之后，就create一个task来处理这个连接的事务。linux使用fork()来创建分支线程。freertos 不支持fork方法，只能创建新的线程来管理连接。此方法内存开销较大。 (2) non-blocking socket 和 select 此方法由单线程处理并发事务，即最原始的轮询方式。在系统不支持fork()的情况下经常用到。首先，accpet/recv函数都必须的non-blocking的，需立即返回，否则其它任务就得不到轮询。这种模式在跑单片机裸机程序时经常是这样的，另外在labview里面也经常是这样的轮询的方式。这个例程可以在lwip 1.4.1 contrib下app demo:chargen 里可以学习到。这种方式会占用很多cpu资源，这样的任务优先级要放低，并设置一定的轮询间隔(类比在labview里，while循环通常会插入一个等待时间)。否则 freertos 中低优先级任务就得不到运行，同优先级的任务也只能分时间片轮流运行。 这里简单总结下 select方法。 协议栈内核在每次有accept 或 recv事件到达后都会调用 event_callback(); 增加一个事件记录。在上层接收后都会减掉一个记录。select 函数通过查询socket的对应event来置位fd_set对应的比特位。本质就类似查询一个计数信号量。 (3) 使用 raw api， 基于事件触发(基于回调)方式。 此方式适合编写只进行简单处理的应用，每次接收到包就会调用相应的回调函数。多连接是由协议栈的active_pcb_lists直接管理，每个连接都创建属于自己的state argument。如果需要运算量比较大占用时间较长的服务则不适合此方式，会影响的协议栈对其它服务的响应速度。 后记，从事务的角度来看，一个tcp连接代表一个session，一句udp 请求也代表一个session。一个session从接收到返回就是一条事务线。若不能一气呵成，则就必须用一条线程去管理它，或者说维护一个工作现场，等待它的后台任务完成再回来应答这个事务。一条线程就对应一个事务现场，多任务操作系统就是在不同的工作现场的中交替工作，模拟多个人工作的情况，每一个工作现场都保存的对应工作事务的进展情况和所有需要用到的工具。 或者还有一种做法，就是一件事做完一部分后丢给后台，让它处理完之后调用我给它的办法帮我把剩下的事处理完，节省了任务之间信息传递和任务切换带来的开销。 其实一个session对应一个任务确实有点浪费，我想一般handle几百上千万个连接的服务应该不会这样做的，每个连接只需将它当前的状态变量连同数据包传给每个部门来做就可以了，毕竟每个连接的状态的数据量不是很多，没必要开辟一个专门的任务去Handle.</description>
    </item>
    
    <item>
      <title>Lwip Netconn</title>
      <link>/post/lwip-netconn/</link>
      <pubDate>Tue, 12 Jul 2016 11:19:36 +0000</pubDate>
      
      <guid>/post/lwip-netconn/</guid>
      <description>从Lwip Netconn接口的代码中，我们可以学到与Lwip 协议栈规范的交互方式和这种接口的封装方法。 这里总结出一个看代码的技巧，第一步先是只看正常处理的流程，忽略异常处理的部分，这样代码就可以非常简洁，可以很快把代码流程搞清楚，第二步再看重要的异常情况的处理过程。 连接的建立过程前面已经简单总结过，这里就只说我们比较关心的recv_xxx()过程。 recv_xxx() 函数是在accept_func里注册的,并且pcb-&amp;gt;callback_arg = new_netconn。 其回调原型： [c] #define TCP_EVENT_RECV(pcb,p,err,ret) \ do { \ if((pcb)-&amp;gt;recv != NULL) { \ (ret) = (pcb)-&amp;gt;recv((pcb)-&amp;gt;callback_arg,(pcb),(p),(err));\ } else { \ &amp;hellip; \ } \ } while (0) [/c] 函数原型： recv_tcp(void *arg, struct tcp_pcb *pcb, struct pbuf *p, err_t err) { struct netconn *conn; u16_t len; conn = (struct netconn *)arg; if (sys_mbox_trypost(&amp;amp;conn-&amp;gt;recvmbox, p) != ERR_OK) { &amp;hellip; } 这里从tcpip_thread抛出的是pbuf。 netconn 接收部分如下： [c] netconn_recv_data(struct netconn *conn, void **new_buf) { void *buf = NULL; if (sys_arch_mbox_fetch(&amp;amp;conn-&amp;gt;recvmbox, &amp;amp;buf, conn-&amp;gt;recv_timeout) == SYS_ARCH_TIMEOUT) &amp;hellip; } [/c] 这里buf 是void 类型的指针，因为上头可能会用pbuf类型或者netbuf类型来接收邮箱里的pbuf。 netbuf的封装方式：</description>
    </item>
    
    <item>
      <title>Lwip 里的信号量、邮箱、线程</title>
      <link>/post/lwip-%E9%87%8C%E7%9A%84%E4%BF%A1%E5%8F%B7%E9%87%8F%E9%82%AE%E7%AE%B1%E7%BA%BF%E7%A8%8B/</link>
      <pubDate>Tue, 12 Jul 2016 01:42:53 +0000</pubDate>
      
      <guid>/post/lwip-%E9%87%8C%E7%9A%84%E4%BF%A1%E5%8F%B7%E9%87%8F%E9%82%AE%E7%AE%B1%E7%BA%BF%E7%A8%8B/</guid>
      <description>这里简单分析总结一下Lwip sys_arch.c 中的信号量、邮箱、进程相关的内容。系统用的是FreeRTOS。 [c] &amp;ldquo;sys_arch.c&amp;rdquo; /* An array to hold the memory for the available semaphores. */ static sem_t sems[SYS_SEM_MAX]; /* An array to hold the memory for the available mailboxes. */ static mbox_t mboxes[SYS_MBOX_MAX]; &amp;ldquo;sys_arch.h&amp;rdquo; ///* A structure to hold the variables for a sys_sem_t. */ typedef struct { xQueueHandle queue; signed char buffer[sizeof(void *) + portQUEUE_OVERHEAD_BYTES]; } sem_t; /* A structure to hold the variables for a sys_mbox_t. */ typedef struct { xQueueHandle queue; signed char buffer[(sizeof(void *) * MBOX_MAX) + portQUEUE_OVERHEAD_BYTES]; } mbox_t; [/c] 这里创建了两个全局结构体数组来管理semaphores and mailboxes.</description>
    </item>
    
    <item>
      <title>LwIP TCP Layer Simple analysis</title>
      <link>/post/some-notes-about-lwip/</link>
      <pubDate>Wed, 06 Jul 2016 10:07:02 +0000</pubDate>
      
      <guid>/post/some-notes-about-lwip/</guid>
      <description>LwIP Version : 1.4.1; 这里分享一些阅读LwIP协议栈的心得。 有个经验: 源代码才是最权威的资料。 若想用raw api编程，可以参考httpd_raw的代码。若涉及进程间通讯，请参考netconn接口，避免在其它进程内调用非Thead-Safe的函数。 下面说说对一些函数及过程的认识。 (1) xxx_accept(void *arg, struct tcp_pcb *pcb, err_t err); 这个函数的参数注意点: 回调原型：pcb-&amp;gt;accept(pcb-&amp;gt;callback_arg, pcb, err); @*arg: 这里协议栈传递过来的是lpcb，即监听pcb，不要认为和第二个参数相同。因为在tcp_listen_input()里，当有新连接请求到达时会新建一个npcb并将其加入到tcp_active_list里，在初始化npcb时，继承的是lpcb的callback_arg, 而这个callback_arg在新建监听链接时将其赋为lpcb。 @*pcb: 这里是传递进新创建的pcb。在创建APP过程中，需给其分配新的argument, 指定xxx_recv(),xxx_err(), xxx_poll(), xxx_sent()等函数。 (2) struct tcp_pcb *tcp_listen( struct tcp_pcb *pcb); 这里传入了一个original pcb，返回一个lpcb，因为listening状态的pcb 只需包含更少的信息。函数内新分配了一个 lpcb, 拷贝必要信息后，将original pcb释放。 对于SO_REUSE选项，在此函数内对比已经在监听List 中的pcb, 允许本地端口号相同，但本地IP号不同的连接可再次监听。 (3) 服务端口监听过程分析 TCP_LISTEN_BACKLOG 选项 此选项使能 TCP 对监听列表允许监听的数量控制。在tcp_listen_input()函数内， [c] &amp;hellip; else if (flags &amp;amp; TCP_SYN) { LWIP_DEBUGF(TCP_DEBUG, (&amp;ldquo;TCP connection request %&amp;ldquo;U16_F&amp;rdquo; -&amp;gt; %&amp;ldquo;U16_F&amp;rdquo;.\n&amp;rdquo;, tcphdr-&amp;gt;src, tcphdr-&amp;gt;dest)); #if TCP_LISTEN_BACKLOG if (pcb-&amp;gt;accepts_pending &amp;gt;= pcb-&amp;gt;backlog) { LWIP_DEBUGF(TCP_DEBUG, (&amp;ldquo;tcp_listen_input: listen backlog exceeded for port %&amp;ldquo;U16_F&amp;rdquo;\n&amp;rdquo;, tcphdr-&amp;gt;dest)); return ERR_ABRT; } #endif /* TCP_LISTEN_BACKLOG */ npcb = tcp_alloc(pcb-&amp;gt;prio); &amp;hellip; #if TCP_LISTEN_BACKLOG pcb-&amp;gt;accepts_pending++; #endif &amp;hellip; [/c] 当收到SYN帧时，此处对比并限制已经pending 状态的数量，即未被上层accept的连接数量。接下来新建立一个npcb, 并加入active_pcbs 的list中。 tcp_process() 主要处理 active_pcbs 的状态机。经过三次握手协议之后就进入了ESTABLISHED状态。 这里着重分析下tcp_input(pbuf *p, netif *inp);函数。 函数传入的是一个pbuf和netif，传入的参数并无连接的概念，接着在这里就进入了tcp层。tcp层维护着几个list: [c] /** An array with all (non-temporary) PCB lists, mainly used for smaller code size */ struct tcp_pcb ** const tcp_pcb_lists[] = {&amp;amp;tcp_listen_pcbs.</description>
    </item>
    
    <item>
      <title>用ECS在云端搭建SVN服务</title>
      <link>/post/%E7%94%A8ecs%E5%9C%A8%E4%BA%91%E7%AB%AF%E6%90%AD%E5%BB%BAsvn%E6%9C%8D%E5%8A%A1/</link>
      <pubDate>Thu, 02 Jun 2016 08:08:41 +0000</pubDate>
      
      <guid>/post/%E7%94%A8ecs%E5%9C%A8%E4%BA%91%E7%AB%AF%E6%90%AD%E5%BB%BAsvn%E6%9C%8D%E5%8A%A1/</guid>
      <description>应用环境： ECS 云端系统：Ubuntu 14.04-x64 本地系统：window 使用工具：cygwin + ssh 原版文档： http://www.shayanderson.com/linux/install-and-setup-subversion-server-on-ubuntu-1210-server-with-multiple-repositories.htm 一、安装及目录配置 1. 登录云端服务器 ssh xxx@[IP] 2. 安装subversion apt-get install subversion 检查是否安装完成 svn --version 3. 先建立一个Repositories 目录放置工程 mkdir /home/repos 在目录底下再建立工程 svnadmin create /home/repos/project1 svnadmin create /home/repos/project2 注：删除则用 svnadmin deltify 4. 修改目录组权限让一用户组都可管理此目录 chmod -R g+rws /home/repos //设置组权限 sudo groupadd svn //添加组 chgrp -R svn /home/repos //修改group ownership usermod -a -G svn [username] //添加用户进组 groups // 检查用户是否被添加进组 二、云端上测试SVN服务 1. 新建一个文件夹 mkdir /home/tmp svn checkout file:///home/repos/project1 /home/tmp // checkout到目录tmp 2.</description>
    </item>
    
    <item>
      <title>阿里云ECS推荐码9折 : ceyo2p</title>
      <link>/post/%E9%98%BF%E9%87%8C%E4%BA%91ecs%E6%8E%A8%E8%8D%90%E7%A0%819%E6%8A%98-ceyo2p/</link>
      <pubDate>Wed, 01 Jun 2016 14:58:03 +0000</pubDate>
      
      <guid>/post/%E9%98%BF%E9%87%8C%E4%BA%91ecs%E6%8E%A8%E8%8D%90%E7%A0%819%E6%8A%98-ceyo2p/</guid>
      <description>阿里云ECS云服务器推荐码9折 : ceyo2p</description>
    </item>
    
    <item>
      <title>HTTP协议与HTTP表单传输格式</title>
      <link>/post/http%E5%8D%8F%E8%AE%AE%E4%B8%8Ehttp%E8%A1%A8%E5%8D%95%E4%BC%A0%E8%BE%93%E6%A0%BC%E5%BC%8F/</link>
      <pubDate>Wed, 13 Apr 2016 07:27:50 +0000</pubDate>
      
      <guid>/post/http%E5%8D%8F%E8%AE%AE%E4%B8%8Ehttp%E8%A1%A8%E5%8D%95%E4%BC%A0%E8%BE%93%E6%A0%BC%E5%BC%8F/</guid>
      <description>HTTP请求 从使用者的角度看，一个HTTP请求起始于 用户端浏览器上输入的一个URL地址； 网页中的一个超链接； 提交一个HTML表单。 但本质上说，一个HTTP请求起始于用户端向HTTP服务器发送的一个URL请求。 一个标准的HTTP请求由以下几个部分组成 [code] [] [/code] 在HTTP请求中，第一行是请求行（request-line），用来说明请求类型、要访问的资源（URL）以及使用的HTTP版本； 紧接着是多行头部（headers）信息，用来说明服务器要使用的附加信息； 头部信息之后是一个回车换行符（/r/n），用于标明头部信息的结束。 以上是必须内容，根据需要可在头部信息结束之后增加主体数据（request-body）； 主体数据之后是一个回车换行符（/r/n），用于标明主体数据的结束。 需要注意的是 请求行（request-line）中的URL部分必须以application/x-www-form-urlencoded方式编码。 主体数据（request-body）的编码方式由头部（headers）信息中的Content-Type指定。 主体数据（request-body）的长度由头部（headers）信息中的Content-Length指定。 例如，我们可以在IE浏览器上输入下面的网址： http://localhost:8000/hello/index.html HTTP请求的头部信息如下： [code] GET /hello/index.html HTTP/1.1 Accept: */* Accept-Language: zh-cn Accept-Encoding: gzip, deflate Host: localhost:8000 Connection: Keep-Alive Cookie: JSESSIONID=BBBA54D519F7A320A54211F0107F5EA6 [/code] 上述信息没有request-body部分，这是以GET方式发送的HTTP请求。如果请求中需要附加主体数据，即增加request-body部分，则必须使用POST方式发送HTTP请求。HTML超链接（）只能用GET方式提交HTTP请求，HTML表单(
)则可以使用两种方式提交HTTP请求。 HTML表单 HTML表单的使用方法如下： [html] &amp;hellip; VALUE VALUE &amp;hellip; [/html] 表单中存在各种类型的表单域标签，如 [html] 、及。 [/html] 每一种表单域标签均有NAME与VALUE两种标签属性。这两个标签属性决定了表单提交时传送的属性名及相应的值。 目标地址（URL） action标签属性指定了表单提交的目标地址，其值可以是完整的URL。如： [html] &amp;hellip; 如果放置表单的网页与表单提交的目标地址在同一个HTTP服务器上，则目标地址可以用绝对路径表示（绝对路径相对于HTTP服务器）。绝对路径以“/”开头，包括WEB应用上下文及请求。如： 如果放置表单的网页与表单提交的目标地址在同一个WEB应用上下文上，则目标地址可以用相对路径表示（相对路径相对于放置表单的网页）。相对路径不以“/”开头，不包括WEB应用上下文。如： 需要注意的是，action标签属性的值必须符合URL的要求，其编码必须符合application/x-www-form-urlencoded编码规则。如下面的表单： &amp;hellip; [/html] 这样的表单是不符合要求的。如果其URL值存在非法字符（如中文字符），应将其进行URL Encoding处理。URL Encoding的处理方法如下： 字母数字字符 &amp;ldquo;a&amp;rdquo; 到 &amp;ldquo;z&amp;rdquo;、&amp;ldquo;A&amp;rdquo; 到 &amp;ldquo;Z&amp;rdquo; 和 &amp;ldquo;0&amp;rdquo; 到 &amp;ldquo;9&amp;rdquo; 保持不变。 特殊字符 &amp;ldquo;.</description>
    </item>
    
    <item>
      <title>SSI Tag的使用</title>
      <link>/post/ssi-tag%E7%9A%84%E4%BD%BF%E7%94%A8/</link>
      <pubDate>Tue, 12 Apr 2016 03:00:09 +0000</pubDate>
      
      <guid>/post/ssi-tag%E7%9A%84%E4%BD%BF%E7%94%A8/</guid>
      <description>这里先说最原始的使用SSI tag的方式，因为这样做在C开发中最简单。跟后来通用的web服务器的SSI有点不一样，因为后来为了使上层开发更方便，又进行了一些封装。 最原始的SSI是这样规定的，如在html中嵌入SSI tag。使用 [code]&amp;lt;&amp;ndash;#tagname&amp;ndash;&amp;gt;[/code] ;，则当Web服务器生成网页时，会将当前的标签后插入所指定的内容。这就是SSI Tag的作用。 SSI可以说是最初动态生成网页的方法，不仅仅是用来插入一些变量也可以直接插入javascript、json等等你想要发送给客户端的内容！一般用SSI来插入静态变量比较方便，如果是插入input框的当前值的话，可以往SSI中插入一段javascript代码或者是json格式的数据，再用javascript把这些实时的值加载进input框。 [html] Name:IP Address:MAC Address:[/html] 其Tag 在Web 服务端代码中作如下定义,并定义其序号的宏。 [c] static const char *g_pcConfigSSITags[] = { &amp;ldquo;ipaddr&amp;rdquo;, // SSI_INDEX_IPADDR &amp;ldquo;macaddr&amp;rdquo;, // SSI_INDEX_MACADDR &amp;ldquo;p0br&amp;rdquo;, // SSI_INDEX_P0BR &amp;ldquo;p0sb&amp;rdquo;, // SSI_INDEX_P0SB &amp;ldquo;p0p&amp;rdquo;, // SSI_INDEX_P0P &amp;ldquo;p0bc&amp;rdquo;, // SSI_INDEX_P0BC &amp;ldquo;p0fc&amp;rdquo;, // SSI_INDEX_P0FC &amp;ldquo;p0tt&amp;rdquo;, // SSI_INDEX_P0TT &amp;ldquo;p0tlp&amp;rdquo;, // SSI_INDEX_P0TLP &amp;ldquo;p0trp&amp;rdquo;, // SSI_INDEX_P0TRP &amp;ldquo;p0tip&amp;rdquo;, // SSI_INDEX_P0TIP &amp;ldquo;p0tip1&amp;rdquo;, // SSI_INDEX_P0TIP1 &amp;ldquo;p0tip2&amp;rdquo;, // SSI_INDEX_P0TIP2 &amp;ldquo;p0tip3&amp;rdquo;, // SSI_INDEX_P0TIP3 &amp;ldquo;p0tip4&amp;rdquo;, // SSI_INDEX_P0TIP4 &amp;ldquo;p0tnm&amp;rdquo;, // SSI_INDEX_P0TNM &amp;ldquo;p1br&amp;rdquo;, // SSI_INDEX_P1BR &amp;ldquo;p1sb&amp;rdquo;, // SSI_INDEX_P1SB &amp;ldquo;p1p&amp;rdquo;, // SSI_INDEX_P1P &amp;ldquo;p1bc&amp;rdquo;, // SSI_INDEX_P1BC &amp;ldquo;p1fc&amp;rdquo;, // SSI_INDEX_P1FC &amp;ldquo;p1tt&amp;rdquo;, // SSI_INDEX_P1TT &amp;ldquo;p1tlp&amp;rdquo;, // SSI_INDEX_P1TLP &amp;ldquo;p1trp&amp;rdquo;, // SSI_INDEX_P1TRP &amp;ldquo;p1tip&amp;rdquo;, // SSI_INDEX_P1TIP &amp;ldquo;p1tip1&amp;rdquo;, // SSI_INDEX_P1TIP1 &amp;ldquo;p1tip2&amp;rdquo;, // SSI_INDEX_P1TIP2 &amp;ldquo;p1tip3&amp;rdquo;, // SSI_INDEX_P1TIP3 &amp;ldquo;p1tip4&amp;rdquo;, // SSI_INDEX_P1TIP4 &amp;ldquo;p1tnm&amp;rdquo;, // SSI_INDEX_P1TNM &amp;ldquo;modname&amp;rdquo;, // SSI_INDEX_MODNAME &amp;ldquo;pnpport&amp;rdquo;, // SSI_INDEX_PNPPORT &amp;ldquo;disable&amp;rdquo;, // SSI_INDEX_DISABLE &amp;hellip; }; [/c] 然后在SSIHandler里如下解析,当每次serving a page with a ``.</description>
    </item>
    
    <item>
      <title>make工具使用</title>
      <link>/post/make%E5%B7%A5%E5%85%B7%E4%BD%BF%E7%94%A8/</link>
      <pubDate>Mon, 28 Mar 2016 11:58:59 +0000</pubDate>
      
      <guid>/post/make%E5%B7%A5%E5%85%B7%E4%BD%BF%E7%94%A8/</guid>
      <description>Makefile 正如其名作为一个制作文件的工具，大大方便了进行大批量文件编译时的工作流程。这里简单的记录一个make 工具的基本使用规则。
1. Makefile 基本规则：  target... : prerequisites ...command......-------------------------------------------------------------------------------target: 为目标文件，即所要生成的对象;
prerequisites : 为要生成target所需要的文件或是目标;
command: 即make需要执行的命令，(任意的shell命令，即对应编译器或者平台的命令)。
第一行表示依赖关系，第二行是规则。( 第二行必须由Tab键开头 )。
注意：
a. 只敲入make命令默认执行第一个target。
b. command 要用Tab键缩进
2. 比如有源文件：main.c api.c api.h 用gcc 作编译的过程：
gcc -c main.c gcc -c api.c gcc -o main main.o api.o写成Makefile的话就是:
 main: main.o api.ogcc -o main main.o api.omain.o: main.cgcc -c main.capi.o: api.c api.hgcc -c api.c 另外Makefile简化格式：</description>
    </item>
    
    <item>
      <title>Ethernet、IP、TCP、UDP帧头格式、详解</title>
      <link>/post/ethernetiptcpudp%E5%B8%A7%E5%A4%B4%E6%A0%BC%E5%BC%8F%E8%AF%A6%E8%A7%A3/</link>
      <pubDate>Thu, 03 Mar 2016 01:57:48 +0000</pubDate>
      
      <guid>/post/ethernetiptcpudp%E5%B8%A7%E5%A4%B4%E6%A0%BC%E5%BC%8F%E8%AF%A6%E8%A7%A3/</guid>
      <description>引用：http://zoufengfu168.blog.163.com/blog/static/5461055200991333616451/ 一、MAC帧头定义 [c] typedef struct _MAC_FRAME_HEADER { char m_cDstMacAddress[6]; //目的mac地址 char m_cSrcMacAddress[6]; //源mac地址 /* 如0x0800代表上一层是IP协议，0x0806为arp, 0x88a4为Ethercat */ short m_cType; //上一层协议类型， }__attribute__((packed))MAC_FRAME_HEADER,*PMAC_FRAME_HEADER; Etherne II 长度为14 byte; typedef struct _MAC_FRAME_TAIL { unsigned int m_sCheckSum; //数据帧尾校验和 }__attribute__((packed))MAC_FRAME_TAIL, *PMAC_FRAME_TAIL; [/c] 补充VLAN 和ARP： [c] // #define ETHTYPE_ARP 0x0806U #define ETHTYPE_IP 0x0800U #define ETHTYPE_VLAN 0x8100U #define ETHTYPE_PPPOEDISC 0x8863U /* PPP Over Ethernet Discovery Stage */ #define ETHTYPE_PPPOE 0x8864U /* PPP Over Ethernet Session Stage */ /** VLAN header inserted between ethernet header and payload * if &amp;lsquo;type&amp;rsquo; in ethernet header is ETHTYPE_VLAN.</description>
    </item>
    
    <item>
      <title>[转]各种工业以太网比较（EtherCAT,EtherNet/IP,ProfiNet,Modbus-TCP,Powerlink）</title>
      <link>/post/%E8%BD%AC%E5%90%84%E7%A7%8D%E5%B7%A5%E4%B8%9A%E4%BB%A5%E5%A4%AA%E7%BD%91%E6%AF%94%E8%BE%83ethercatethernetipprofinetmodbus-tcppowerlink/</link>
      <pubDate>Wed, 27 Jan 2016 06:15:31 +0000</pubDate>
      
      <guid>/post/%E8%BD%AC%E5%90%84%E7%A7%8D%E5%B7%A5%E4%B8%9A%E4%BB%A5%E5%A4%AA%E7%BD%91%E6%AF%94%E8%BE%83ethercatethernetipprofinetmodbus-tcppowerlink/</guid>
      <description>EtherCAT（以太网控制自动化技术）是一个以以太网为基础的开放架构的现场总线系统，EterCAT名称中的CAT为ControlAutomation Technology（控制自动化技术）首字母的缩写。最初由德国倍福自动化有限公司(Beckhoff AutomationGmbH)研发。EtherCAT为系统的实时性能和拓扑的灵活性树立了新的标准，同时，它还符合甚至降低了现场总线的使用成本。EtherCAT的特点还包括高精度设备同步，可选线缆冗余，和功能性安全协议(SIL3)。 Ethernet/IP是一个面向工业自动化应用的工业应用层协议。它建立在标准UDP/IP与TCP/IP协议之上，利用固定的以太网硬件和软件，为配置、访问和控制工业自动化设备定义了一个应用层协议西蒙公司开发 PROFINET由PROFIBUS国际组织（PROFIBUS International，PI）推出，是新一代基于工业以太网技术的自动化总线标准。作为一项战略性的技术创新，PROFINET为自动化通信领域提供了一个完整的网络解决方案，囊括了诸如实时以太网、运动控制、分布式自动化、故障安全以及网络安全等当前自动化领域的热点话题，并且，作为跨供应商的技术，可以完全兼容工业以太网和现有的现场总线（如PROFIBUS）技术，保护现有投资。
PROFINET是适用于不同需求的完整解决方案，其功能包括8个主要的模块，依次为实时通信、分布式现场设备、运动控制、分布式自动化、网络安装、IT标准和信息安全、故障安全和过程自动化。
 MODBUS/TCP是简单的、中立厂商的用于管理和控制自动化设备的MODBUS系列通讯协议的派生产品。显而易见，它覆盖了使用TCP/IP协议的 “Intranet”和“Internet”环境中MODBUS 报文的用途。协议的最通用用途是为诸如PLC’s，I/O模块，以及连接其它简单域总线或I/O模块的网关服务的。 MODBUS/TCP协议是作为一种（实际的）自动化标准发行的。既然MODBUS已经广为人知，该规范只将别处没有收录的少量信息列入其中。然而，本规范力图阐明MODBUS中哪种功能对于普通自动化设备的互用性有价值，哪些部分是MODBUS作为可编程的协议交替用于PLC’s的“多余部分”。 它通过将配套报文类型“一致性等级”，区别那些普遍适用的和可选的，特别是那些适用于特殊设备如PLC’s的报文。 POWERLINK=CANopen+Ethernet 鉴于以太网的蓬勃发展和CANopen在自动化领域里的广阔应用基础，EthernetPOWERLINK 融合了这两项技术的优点和缺点，即拥有了Ethernet的高速、开放性接口，以及CANopen在工业领域良好的SDO 和PDO 数据定义，在某种意义上说POWERLINK就是Ethernet 上的CANopen，物理层、数据链路层使用了Ethernet介质，而应用层则保留了原有的SDO和PDO对象字典的结构 虽然这些工业以太网都是国际标准，但是指的是IEC 61784里的标准，但是这些工业以太网不都是标准的以太网。即这些工业以太网并不都是符合IEEE802.3U的标准，这当中只有Modbus-TCP和EtherNet/IP是符合IEEE802.3U的，只有符合IEEE802.3U标准的，才能与IT和以太网将来的发展相兼容。而不符合IEEE802.3U标准的，基本上可以讲不是以太网，它们都对以太网进行了修改，或者是硬件或者是软件，已经不是以太网了。 各种工业以太网的区别其实主要就是协议的区别，其中最主要的还是应用层协议的区别，我们知道，按照ISO的参考模型，网络被划分为7层。 a. Modbus TCP和EtherNet/IP的区别主要是应用层不相同，ModbusTCP的应用层采用Modbus协议，而EtherNet/IP采用CIP协议，这两种工业以太网的数据链路层采用的是CSMA/CD，因此是标准的以太网，另外，这两种工业以太网的网络层和传输层采用TCP/IP协议族。还有一个区别是，Modbus协议中迄今没有协议来完成功能安全、高精度同步和运功控制等，而EtherNet/IP有CIPSafety、CIP Sync和CIP Motion来完成上述功能，所以才有Schneider加入ODVA，成为ODVA的核心成员来推广EtherNet/IP。由于这两种网络都是标准的TCP/IP以太网，所以所有标准以太网节点都可以接入这两种网络。 b. b. 至于EthernetPowerLink(EPL), Ethernet PowerLink就是个怪胎，PowerLink虽然在物理层和数据链路层还是采用标准的以太网，但是它又添加了另一个数据链路层，此EPL数据链路层在结构上为于以太网数据链路层之上。我们知道数据链路层的一个子层的MAC(介质访问)层的作用是[color=#FF0000]决定哪一个节点可以占有总线，也即决定哪个节点一个发送数据[/color]。所以本来由以太网的数据链路层来决定哪一个节点占用总线，现在它被位于它之上的EPL数据链路层给架空了，由这个EPL数据链路层通过软件的方式来决定哪个节点发送数据。所有在这样的一个EPL工业以太网系统中，不能使用交换机，只能使用HUB，所以对100M的网络，EPL总的带宽是小于100m,一盘情况下只有40－50M，而如果采用交换机的工业以太网，它的带宽可以达到大几百M,另外在EPL网络上，所有的节点都要实现EPL数据链路。没有实现EPL数据链路层的节点不能接入此网络。 c. PROFINET分为原来划分为v1,v2,v3，现在一般称为ProfiNetCBA、ProfiNet IO和ProfiNet IRT.也就是通过以太网来实现对等通讯、实时控制和运动控制。v1采用TCP/IP协议，采用标准的以太网，而V2和V3不采用tcp/ip协议，这两种都绕过tcp/ip协议，采用另外的网络层和传输层协议，开发ProfiNet采用开发人员人员认为tcp/ip协议增加了数据在网络中的传输延迟，其实这是一种误解，据美国密歇根大学的教授研究后认为数据在TCP/IP中的传输延迟很小，他们研究得出数据在经过TCP,IP栈时延迟只有不到100微秒，如果采用UDP/IP时就更小，同时他们研究也得出数据在不同应用层延时比较大，不同的协议延迟不一样，但是相差不是很大，从200us-800us不等，他们经过实验后认为以太网的基础设施(指交换机、网卡等）和TCP/IP协议并不是影响工业以太网实时性的主要原因，而认为应用层协议才是主要原因。所以密歇根大学的教授认为绕开TCP/IP协议没有丝毫的意义，反而由于缺少了TCP/IP协议，使得设备也就缺少了IT功能，与其它现场总线没有区别。 ProfiNet V3就更特别了，它不完全采用标准以太网的数据链路层，有一不时间采用以太网的数据链路层(CSMA/CD)，而另外一部分时间采用自己的数据链路层，通过一个高精度的时间来完成。所以ProfiNet V3也就不是标准的以太网了，也就给Profinet v3带来如下的问题：不能采用标准的交换机、不能采用标准的以太网芯片、与企业网相连可能会出现问题，与标准以太网相连还要特殊的网关、添加和删除一个节点都需要重新组态网络和重新启动网络、至今没有千兆网络，还有最重要的是，当标准以太网以后发展了后，它不能与标准以太网相兼容，不具有将来以太网所应具有的功能。 d. EtherCat这种工业以太网也很奇怪，它们不使用标准的芯片，一般不使用交换机，软件也不是标准的，对以太网的数据帧进行了一些修改，我们知道一个数据帧只有一个源节点，但是对于EtherCat一个数据可能有多个源节点，即一个数据是由多个节点发送的数据组合而成的。所以对于这样的网络，标准的以太网设备也不能接入这样的网络。 我认为Ethernet/IP和ProfiNet这两种工业以太网都适合各个行业，并不象heidai讲的应用的行业不一样。首先这两种工业以太网都用于传输非实时数据，还可传输实时数据，即可以用于离散控制，也可用于过程控制(当然现在还不能用于本安应用)。其次，这两种工业以太网都可用于网络功能安全传输，Ethernet/IP有CIP Safety协议，而ProfiNet有Profisafe协议,还有在运动控制方面ProfiNet有 ProfiNet IRT，而EtherNet/IP则有CIP Safety,二者都可以用于中高端的运动控制。最后两者都有基于IEEE1588的高精度时钟同步。而Modbus TCP,EtherCat和PowerLink,都只能完成部分控制任务，如Modbus TCP一般只作常规IO实时和非实时数据。而EtherCat和PowerLink则更象是为运动控制而开发的，这二者好像没有功能安全、在PLC和DCS控制方面也没有得到大自动化公司的支持，况且这两者又对以太网进行修改，一个在软件，另一个在软件和硬件方面都进行了修改，都不能兼容标准的以太网设备，个人认为这样做得不偿失，为满足运动控制而不能兼容已有的标准的以太网设备而开发的工业以太网并不是以太网，与其说是工业以太网还不如说是另一种现场总线。 我认为工业以太网的竞争将会在Ethernet/IP和ProfiNet间进行，而其它工业以太网都是这两者的陪衬，将会逐渐退出市场。 EtherNet/IP以后将由罗克韦尔自动化、Omron、施耐德和思科公司来推动，而ProfiNet将由业界老大西门子公司带领一些小公司去奋斗，由国内PLC厂商中的老二、老三和老五对老大，不知谁将引导未来。 其实，工业以太网里还有几个怪胎，举两个例吧： SynqNet: 丹纳赫主导的，几乎只用在运动控制，而且据说只用在了半导体机械行业（奇怪的是，不才也搞半导体机械很久了，却从来没看到过SynqNet，孤陋寡闻啊）。只用了以太网的硬件，完全和我们平常说的以太网没有任何关系，连MAC层都没有。当然如此运用，速度性能当然好，但未来难说。 Sercos III: 光纤SercosII的新一代以太网版本，背后推手是博世力士乐，只用在运动控制。也基本上是只用了以太网底层硬件，系统里竟然连switch都不允许用。速度当然快，但只比SercosII快了一倍。估计用了SercosII的用户，谁会去更新到一个没快了多少的新系统啊，还没问世，就已经不被业界看好了。 我个人认为，最后一定是大西洋两岸的两大巨人之间的角力，就像以前的现场总线战争，最后还不是Profibus和DeviceNet，别的都只能当陪衬的角色？ 当然，现在大家都在看中国这个大西洋两岸以外的单一最大市场，中国把砝码放在谁这一边，可能会使天平倾斜一点。但最后，肯定两者都会存在的。我个人认为，咱们应该选Ethernet/IP这一边站 中国用户和制造商应选择Ethernet/IP还是ProfiNet，各人的看法有所不同，不过我认为firstrazor所说的没错，有于ProfiNet采用了专门的芯片、网卡、交换机等以太网基础设施，虽然ProfiNet应用层协议是公开的，但这些芯片却是专用，国内的制造商要想开发符合ProfiNet标准的设备，确要依赖于这些芯片，受制于提供芯片的公司，也就是西门子公司，因此可以将ProfiNet并不是完全开放的。而相反，Ethernet/IP不论是在软件还是硬件上都是标准和开放的，国内的工业以太网制造商还是选择EtherNet/IP为好，至于最终用户的选择，当然是从可靠性、价格、兼容性和可替换性方面考虑，可靠性方面，二者没有明显区别，在其它方面Ethernet/IP具有明显的优势</description>
    </item>
    
    <item>
      <title>Libero 安装教程</title>
      <link>/post/libero-%E5%AE%89%E8%A3%85%E6%95%99%E7%A8%8B/</link>
      <pubDate>Thu, 07 Jan 2016 02:07:03 +0000</pubDate>
      
      <guid>/post/libero-%E5%AE%89%E8%A3%85%E6%95%99%E7%A8%8B/</guid>
      <description>在此记录下各种软件的安装教程，等到重装电脑时就会发现它的好处了。 这里 Libero 的版本是11.5。V11.3的版本有bug，不建议装。 去官网申请一个免费的Gold 1 year 的license. 可使用 Vol C: 查看Disk 序列号。 安装软件完毕后。 1. 放置license.dat文件到C:\flexlm\ 下。 2. 如果license 不是用你的disk序列号申请的，可用硬盘序列号修改器修改C盘序列号 。 3. 添加系统环境变量。 LM_LICENSE_FILE = c:\flexlm\license.dat; SNPSLMD_LICENSE_FILE = c:\flexlm\license.dat; 完成！</description>
    </item>
    
    <item>
      <title>Eclipse ARM IDE 开发环境搭建</title>
      <link>/post/eclipse-arm-ide-%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/</link>
      <pubDate>Sat, 12 Dec 2015 15:02:24 +0000</pubDate>
      
      <guid>/post/eclipse-arm-ide-%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/</guid>
      <description>一、Eclipse Eclipse的本身只是一个框架平台，但是众多插件的支持，使得Eclipse拥有较好的灵活性。依托于Java 环境运行，所以必须安装 Jre。 二、CDT CDT是Eclipse用于扩展Eclipse支持C/C++开发的插件。可直接下载带CDT的Eclipse。 三、Zylin CDT 支持Eclipse用于嵌入式C/C++开发和远程调试的插件。 四、Yagarto Yagarto是整合了GNU arm的交叉编译工具链，是一个跨平台的 ARM 架构开发平台。他们说了，由于基于MinGW的ToolChain 的GDB 跟Eclipse 配合不是很好，所以Yagarto 出现了。目前Yagarto 项目已经完结。此外Yagrato 建议使用免费的
 emIDE (free Visual Studio Style IDE including GNU Tools for ARM) 。其集成了GNU Tools。  五、J-LINK GDB Server A JTAG GDB Debug agent run on Host 六、IDE整体结构框图 安装： 1、安装Java SE 下载地址：http://www.oracle.com/technetwork/java/javase/downloads/jre-7u3-download-1501631.html 设置环境变量: 如果只安装Jre的话就添加 : JAVA_HOME = C:\Program Files\Java\jre1.8.0_65; 若是安装JDK的话就添加 : JAVA_HOME = C:\Program Files\Java\jdk1.8.0_65; Path = %JAVA_HOME%\bin;%JAVA_HOME%\jre\bin; //安装JDK时，JDK内部有个jre目录，外部也默认安装了一个jre目录。一般配置jre环境为内部jre目录。 CLASSPATH = .</description>
    </item>
    
    <item>
      <title>Beremiz 简介</title>
      <link>/post/beremiz-%E7%AE%80%E4%BB%8B/</link>
      <pubDate>Thu, 10 Dec 2015 07:36:06 +0000</pubDate>
      
      <guid>/post/beremiz-%E7%AE%80%E4%BB%8B/</guid>
      <description>Beremiz 是一各为自动化技术提供开放性源代码的软件，它的PLC平台可以支持IEC61131-3 五种开发语言，Beremiz 提供的子项目：
 PLCOpen 编辑器 : 提供自动化技术所需要的多平台 IDE （Integrated Development Environment） ； MatPLC&amp;rsquo;s IEC 编译器 : IEC 61131-3 编译器， 可以将结构化文本和指令表120 直接编译为 C 语言； CanFestival : CANOpen 接口服务于物理的输入/ 输出； SVGUI : 以 SVG为基础的自动化 HMI 工具； 所有软件都是提供源代码的， 使用了 PYTHON MINGW 等语言或者平台。  Beremiz软PLC 开发流程: MatIEC包含两个工具: 1. IEC2IEC工具将标准的IEC61131-3的5种语言统一转成ST格式， 2. IEC2C工具将ST格式用户代码转ANSI-C代码。 然后将所有代码通过GCC 工具编译成机器码运行。 </description>
    </item>
    
    <item>
      <title>[转]开源EtherCAT Master比较</title>
      <link>/post/%E8%BD%AC%E5%BC%80%E6%BA%90ethercat-master%E6%AF%94%E8%BE%83/</link>
      <pubDate>Wed, 25 Nov 2015 02:52:26 +0000</pubDate>
      
      <guid>/post/%E8%BD%AC%E5%BC%80%E6%BA%90ethercat-master%E6%AF%94%E8%BE%83/</guid>
      <description>EtherCAT的主站开发是基于EtherCAT机器人控制系统的开发中非常重要的环节。目前常见开源的主站代码为的RT-LAB开发的SOEM (Simple OpenSource EtherCAT Master)和EtherLab的the IgH EtherCAT® Master。使用起来SOEM的简单一些，而the IgH EtherCAT® Master更复杂一些，但对EtherCAT的实现更为完整。 具体比较如下表：
功能
SOME(Simple OpenSource EtherCAT Master)
IgH EtherCAT Master
版本
1.3.0
1.5.2
更新日期
2013-02-26
2013-02-12
发布公司
RT-LAB
EtherLab
官方网站
ethercat.rt-labs.com
www.etherlab.org
支持的操作系统
Linux,Windows
Linux
支持RT内核
RTAI, Xenomai
RTAI, Xenomai, RT-Preempt
支持的CPU
Freescale i.MX53 Blackfin 5xx Blackfin 6xx Intel
支持Linux内核的所有CPU
支持的网卡
-
8139too - RealTek 8139C (or compatible) Fast-Ethernet chipsets. •e1000 - Intel PRO/1000 Gigabit-Ethernet chipsets (PCI). •e100 - Intel PRO/100 Fast-Ethernet chipsets.</description>
    </item>
    
    <item>
      <title>Verdi201210 安装笔记</title>
      <link>/post/verdi201210-%E5%AE%89%E8%A3%85%E7%AC%94%E8%AE%B0/</link>
      <pubDate>Fri, 20 Nov 2015 07:02:41 +0000</pubDate>
      
      <guid>/post/verdi201210-%E5%AE%89%E8%A3%85%E7%AC%94%E8%AE%B0/</guid>
      <description>Verdi 为Debussy 在linux的底下的版本，windows版本Debussy已经不更新了。前面也在xp下试验过Debussy54 和modelsim联调，Debussy经常出错退出。于是果断放弃了。(Verdi用于查看代码和生成原理图，了解整个设计架构。modelsim主要还是用来进行仿真，获取波形和测试文档vcd，看不了原理图。) 这里在ubuntu 1204下安装Verdi201210。 安装步骤:
 下载 Verdi3-201210，及破解工具 novas_single.exe; 解压拷贝到所要安装Verdi的目录。这里要用到 tar -zxvf filename.tar.gz; 将压缩包全部解压。我是放在 /home/xxx/EDA/Verdi3_201210/ 下； 破解。windows 命令行下运行 novas_single -V2012.10 -FVerdi -MXXXXXXXXXXXX 。X为linux网卡的MAC地址，可用 ifconfig -a 查看eth0 的MAC。得到 novas_license_V6.0.txt。打开它，修改主机名为linux的主机名。或者在linux 下使用wine 工具运行破解工具。 在snslmgrd 之后添加snslmgrd的路径。  最后修改保存成license.dat 如下： SERVER ubuntu 000c29ee5f8a 28001 DAEMON snslmgrd /home/xxxx/EDA/Verdi3_201210/bin/snslmgrd FEATURE Verdi snslmgrd 2012.10 1-nov-2016 20 6E178584B60F25C09A15 \ VENDOR_STRING=ES=HJHJDBQQNLQKNNMHHBPP HOSTID=000c29ee5f8a \ ck=224 拷贝至Verdi所在目录的license文件夹下。
 修改环境变量 修改 /etc/.bashrc 文件。 ############################ export VERDI_HOME=&amp;rdquo;/home/xxxx/Verdi3_2010&amp;rdquo; export PATH=$VERDI_HOME/bin:$VERDI_HOME/platform/LINUX/bin:$PATH export LM_LICENSE_FILE=&amp;quot;$VERDI_HOME/license/novas_license.dat&amp;rdquo; alias lmgrd=&amp;quot;lmgrd $VERDI_HOME/license/novas_license.</description>
    </item>
    
    <item>
      <title>linux 常用命令笔记</title>
      <link>/post/linux-%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4%E7%AC%94%E8%AE%B0/</link>
      <pubDate>Fri, 20 Nov 2015 06:33:12 +0000</pubDate>
      
      <guid>/post/linux-%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4%E7%AC%94%E8%AE%B0/</guid>
      <description>1. 修改文件夹所有者  chown -R [owner] .. ; 修改当前目录下所有文件夹的所有都为owner, -R表示递归调用。
 2. 解压命令  tar -zxvf xxx;
-c: 建立压缩档案 -x：解压 -t：查看内容 -r：向压缩归档文件末尾追加文件 -u：更新原压缩包中的文件 这五个是独立的命令，压缩解压都要用到其中一个，可以和别的命令连用但只能用其中一个。下面的参数是根据需要在压缩或解压档案时可选的。 -z：有gzip属性的 -j：有bz2属性的 -Z：有compress属性的 -v：显示所有过程 -O：将文件解开到标准输出 下面的参数-f是必须的 -f: 使用档案名字，切记，这个参数是最后一个参数，后面只能接档案名。
创建用户 useradd 修改密码 passwd 安装包 apt-get install apt-get update //更新源 iptables iptables -nv -L //列出 netstat ps aux 查看进程</description>
    </item>
    
    <item>
      <title>Profinet 简介</title>
      <link>/post/profinet-%E7%AE%80%E4%BB%8B/</link>
      <pubDate>Tue, 27 Oct 2015 06:39:04 +0000</pubDate>
      
      <guid>/post/profinet-%E7%AE%80%E4%BB%8B/</guid>
      <description>Profinet 主要包括8个主要模块：实时通信、分布式现场设备、运动控制、分布式自动化、网络安装、IT标准和信息安全、故障安全和过程自动化。  Profinet 实时通信  PROFINET提供适应各种类型 设备的三种通信通道，而且在同 一个网络或设备上能够同时运行。 1.1 TCP/IP 标准通讯; 标准通道适用于具有100ms典型响应时间的简单设备。它能够用于设备的参数化和组态，例如用于读取诊断数据。 1.2 实时(RT)通讯; 对于典型循环时间低于10ms的场合，RT通道具有与最新现场总线系统相同级别的性能，在设备中RT通道能够采用软件方案实现，通道支持用户数据、事件驱动报文和报警等高性能周期传输。 传感器与执行器之间， 5~10ms。 1.3 同步实时(IRT)通讯; 循环时间小于1ms和抖动低于1μs的IRT通道用于高动态的驱动应用。IRT基于一个以太网芯片，用它在IRT网络中创建高动态特性。 运动控制， 响应时间&amp;lt; 1ms, 抖动误差&amp;lt;1us。
 兼容“开放的以太网 世界” 为了实现制造过程最佳化，可直接访问控制和生产级的所有自动化数据应该是生产计划管理系统最重要的因素。PROFINET使用以太网标准通信技术和IT技术，如OPC、XML、COM/DCOM、DHCP、SNMP、FTP或HTTP，与TCP/IP和RT技术一起共同将上述需求付诸实践。 Profinet 分布式现场设备  可以通过代理服务器将其它现场总线网络接入到Profinet中。
Profinet 运动控制  IRT中将通讯周期分成两个部分，一个是循环的、确定的实时通道；另外一个是标准通道，标准的TCP/IP数据通过这个通道传输。 。。。</description>
    </item>
    
    <item>
      <title>FG、LG、PG(PE)的定义及区别</title>
      <link>/post/fglgpgpe%E7%9A%84%E5%AE%9A%E4%B9%89%E5%8F%8A%E5%8C%BA%E5%88%AB/</link>
      <pubDate>Fri, 24 Jul 2015 07:03:09 +0000</pubDate>
      
      <guid>/post/fglgpgpe%E7%9A%84%E5%AE%9A%E4%B9%89%E5%8F%8A%E5%8C%BA%E5%88%AB/</guid>
      <description>FG與LG 都是接地端子 FG(Frame Ground): 是針對基板電路屏蔽用的接地端子, 主要是對高頻游離電磁波的屏蔽接地之用, 理論上應接於大地，一般将金属外壳，散热片，信号线缆屏蔽层等接于此，将噪声导入大地，或者防止触电。就是通常所认为的GR、PG(Protective Ground)，接地电阻要小于等于100欧姆。 LG(Line Ground)又叫(Functional Ground)不是(Logic Ground)： 是針對AC電源側低頻濾波器的接地, 主要是保持輸入電壓的電位準之用, 理論應與中性線連接。如果噪声是错误的主要来源 或者 有电击的问题， 则将FG 接入PG并一同接地，接地电阻要小于等于100欧姆。 所以 FG端是屬於信號端的接地, LG端是屬於電源端的接地, 二者雖都是接地, 在設計上端子仍是要分開的, 但一般在使用上, 除非AC中性線有帶電的現像, 否則你可以將FG及LG併接後一次接地既可。</description>
    </item>
    
    <item>
      <title>[转]Apache与Tomcat有什么关系和区别</title>
      <link>/post/%E8%BD%ACapache%E4%B8%8Etomcat%E6%9C%89%E4%BB%80%E4%B9%88%E5%85%B3%E7%B3%BB%E5%92%8C%E5%8C%BA%E5%88%AB/</link>
      <pubDate>Sun, 21 Jun 2015 09:36:55 +0000</pubDate>
      
      <guid>/post/%E8%BD%ACapache%E4%B8%8Etomcat%E6%9C%89%E4%BB%80%E4%B9%88%E5%85%B3%E7%B3%BB%E5%92%8C%E5%8C%BA%E5%88%AB/</guid>
      <description>经常在用apache和tomcat等这些服务器，可是总感觉还是不清楚他们之间有什么关系，在用tomcat的时候总出现apache，总感到迷惑，到底谁是主谁是次，因此特意在网上查询了一些这方面的资料，总结了一下： 一 apache支持静态页，tomcat支持动态的，比如servlet等，一般使用apache+tomcat的话，apache只是作为一个转发，对jsp的处理是由tomcat来处理的。 apache可以支持php\cgi\perl,但是要使用java的话，你需要tomcat在apache后台支撑，将java请求由apache转发给tomcat处理。 apache是web服务器,Tomcat是应用（java）服务器，它只是一个servlet(jsp也翻译成servlet)容器，可以认为是apache的扩展，但是可以独立于apache运行。 这两个有以下几点可以比较的： 1、两者都是apache组织开发的 2、两者都有HTTP服务的功能 3、两者都是免费的 不同点： Apache是专门用了提供HTTP服务的，以及相关配置的（例如虚拟主机、URL转发等等） Tomcat是Apache组织在符合J2EE的JSP、Servlet标准下开发的一个JSP服务器 二： APACHE是一个web服务器环境程序 启用他可以作为web服务器使用 不过只支持静态网页 如(asp,php,cgi,jsp)等动态网页的就不行 如果要在APACHE环境下运行jsp 的话就需要一个解释器来执行jsp网页 而这个jsp解释器就是TOMCAT, 为什么还要JDK呢？因为jsp需要连接数据库的话 就要jdk来提供连接数据库的驱程，所以要运行jsp的web服务器平台就需要APACHE+TOMCAT+JDK 整合的好处是： 如果客户端请求的是静态页面，则只需要Apache服务器响应请求 如果客户端请求动态页面，则是Tomcat服务器响应请求 因为jsp是服务器端解释代码的，这样整合就可以减少Tomcat的服务开销 三： apache:侧重于http server tomcat:侧重于servlet引擎，如果以standalone方式运行，功能上与apache等效 ， 支持JSP，但对静态网页不太理想； apache是web服务器，tomcat是应用（java）服务器，它只是一个servlet(jsp也翻译成servlet)容器，可以认为是apache的扩展，但是可以独立于apache运行。 换句话说，apache是一辆卡车，上面可以装一些东西如html等。但是不能装水，要装水必须要有容器（桶），而这个桶也可以不放在卡车上。</description>
    </item>
    
    <item>
      <title>Ethernet 的类型</title>
      <link>/post/ethernet-%E7%9A%84%E7%B1%BB%E5%9E%8B/</link>
      <pubDate>Sun, 21 Jun 2015 08:51:44 +0000</pubDate>
      
      <guid>/post/ethernet-%E7%9A%84%E7%B1%BB%E5%9E%8B/</guid>
      <description>通过学习以太网的类型，可以更好的了解以太网的工作原理。 共享式以太网 共享式以太网的典型代表是使用10Base2/10Base5的总线型网络和以集线器为核心的星型网络。在使用集线器的以太网中，集线器将很多以太网设备集中到一台中心设备上，这些设备都连接到集线器中的同一物理总线结构中。从本质上讲，以集线器为核心的以太网同原先的总线型以太网无根本区别。 集线器的工作原理： 集线器并不处理或检查其上的通信量，仅通过将一个端口接收的信号重复分发给其他端口来扩展物理介质。所有连接到集线器的设备共享同一介质，其结果是它们也共享同一冲突域、广播和带宽。因此集线器和它所连接的设备组成了一个单一的冲突域。如果一个节点发出一个广播信息，集线器会将这个广播传播给所有同它相连 的节点，因此它也是一个单一的广播域。 集线器的工作特点： 集线器多用于小规模的以太网，由于集线器一般使用外接电源（有源），对其接收的信号有放大处理。在某些场合，集线器也被称为“多端口中继器”。 集线器同中继器一样都是工作在物理层的网络设备。 共享式以太网存在的弊端：由于所有的节点都接在同一冲突域中，不管一个帧从哪里来或到哪里去，所有的节点都能接受到这个帧。随着节点的增加，大量的冲突将导致网络性能急剧下降。而且集线器同时只能传输一个数据帧，这意味着集线器所 有端口都要共享同一带宽。 交换式以太网 交换式结构： 在交换式以太网中，交换机根据收到的数据帧中的MAC地址决定数据帧应发向交换机的哪个端口。因为端口间的帧传输彼此屏蔽，因此节点就不担心自己发送的帧在通过交换机时是否会与其他节点发送的帧产生冲突。 为什么要用交换式网络替代共享式网络： ·减少冲突：交换机将冲突隔绝在每一个端口（每个端口都是一个冲突域），避免了冲突的扩散。 ·提升带宽：接入交换机的每个节点都可以使用全部的带宽，而不是各个节点共享带宽。</description>
    </item>
    
    <item>
      <title>Web 开发环境搭建</title>
      <link>/post/web-%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/</link>
      <pubDate>Sun, 21 Jun 2015 03:37:16 +0000</pubDate>
      
      <guid>/post/web-%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/</guid>
      <description>1.安装eclipse。 2. TOMCAT依赖JDK运行，必须安装JDK，光有JRE不行。 JDK的环境变量配置： （1）先配置 JAVA_HOME = C:\Program Files\Java\jdk1.8.0_77; （2）然后 PATH 里添加 %JAVA_HOME%\bin;%JAVA_HOME%\jre\bin;这两个目录，以便命令行里能直接寻到这里。 注意: 安装 JDK时会默认在外部安装一个JRE，这里TOMCAT是依赖JDK运行的，所以JRE的环境变量目录要用JDK文件夹里的那个JRE，不要配置成外部的JRE目录了。 运行java -version 不出现java版本的一般是这里没配置好。 （2）最后是 CLASSPATH = .;%JAVA_HOME%\lib;%JAVA_HOME%\lib\tools.jar; 注意：这里有三个目录，第一个是.; //表示当前工作目录，别丢了。运行TOMCAT时一闪而过一般是这个环境变量没设置好。 3. 安装 tomcat ，直接解压即可。 添加环境变量： CATALINA_HOME = D:\WebDev\apache-tomcat-6.0.45-windows-x64\apache-tomcat-6.0.45; //是你的tomcat目录。 PATH 里添加：%CATALINA_HOME%\bin; 点 bin/startup.bat直接可运行tomcat。或者命令行里打startup即可，若不行则是TOMCAT的 PATH变量没设置好。 尝试访问 http://localhost:8080，出现示例页说明配置成功。可以关闭控制台。 平时有要调试的网页文件可以拷到 webapps/ 底下，浏览器输入 http://localhost:8080/foldername/ 即可访问。 3.安装mysql。 eclipse 配置tomacat 路径方法. Window-&amp;gt;Preference-&amp;gt;Server-&amp;gt;Runtime Environments Add : 添加 Tomecat 路径，即可。</description>
    </item>
    
    <item>
      <title>从PC的总线到ARM内部总线</title>
      <link>/post/%E4%BB%8Epc%E7%9A%84%E6%80%BB%E7%BA%BF%E5%88%B0arm%E5%86%85%E9%83%A8%E6%80%BB%E7%BA%BF/</link>
      <pubDate>Mon, 09 Mar 2015 04:51:50 +0000</pubDate>
      
      <guid>/post/%E4%BB%8Epc%E7%9A%84%E6%80%BB%E7%BA%BF%E5%88%B0arm%E5%86%85%E9%83%A8%E6%80%BB%E7%BA%BF/</guid>
      <description>从PC的总线到ARM内部总线
来源: ChinaUnix博客 日期： 2009.07.18 23:45
从PC的总线到ARM内部总线 我在学习《Linux设备驱动程序（第3版）》的 第九章 与硬件通信 时，对 I\O总线的概念 不是很清晰，所以查找了有关资料。现在总结如下： 本文的参考资料： 1、 《AMBA、AHB、APB总线简介》 作者 adamzhao 日期 2006-11-16 19:33:00 转载网址： http://www.openhard.org/myspace/blog/show.php?id=75802 2、 《Introduction to AMBA Bus System 》台湾 工研院 / 系統晶片技術中心工程師 吳欣龍，PDF格式 下载地址： http://tpe-wh3.dwins.net/download/member_file/2002/soc/2002-5-1.pdf 3、 《PC架构系列：CPU/RAM/IO总线的发展历史！》 转载网址： http://blog.csdn.net/xport/archive/2006/11/16/1387928.aspx 4、 《认识物理I/O构件- 主机I/O总线(1)》作者：IT168存储频道 2007-04-10 原文网址： http://storage.it168.com/g/2007-04-10/200704101424234.shtml 总线的演变 首先应该讲讲总线的演变历史，这方面《PC架构系列：CPU/RAM/IO总线的发展历史！》这篇文章写得很好！感谢文章的作者！以下内容大量来自这篇文章，可以说是这篇文章的缩减转载。 [#toggle Title=&amp;quot;继续阅读&amp;rdquo;] 公共总线 早期PC中，CPU/RAM/IO都是挂在一条总线上，所有的部件都必须在同步的模式下工作。这样就带来一个&amp;quot;互锁&amp;rdquo; （locked to each other ）效应：所有设备都被限定在一个通用时钟频率（Clock Frequency）上面，整个系统的速度会被系统中最慢的设备限制，系统的整体性能无法提高。 南桥诞生（I\O总线诞生） 1987年，康柏（Compaq）公司想到一个办法: 将系统总线与I/O总线分开，使得2个不同的总线工作在不同的时钟频率上。CPU和内存工作在系统总线上（the System Bus），独立于所有的I/O设备。这样高速的CPU/RAM组件就摆脱了低速I/O设备的束缚。这里的Bridge，就是现在的南桥（South Bridge）芯片的前身，而它实际起到了降频的作用。 倍频出世 从80486开始，CPU的发展迅猛，频率大幅攀升。内存开始变得跟不上CPU的发展步伐了。Intel 于是决定在80486中引入倍频（Clock Doubler）的概念。内存依旧工作在系统总线上，与系统总线保持同样的工作频率，而CPU的内部工作频率（CPU主频）是： CPU 主频 = 外频（系统总线频率System Bus Frequency）* 倍频 (Clock doubler) 北桥和前端总线的诞生 PC结构的变化趋势是把低速设备与高速设备用隔离总线的方法进行隔离。而发展到后来，就演变出了北桥（North Bridge）芯片。内存与北桥间的总线称为内存总线，把CPU与北桥间连接的这段总线成为前端总线**(Front Side Bus，FSB），**也就是系统总线（System Bus）！ **PC中的I\O总线** 通过上面的文章，我们知道的总线的演变过程。现在专门来讲讲I\O总线。 总线：用来传送信号或能量的构造器。 系统 I/O 总线将指令从内存传导至与输入\输出处理器(IOP) [url=http://publib.</description>
    </item>
    
    <item>
      <title>Wordpress 修改域名后修改图片路径</title>
      <link>/post/wordpress-%E4%BF%AE%E6%94%B9%E5%9F%9F%E5%90%8D%E5%90%8E%E4%BF%AE%E6%94%B9%E5%9B%BE%E7%89%87%E8%B7%AF%E5%BE%84/</link>
      <pubDate>Sun, 08 Mar 2015 15:08:52 +0000</pubDate>
      
      <guid>/post/wordpress-%E4%BF%AE%E6%94%B9%E5%9F%9F%E5%90%8D%E5%90%8E%E4%BF%AE%E6%94%B9%E5%9B%BE%E7%89%87%E8%B7%AF%E5%BE%84/</guid>
      <description>[hermit auto=&amp;quot;1&amp;rdquo; loop=&amp;quot;0&amp;rdquo; unexpand=&amp;quot;0&amp;rdquo;]netease_songs#:65538[/hermit] WordPress更换域名 主页和图片路径错误 解决办法 首先介绍下SQL替换命令 UPDATE 表名 SET 字段 = REPLACE(字段,’替换内容’,&amp;lsquo;替换值’); eg： UPDATE wp_options SET option_value = REPLACE(option_value,&amp;lsquo;www.59a.cn&amp;rsquo;,&amp;lsquo;m59a.cn&amp;rsquo;); 其中wp_options就是表名，option_value就是表wp_options里的一个字段，wp_options里有siteurl和home的值。 一般只要执行以下命令，就可完成域名的修改： 1.修改option_value里的站点url和主页地址： UPDATE wp_options SET option_value = replace(option_value, &amp;lsquo;http://www.59a.cn&amp;rsquo;, &amp;lsquo;http://www.new-59a.cn&amp;rsquo;) WHERE option_name = &amp;lsquo;home&amp;rsquo; OR option_name = &amp;lsquo;siteurl&amp;rsquo;; 2.更正文章中内部链接及附件的地址, 主要是一些图片路径： UPDATE wp_posts SET post_content = replace(post_content, &amp;lsquo;http://www.59a.cn&amp;rsquo;, &amp;lsquo;http://www.new-59a.cn&amp;rsquo;); 3.更正wordpress文章默认的永久链接： UPDATE wp_posts SET guid = replace(guid, &amp;lsquo;http://www.59a.cn&amp;rsquo;,&amp;lsquo;http://www.new-59a.cn&amp;rsquo;);</description>
    </item>
    
    <item>
      <title>keil 5.0： pack installer Reading one or more Pack discriptions failed 报错的问题</title>
      <link>/post/keil-5.0-pack-installer-reading-one-or-more-pack/</link>
      <pubDate>Fri, 27 Dec 2013 13:31:52 +0000</pubDate>
      
      <guid>/post/keil-5.0-pack-installer-reading-one-or-more-pack/</guid>
      <description>http://www.keil.com/support/docs/3646.htm 按照链接所说的是Keil5.0不支持这些新版本的DFP，需要换Keil5.01. http://www.keil.com/dd2/pack/ 有点奇怪这里有V1.0版本的DFP为什么导进去也不成功呢？ http://www2.keil.com/mdk5/legacy 后来下载了legacy support，包括Cortex M系列和ARM7和ARM9的在Keil4.73版本里面的两个Device 包，这个是Keil5.0支持的。 然后，果断升级了keil5.1. 发现了一个规律，只要在之前破解版的基础上覆盖安装到V5.01都是不需要再破解的直接就是标准版的了，再加上那两个包就能完全兼容老版本支持的设备。。</description>
    </item>
    
    <item>
      <title>嵌入式系统分层（转自电子发烧友）</title>
      <link>/post/%E5%B5%8C%E5%85%A5%E5%BC%8F%E7%B3%BB%E7%BB%9F%E5%88%86%E5%B1%82%E8%BD%AC%E8%87%AA%E7%94%B5%E5%AD%90%E5%8F%91%E7%83%A7%E5%8F%8B/</link>
      <pubDate>Thu, 26 Dec 2013 15:36:37 +0000</pubDate>
      
      <guid>/post/%E5%B5%8C%E5%85%A5%E5%BC%8F%E7%B3%BB%E7%BB%9F%E5%88%86%E5%B1%82%E8%BD%AC%E8%87%AA%E7%94%B5%E5%AD%90%E5%8F%91%E7%83%A7%E5%8F%8B/</guid>
      <description>一、嵌入式系统的分层与专业的分类。 嵌入式系统分为4层，硬件层、驱动层、操作系统层和应用层。 1、硬件层，是整个嵌入式系统的根本，如果现在单片机及接口这块很熟悉，并且能用C和汇编语言来编程的话，从嵌入式系统的硬件层走起来相对容易，硬件 层也是驱动层的基础，一个优秀的驱动工程师是要能够看懂硬件的电路图和自行完成CPLD的逻辑设计的，同时还要对操作系统内核及其调度性相当的熟悉的。但 硬件平台是基础，增值还要靠软件。 硬件层比较适合于，电子、通信、自动化、机电一体、信息工程类专业的人来搞，需要掌握的专业基础知识有，单片机原理及接口技术、微机原理及接口技术、C语言。 2、 驱动层，这部分比较难，驱动工程师不仅要能看懂电路图还要能对操作系统内核十分的精通，以便其所写的驱动程序在系统调用时，不会独占操作系统时间片，而导 至其它任务不能动行，不懂操作系统内核架构和实时调度性，没有良好的驱动编写风格，按大多数书上所说添加的驱动的方式，很多人都能做到，但可能连个初级的 驱动工程师的水平都达不到，这样所写的驱动在应用调用时就如同windows下我们打开一个程序运行后，再打开一个程序时，要不就是中断以前的程序，要不 就是等上一会才能运行后来打开的程序。想做个好的驱动人员没有三、四年功底，操作系统内核不研究上几编，不是太容易成功的，但其工资在嵌入式系统四层中可 是最高的。 驱动层比较适合于电子、通信、自动化、机电一体、信息工程类专业尤其是计算机偏体系结构类专业的人来搞，除硬件层所具备的基础学科外，还要对数据结构与算法、操作系统原理、编译原理都要十分精通了解。 3、操作系统层，对于操作系统层目前可能只能说是简单的移植，而很少有人来自已写操作系统，或者写出缺胳膊少腿的操作系统来，这部分工作大都由驱动工 程师来完成。操作系统是负责系统任务的调试、磁盘和文件的管理，而嵌入式系统的实时性十分重要。据说，XP操作系统是微软投入300人用两年时间才搞定 的，总时工时是600人年，中科院软件所自己的女娲Hopen操作系统估计也得花遇几百人年才能搞定。因此这部分工作相对来讲没有太大意义。 4、应用层，相对来讲较为容易的，如果会在windows下如何进行编程接口函数调用，到操作系统下只是编译和开发环 境有相应的变化而已。如果涉及Jave方面的编程也是如此的。嵌入式系统中涉及算法的由专业算法的人来处理的，不必归结到嵌入式系统范畴内。但如果涉及嵌 入式系统下面嵌入式数据库、基于嵌入式系统的网络编程和基于某此应用层面的协议应用开发（比如基于SIP、H.323、Astrisk）方面又较为复杂， 并且有难度了。</description>
    </item>
    
    <item>
      <title>S3C2440外围设备（peripherals）</title>
      <link>/post/s3c2440%E5%A4%96%E5%9B%B4%E8%AE%BE%E5%A4%87peripherals/</link>
      <pubDate>Sun, 22 Dec 2013 15:08:09 +0000</pubDate>
      
      <guid>/post/s3c2440%E5%A4%96%E5%9B%B4%E8%AE%BE%E5%A4%87peripherals/</guid>
      <description>1.它与单片机有啥区别呢？ 比我们常见的单片机多了这些东西： External memory controller, LCD controller, AC‘97 CODEC interface, USB Host, Camera interface. 
图1 S3C2440外围

图 ARM920T内核</description>
    </item>
    
    <item>
      <title>关于冯.诺伊曼架构和哈佛架构</title>
      <link>/post/%E5%85%B3%E4%BA%8E%E5%86%AF.%E8%AF%BA%E4%BC%8A%E6%9B%BC%E6%9E%B6%E6%9E%84%E5%92%8C%E5%93%88%E4%BD%9B%E6%9E%B6%E6%9E%84/</link>
      <pubDate>Mon, 16 Dec 2013 15:03:08 +0000</pubDate>
      
      <guid>/post/%E5%85%B3%E4%BA%8E%E5%86%AF.%E8%AF%BA%E4%BC%8A%E6%9B%BC%E6%9E%B6%E6%9E%84%E5%92%8C%E5%93%88%E4%BD%9B%E6%9E%B6%E6%9E%84/</guid>
      <description>典型的冯.诺伊曼架CPU是x86的CPU。pc机cpu在运行的时候程序是存储在RAM即内存中的，需要运行的程序从硬盘、U盘等外存读取加载进内存中供CPU高速运行（CPU不可能从外存中直接读取指令），所以程序和数据都是放在内存中的。取指令和取操作数都在同一总线上，通过分时复用的方式进行的。缺点是在高速运行时，不能达到同时取指令和取操作数，从而形成了传输过程的瓶颈。 而大多数单片机等嵌入式系统则是存于flash中，flash逐步取代较古老ROM。单片机的程序是固化在flash中，cpu运行时直接从flash中读取程序，从RAM中读取数据。即程序和数据分开存储，而且单片的片内RAM资源是相当有限的，内部的RAM过大会带来成本的大幅度提高。 哈佛总线技术应用是以DSP和ARM为代表的。采用哈佛总线体系结构的芯片内部程序空间和数据空间是分开的，这就允许同时取指令和取操作数，从而大大提高了运算能力。它们都有独立的程序地址总线（PAB），数据地址读总线（DRAB）和数据地址写总线（DWRB）。</description>
    </item>
    
    <item>
      <title>关于ADS V1.2开发环境</title>
      <link>/post/%E5%85%B3%E4%BA%8Eads-v1.2%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83/</link>
      <pubDate>Sun, 15 Dec 2013 15:42:59 +0000</pubDate>
      
      <guid>/post/%E5%85%B3%E4%BA%8Eads-v1.2%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83/</guid>
      <description>从开始用freescale 的CodeWarrior起到这个ADS V1.2 ,一直认为这个开发环境做得不好。有几个问题。 1.当make完之后在xx.o文件报错有不明物体，双击这条error, 它没帮你定位到xx.c里。以至于你还得打开xx.c CTRL+F，找出这个不明物体。这很烦，有时候会觉得这个编译器很无语。 2.ADS V1.2的工程管理不能靠边？dock，至今没找到这个功能。。以至于窗口管理乱糟糟的。</description>
    </item>
    
    <item>
      <title>嵌入式开学-先认识硬件</title>
      <link>/post/%E5%B5%8C%E5%85%A5%E5%BC%8F%E5%BC%80%E5%AD%A6-%E5%85%88%E8%AE%A4%E8%AF%86%E7%A1%AC%E4%BB%B6/</link>
      <pubDate>Sun, 15 Dec 2013 15:28:03 +0000</pubDate>
      
      <guid>/post/%E5%B5%8C%E5%85%A5%E5%BC%8F%E5%BC%80%E5%AD%A6-%E5%85%88%E8%AE%A4%E8%AF%86%E7%A1%AC%E4%BB%B6/</guid>
      <description>这里使用的是TQ2440开发板，CPU 一般运行在400M的时钟频率。核心板载有两片Hynix(海力士,又叫现代内存)256Mb的SDRAM合64MB的内存，256MB SAMSUNG 的Nand flash，2MB 的Eon（宜扬） 的Nor flash。 首先，Nor flash 和 Nand flash 的区别？ Nor flash的有自己的地址线和数据线，操作以字为单位，可以采用类似于memory的随机访问方式，在nor flash上可以直接运行程序，所以nor flash可以直接用来做boot，采用nor flash启动的时候会把地址映射到0x00上。类似于计算机内BIOS的存放位置。 Nand flash是IO设备，类似于计算机的硬盘，数据、地址、控制线都是共用的，需要软件区控制读取时序，更**无法挂在ARM的程序空间，**所以不能像nor flash、内存一样随机访问，不能EIP（片上运行），因此不能直接作为boot。一般Nand flash 用来存储系统程序，系统上电后由Nor flash中的BootLoader将系统加载进RAM中的可执行地址中运行，然后跳到主程序中运行。（这有点像冯.诺伊曼架构，程序和数据都在RAM中）。Nand flash在读取数据量较大的成块数据时，速度较快。</description>
    </item>
    
    <item>
      <title>几种常见的开关电源拓扑</title>
      <link>/post/%E5%87%A0%E7%A7%8D%E5%B8%B8%E8%A7%81%E7%9A%84%E5%BC%80%E5%85%B3%E7%94%B5%E6%BA%90%E6%8B%93%E6%89%91/</link>
      <pubDate>Sun, 01 Dec 2013 16:02:43 +0000</pubDate>
      
      <guid>/post/%E5%87%A0%E7%A7%8D%E5%B8%B8%E8%A7%81%E7%9A%84%E5%BC%80%E5%85%B3%E7%94%B5%E6%BA%90%E6%8B%93%E6%89%91/</guid>
      <description>1.降压型（Buck）变换器 2.升压型（Boost）变换器 3.极性反转型升降压（Buck-Boost）变换器 4.Cuk变换器 5.单端正、反激式变换器 6.推挽变换器 7.半桥、全桥变换器</description>
    </item>
    
    <item>
      <title>About</title>
      <link>/about/</link>
      <pubDate>Sun, 01 Dec 2013 15:50:13 +0000</pubDate>
      
      <guid>/about/</guid>
      <description>一个本该好好玩音乐的年纪，选择了为人类智慧高楼添砖加瓦的工作。 由于个人大脑存储空间有限，本博客作为临时存储区，那如果你在浏览过程中能够有所收获，自然也是极好的。 #include: Music，FPGA, verilog, C, Embedded systems, network, python, Vision, Image processing, Deep Learning.  欢迎多多交流</description>
    </item>
    
    <item>
      <title>基于Altera FPGA的 摄像头&#43;LCD DIY</title>
      <link>/post/%E5%9F%BA%E4%BA%8Ealtera-fpga%E7%9A%84-%E6%91%84%E5%83%8F%E5%A4%B4&#43;lcd-diy/</link>
      <pubDate>Sat, 30 Nov 2013 09:54:20 +0000</pubDate>
      
      <guid>/post/%E5%9F%BA%E4%BA%8Ealtera-fpga%E7%9A%84-%E6%91%84%E5%83%8F%E5%A4%B4&#43;lcd-diy/</guid>
      <description>前些日子买了个大家玩得很火的OV7670来玩玩，由于之前没玩过摄像头，也听说不带FIFO的摄像头采集起来是那么困难，所以就买了个不带FIFO的来尝尝鲜。后来看了资料才知道，一幅QVGA的图像按320*240*2Byte来算，也要153.6KB内存，对单片机来说是一比不小的开销。更何况单片机的速率才多少M，就按50M主频来说，捕捉一个8M左右的像素时钟也是相当困难的。当然后面也用STM32F103ZET6来尝试捕捉了一下，结果也是不尽人意。 考虑到时钟的捕捉，当然是用FPGA的硬件电路来实现才是王道了。又想想摄像头和液晶屏的初始化也是相当麻烦的，如果也用硬件电路来实现，那写起代码来就是一大串了，而且改起来也不方便。于是乎，脑子里一直存在的一个想法在这里就能得到真正的应用和实现了。那就是MCU与FPGA结合的方案。手上正有一款Altera 的EP2C8Q208C的开发板。那么我们的DIY就开始了。
  首先要准备的东西就是 一个OV7670摄像头，一块TFT液晶屏，一块FPGA核心板。使用Nios II做为主控MCU会使你的DIY简洁很多。系统主要的结构就如下：
  一个Nios II MCU，一个VGA转8080并口的模块VGA_8080，一个MCU与VGA_8080模块分别对LCD控制的总线切换模块。模块分工，MCU负责初始化液晶屏和OV7670。 VGA_8080负责OV7670的VGA输出时序转换成LCD的16bit的8080并口时序 。由于我的LCD是320*240的，所以我们只 使用QVGA输出，并且LCD使用的是565的像素格式，我们也将OV7670配置成565像素格式，这样能够使我们的编程方便很多。 我们的主要任务分为以下几块：1.nios ii MCU的搭建; 2.nios ii软件程序的编写；3.fpga硬件代码的编写。 一、NIOS ii MCU搭建可参考《NIOS ii 那些事儿》，硬件上要求板子上带有SDRAM, 否则内存不够会很麻烦。等系统整体编译通过后可以把代码写入flash当中，这样每次掉电后开机就能直接运行了。主要配置一个LCD的控制口，SDRAM的控制口，OV7670的SCCB控制口。这里有几个注意点：1.FPGA的双向口处理，由于SCCB的SIOD数据口是双向的，所以在配置时要配置成双向口，画顶层Pin时也要用bidir。2.本来液晶屏的数据口也是双向的，但是在FPGA内部没有三态门，按顶层那样的连接无法实现双向，要实现的话只能通过将IO口引出来，再把IO口连接到其它pin脚输入，不过这样很麻烦，就省了，LCD代码中要改动LCD读数据的部分。（不知道各位还有什么好办法能实现内部的双向口？） 二、然后就是LCD代码，和OV7670初始化代码的移植，之前都是在STM32上跑的，想办法把它们移植到NIOS ii当中，基本上只需修改IO口读写部分的代码就行了。 三、关键部分就是FPGA硬件上实现 OV7670的QVGA时序到液晶屏读写时序的转换。Bus_Switcher就是个2选一的多路选择器，负责切换LCD的控制总线。在主MCU初始化液晶屏和OV7670之后，就把液晶屏的控制总线交给VGA_8080控制模块，直接将OV7670的QVGA时序写入到液晶屏的GRAM当中，这样显示的帧频就能达到很高，画面非常流畅。在后期设计中可以再设置一个存储器，将图片保存下来。这里仅仅实现的摄像头信号的高速显示。这里的代码基本上可达到要求了，还有些小细节要优化，后期还可以添加一系列按钮调整OV7670的各种参数，非常之方便。
 module VGA_8080(iclk, rst_n, XCLK, HREF, VSYNC, PCLK, C_DATA, LCD_CS, LCD_WR, LCD_RD, LCD_RS, LCD_RST, LCD_DATA); input rst_n; input iclk; // camera IO; output XCLK; input HREF, VSYNC, PCLK; input [7:0] C_DATA; //LCD IO; output LCD_WR, LCD_RD, LCD_RS, LCD_RST, LCD_CS; output [15:0] LCD_DATA;</description>
    </item>
    
    <item>
      <title>第一篇博文</title>
      <link>/post/%E7%AC%AC%E4%B8%80%E7%AF%87%E5%8D%9A%E6%96%87/</link>
      <pubDate>Tue, 26 Nov 2013 14:24:26 +0000</pubDate>
      
      <guid>/post/%E7%AC%AC%E4%B8%80%E7%AF%87%E5%8D%9A%E6%96%87/</guid>
      <description>感谢心心蔷薇阁同学的辛勤劳动和大力支持！本工作室终于建成了！</description>
    </item>
    
    <item>
      <title>嵌入式 GUI 设计心得</title>
      <link>/post/%E5%B5%8C%E5%85%A5%E5%BC%8F-gui-%E8%AE%BE%E8%AE%A1%E5%BF%83%E5%BE%97/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>/post/%E5%B5%8C%E5%85%A5%E5%BC%8F-gui-%E8%AE%BE%E8%AE%A1%E5%BF%83%E5%BE%97/</guid>
      <description>GUI，（Graphic User Interface) 为图形用户接口。其从用户角度出发进行程序设计。主要包括输入事件，如：按键、触屏、定时触发事件、动作事件等。输出接口，如显示、振动等。
emWin GUI, GUI 主任务负责检查处理输入事件、更新对应输出。其核心是给用户显示出其当前操作的状态结果。相对其它实时性要求很高的任务，GUI的任务优先级应该是最低的。
嵌入式系统裁剪的是代码，增加的是开发者呕心沥血的工作量。若不是量特别大，是不建议深入开发的，只能停留在Demo 阶段，玩玩是可以。因为开发者良苦用心的工作，等几年后硬件升级了，这些工作全部都没有价值了。当时费心费力的省内存，省空间，优化CPU，这些价值全部归零。想想当年的51单片机就是这样。所以觉得做嵌入式一直不被开发者看好。能坚持下去的都是一些有独特爱好的玩家。</description>
    </item>
    
  </channel>
</rss>